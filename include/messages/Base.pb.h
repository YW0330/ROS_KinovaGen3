// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Base.proto

#ifndef PROTOBUF_Base_2eproto__INCLUDED
#define PROTOBUF_Base_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Common.pb.h"  // IWYU pragma: export
#include "Errors.pb.h"  // IWYU pragma: export
#include "ProductConfiguration.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace protobuf_Base_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[166];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsGpioConfigurationListImpl();
void InitDefaultsGpioConfigurationList();
void InitDefaultsGpioConfigurationImpl();
void InitDefaultsGpioConfiguration();
void InitDefaultsGpioPinConfigurationImpl();
void InitDefaultsGpioPinConfiguration();
void InitDefaultsFullUserProfileImpl();
void InitDefaultsFullUserProfile();
void InitDefaultsUserProfileImpl();
void InitDefaultsUserProfile();
void InitDefaultsUserProfileListImpl();
void InitDefaultsUserProfileList();
void InitDefaultsUserListImpl();
void InitDefaultsUserList();
void InitDefaultsPasswordChangeImpl();
void InitDefaultsPasswordChange();
void InitDefaultsSequenceHandleImpl();
void InitDefaultsSequenceHandle();
void InitDefaultsAdvancedSequenceHandleImpl();
void InitDefaultsAdvancedSequenceHandle();
void InitDefaultsSequenceTaskHandleImpl();
void InitDefaultsSequenceTaskHandle();
void InitDefaultsSequenceTaskImpl();
void InitDefaultsSequenceTask();
void InitDefaultsSequenceTasksImpl();
void InitDefaultsSequenceTasks();
void InitDefaultsSequenceTasksConfigurationImpl();
void InitDefaultsSequenceTasksConfiguration();
void InitDefaultsSequenceTaskConfigurationImpl();
void InitDefaultsSequenceTaskConfiguration();
void InitDefaultsSequenceTasksRangeImpl();
void InitDefaultsSequenceTasksRange();
void InitDefaultsSequenceTasksPairImpl();
void InitDefaultsSequenceTasksPair();
void InitDefaultsSequenceImpl();
void InitDefaultsSequence();
void InitDefaultsSequenceListImpl();
void InitDefaultsSequenceList();
void InitDefaultsAppendActionInformationImpl();
void InitDefaultsAppendActionInformation();
void InitDefaultsActionHandleImpl();
void InitDefaultsActionHandle();
void InitDefaultsRequestedActionTypeImpl();
void InitDefaultsRequestedActionType();
void InitDefaultsActionImpl();
void InitDefaultsAction();
void InitDefaultsSnapshotImpl();
void InitDefaultsSnapshot();
void InitDefaultsSwitchControlMappingImpl();
void InitDefaultsSwitchControlMapping();
void InitDefaultsChangeTwistImpl();
void InitDefaultsChangeTwist();
void InitDefaultsChangeJointSpeedsImpl();
void InitDefaultsChangeJointSpeeds();
void InitDefaultsChangeWrenchImpl();
void InitDefaultsChangeWrench();
void InitDefaultsEmergencyStopImpl();
void InitDefaultsEmergencyStop();
void InitDefaultsFaultsImpl();
void InitDefaultsFaults();
void InitDefaultsDelayImpl();
void InitDefaultsDelay();
void InitDefaultsStopImpl();
void InitDefaultsStop();
void InitDefaultsActionListImpl();
void InitDefaultsActionList();
void InitDefaultsTimeoutImpl();
void InitDefaultsTimeout();
void InitDefaultsSsidImpl();
void InitDefaultsSsid();
void InitDefaultsCommunicationInterfaceConfigurationImpl();
void InitDefaultsCommunicationInterfaceConfiguration();
void InitDefaultsNetworkHandleImpl();
void InitDefaultsNetworkHandle();
void InitDefaultsIPv4ConfigurationImpl();
void InitDefaultsIPv4Configuration();
void InitDefaultsIPv4InformationImpl();
void InitDefaultsIPv4Information();
void InitDefaultsFullIPv4ConfigurationImpl();
void InitDefaultsFullIPv4Configuration();
void InitDefaultsWifiInformationImpl();
void InitDefaultsWifiInformation();
void InitDefaultsWifiInformationListImpl();
void InitDefaultsWifiInformationList();
void InitDefaultsWifiConfigurationImpl();
void InitDefaultsWifiConfiguration();
void InitDefaultsWifiConfigurationListImpl();
void InitDefaultsWifiConfigurationList();
void InitDefaultsProtectionZoneHandleImpl();
void InitDefaultsProtectionZoneHandle();
void InitDefaultsRotationMatrixRowImpl();
void InitDefaultsRotationMatrixRow();
void InitDefaultsRotationMatrixImpl();
void InitDefaultsRotationMatrix();
void InitDefaultsPointImpl();
void InitDefaultsPoint();
void InitDefaultsZoneShapeImpl();
void InitDefaultsZoneShape();
void InitDefaultsProtectionZoneImpl();
void InitDefaultsProtectionZone();
void InitDefaultsProtectionZoneListImpl();
void InitDefaultsProtectionZoneList();
void InitDefaultsCartesianLimitationImpl();
void InitDefaultsCartesianLimitation();
void InitDefaultsTwistLimitationImpl();
void InitDefaultsTwistLimitation();
void InitDefaultsWrenchLimitationImpl();
void InitDefaultsWrenchLimitation();
void InitDefaultsCartesianLimitationListImpl();
void InitDefaultsCartesianLimitationList();
void InitDefaultsJointLimitationImpl();
void InitDefaultsJointLimitation();
void InitDefaultsJointsLimitationsListImpl();
void InitDefaultsJointsLimitationsList();
void InitDefaultsQueryImpl();
void InitDefaultsQuery();
void InitDefaultsConfigurationChangeNotificationImpl();
void InitDefaultsConfigurationChangeNotification();
void InitDefaultsMappingInfoNotificationImpl();
void InitDefaultsMappingInfoNotification();
void InitDefaultsControlModeInformationImpl();
void InitDefaultsControlModeInformation();
void InitDefaultsControlModeNotificationImpl();
void InitDefaultsControlModeNotification();
void InitDefaultsServoingModeInformationImpl();
void InitDefaultsServoingModeInformation();
void InitDefaultsOperatingModeInformationImpl();
void InitDefaultsOperatingModeInformation();
void InitDefaultsOperatingModeNotificationImpl();
void InitDefaultsOperatingModeNotification();
void InitDefaultsServoingModeNotificationImpl();
void InitDefaultsServoingModeNotification();
void InitDefaultsSequenceInfoNotificationImpl();
void InitDefaultsSequenceInfoNotification();
void InitDefaultsSequenceInformationImpl();
void InitDefaultsSequenceInformation();
void InitDefaultsProtectionZoneNotificationImpl();
void InitDefaultsProtectionZoneNotification();
void InitDefaultsProtectionZoneInformationImpl();
void InitDefaultsProtectionZoneInformation();
void InitDefaultsUserNotificationImpl();
void InitDefaultsUserNotification();
void InitDefaultsControllerHandleImpl();
void InitDefaultsControllerHandle();
void InitDefaultsControllerElementHandleImpl();
void InitDefaultsControllerElementHandle();
void InitDefaultsControllerNotificationImpl();
void InitDefaultsControllerNotification();
void InitDefaultsControllerListImpl();
void InitDefaultsControllerList();
void InitDefaultsControllerStateImpl();
void InitDefaultsControllerState();
void InitDefaultsControllerElementStateImpl();
void InitDefaultsControllerElementState();
void InitDefaultsActionNotificationImpl();
void InitDefaultsActionNotification();
void InitDefaultsTrajectoryInfoImpl();
void InitDefaultsTrajectoryInfo();
void InitDefaultsActionExecutionStateImpl();
void InitDefaultsActionExecutionState();
void InitDefaultsRobotEventNotificationImpl();
void InitDefaultsRobotEventNotification();
void InitDefaultsFactoryNotificationImpl();
void InitDefaultsFactoryNotification();
void InitDefaultsNetworkNotificationImpl();
void InitDefaultsNetworkNotification();
void InitDefaultsConfigurationChangeNotificationListImpl();
void InitDefaultsConfigurationChangeNotificationList();
void InitDefaultsMappingInfoNotificationListImpl();
void InitDefaultsMappingInfoNotificationList();
void InitDefaultsControlModeNotificationListImpl();
void InitDefaultsControlModeNotificationList();
void InitDefaultsOperatingModeNotificationListImpl();
void InitDefaultsOperatingModeNotificationList();
void InitDefaultsServoingModeNotificationListImpl();
void InitDefaultsServoingModeNotificationList();
void InitDefaultsSequenceInfoNotificationListImpl();
void InitDefaultsSequenceInfoNotificationList();
void InitDefaultsProtectionZoneNotificationListImpl();
void InitDefaultsProtectionZoneNotificationList();
void InitDefaultsUserNotificationListImpl();
void InitDefaultsUserNotificationList();
void InitDefaultsSafetyNotificationListImpl();
void InitDefaultsSafetyNotificationList();
void InitDefaultsControllerNotificationListImpl();
void InitDefaultsControllerNotificationList();
void InitDefaultsActionNotificationListImpl();
void InitDefaultsActionNotificationList();
void InitDefaultsRobotEventNotificationListImpl();
void InitDefaultsRobotEventNotificationList();
void InitDefaultsNetworkNotificationListImpl();
void InitDefaultsNetworkNotificationList();
void InitDefaultsMappingHandleImpl();
void InitDefaultsMappingHandle();
void InitDefaultsSafetyEventImpl();
void InitDefaultsSafetyEvent();
void InitDefaultsControllerEventImpl();
void InitDefaultsControllerEvent();
void InitDefaultsGpioEventImpl();
void InitDefaultsGpioEvent();
void InitDefaultsMapEventImpl();
void InitDefaultsMapEvent();
void InitDefaultsMapElementImpl();
void InitDefaultsMapElement();
void InitDefaultsActivateMapHandleImpl();
void InitDefaultsActivateMapHandle();
void InitDefaultsMapImpl();
void InitDefaultsMap();
void InitDefaultsMapHandleImpl();
void InitDefaultsMapHandle();
void InitDefaultsMapListImpl();
void InitDefaultsMapList();
void InitDefaultsMapGroupHandleImpl();
void InitDefaultsMapGroupHandle();
void InitDefaultsMapGroupImpl();
void InitDefaultsMapGroup();
void InitDefaultsMapGroupListImpl();
void InitDefaultsMapGroupList();
void InitDefaultsMappingImpl();
void InitDefaultsMapping();
void InitDefaultsMappingListImpl();
void InitDefaultsMappingList();
void InitDefaultsTransformationMatrixImpl();
void InitDefaultsTransformationMatrix();
void InitDefaultsTransformationRowImpl();
void InitDefaultsTransformationRow();
void InitDefaultsPoseImpl();
void InitDefaultsPose();
void InitDefaultsPositionImpl();
void InitDefaultsPosition();
void InitDefaultsOrientationImpl();
void InitDefaultsOrientation();
void InitDefaultsCartesianSpeedImpl();
void InitDefaultsCartesianSpeed();
void InitDefaultsCartesianTrajectoryConstraintImpl();
void InitDefaultsCartesianTrajectoryConstraint();
void InitDefaultsJointTrajectoryConstraintImpl();
void InitDefaultsJointTrajectoryConstraint();
void InitDefaultsWrenchImpl();
void InitDefaultsWrench();
void InitDefaultsTwistImpl();
void InitDefaultsTwist();
void InitDefaultsAdmittanceImpl();
void InitDefaultsAdmittance();
void InitDefaultsConstrainedPoseImpl();
void InitDefaultsConstrainedPose();
void InitDefaultsConstrainedPositionImpl();
void InitDefaultsConstrainedPosition();
void InitDefaultsConstrainedOrientationImpl();
void InitDefaultsConstrainedOrientation();
void InitDefaultsWrenchCommandImpl();
void InitDefaultsWrenchCommand();
void InitDefaultsTwistCommandImpl();
void InitDefaultsTwistCommand();
void InitDefaultsConstrainedJointAnglesImpl();
void InitDefaultsConstrainedJointAngles();
void InitDefaultsConstrainedJointAngleImpl();
void InitDefaultsConstrainedJointAngle();
void InitDefaultsJointAnglesImpl();
void InitDefaultsJointAngles();
void InitDefaultsJointAngleImpl();
void InitDefaultsJointAngle();
void InitDefaultsJointSpeedsImpl();
void InitDefaultsJointSpeeds();
void InitDefaultsJointSpeedImpl();
void InitDefaultsJointSpeed();
void InitDefaultsJointTorquesImpl();
void InitDefaultsJointTorques();
void InitDefaultsJointTorqueImpl();
void InitDefaultsJointTorque();
void InitDefaultsGripperCommandImpl();
void InitDefaultsGripperCommand();
void InitDefaultsGripperRequestImpl();
void InitDefaultsGripperRequest();
void InitDefaultsGripperImpl();
void InitDefaultsGripper();
void InitDefaultsFingerImpl();
void InitDefaultsFinger();
void InitDefaultsGpioCommandImpl();
void InitDefaultsGpioCommand();
void InitDefaultsSystemTimeImpl();
void InitDefaultsSystemTime();
void InitDefaultsControllerConfigurationModeImpl();
void InitDefaultsControllerConfigurationMode();
void InitDefaultsControllerConfigurationImpl();
void InitDefaultsControllerConfiguration();
void InitDefaultsControllerConfigurationListImpl();
void InitDefaultsControllerConfigurationList();
void InitDefaultsActuatorInformationImpl();
void InitDefaultsActuatorInformation();
void InitDefaultsArmStateInformationImpl();
void InitDefaultsArmStateInformation();
void InitDefaultsArmStateNotificationImpl();
void InitDefaultsArmStateNotification();
void InitDefaultsCapSenseConfigImpl();
void InitDefaultsCapSenseConfig();
void InitDefaultsBridgeListImpl();
void InitDefaultsBridgeList();
void InitDefaultsBridgeResultImpl();
void InitDefaultsBridgeResult();
void InitDefaultsBridgeIdentifierImpl();
void InitDefaultsBridgeIdentifier();
void InitDefaultsBridgeConfigImpl();
void InitDefaultsBridgeConfig();
void InitDefaultsBridgePortConfigImpl();
void InitDefaultsBridgePortConfig();
void InitDefaultsPreComputedJointTrajectoryImpl();
void InitDefaultsPreComputedJointTrajectory();
void InitDefaultsPreComputedJointTrajectoryElementImpl();
void InitDefaultsPreComputedJointTrajectoryElement();
void InitDefaultsTrajectoryErrorElementImpl();
void InitDefaultsTrajectoryErrorElement();
void InitDefaultsTrajectoryErrorReportImpl();
void InitDefaultsTrajectoryErrorReport();
void InitDefaultsWaypointValidationReportImpl();
void InitDefaultsWaypointValidationReport();
void InitDefaultsWaypointImpl();
void InitDefaultsWaypoint();
void InitDefaultsAngularWaypointImpl();
void InitDefaultsAngularWaypoint();
void InitDefaultsCartesianWaypointImpl();
void InitDefaultsCartesianWaypoint();
void InitDefaultsWaypointListImpl();
void InitDefaultsWaypointList();
void InitDefaultsKinematicTrajectoryConstraintsImpl();
void InitDefaultsKinematicTrajectoryConstraints();
void InitDefaultsFirmwareBundleVersionsImpl();
void InitDefaultsFirmwareBundleVersions();
void InitDefaultsFirmwareComponentVersionImpl();
void InitDefaultsFirmwareComponentVersion();
void InitDefaultsIKDataImpl();
void InitDefaultsIKData();
inline void InitDefaults() {
  InitDefaultsGpioConfigurationList();
  InitDefaultsGpioConfiguration();
  InitDefaultsGpioPinConfiguration();
  InitDefaultsFullUserProfile();
  InitDefaultsUserProfile();
  InitDefaultsUserProfileList();
  InitDefaultsUserList();
  InitDefaultsPasswordChange();
  InitDefaultsSequenceHandle();
  InitDefaultsAdvancedSequenceHandle();
  InitDefaultsSequenceTaskHandle();
  InitDefaultsSequenceTask();
  InitDefaultsSequenceTasks();
  InitDefaultsSequenceTasksConfiguration();
  InitDefaultsSequenceTaskConfiguration();
  InitDefaultsSequenceTasksRange();
  InitDefaultsSequenceTasksPair();
  InitDefaultsSequence();
  InitDefaultsSequenceList();
  InitDefaultsAppendActionInformation();
  InitDefaultsActionHandle();
  InitDefaultsRequestedActionType();
  InitDefaultsAction();
  InitDefaultsSnapshot();
  InitDefaultsSwitchControlMapping();
  InitDefaultsChangeTwist();
  InitDefaultsChangeJointSpeeds();
  InitDefaultsChangeWrench();
  InitDefaultsEmergencyStop();
  InitDefaultsFaults();
  InitDefaultsDelay();
  InitDefaultsStop();
  InitDefaultsActionList();
  InitDefaultsTimeout();
  InitDefaultsSsid();
  InitDefaultsCommunicationInterfaceConfiguration();
  InitDefaultsNetworkHandle();
  InitDefaultsIPv4Configuration();
  InitDefaultsIPv4Information();
  InitDefaultsFullIPv4Configuration();
  InitDefaultsWifiInformation();
  InitDefaultsWifiInformationList();
  InitDefaultsWifiConfiguration();
  InitDefaultsWifiConfigurationList();
  InitDefaultsProtectionZoneHandle();
  InitDefaultsRotationMatrixRow();
  InitDefaultsRotationMatrix();
  InitDefaultsPoint();
  InitDefaultsZoneShape();
  InitDefaultsProtectionZone();
  InitDefaultsProtectionZoneList();
  InitDefaultsCartesianLimitation();
  InitDefaultsTwistLimitation();
  InitDefaultsWrenchLimitation();
  InitDefaultsCartesianLimitationList();
  InitDefaultsJointLimitation();
  InitDefaultsJointsLimitationsList();
  InitDefaultsQuery();
  InitDefaultsConfigurationChangeNotification();
  InitDefaultsMappingInfoNotification();
  InitDefaultsControlModeInformation();
  InitDefaultsControlModeNotification();
  InitDefaultsServoingModeInformation();
  InitDefaultsOperatingModeInformation();
  InitDefaultsOperatingModeNotification();
  InitDefaultsServoingModeNotification();
  InitDefaultsSequenceInfoNotification();
  InitDefaultsSequenceInformation();
  InitDefaultsProtectionZoneNotification();
  InitDefaultsProtectionZoneInformation();
  InitDefaultsUserNotification();
  InitDefaultsControllerHandle();
  InitDefaultsControllerElementHandle();
  InitDefaultsControllerNotification();
  InitDefaultsControllerList();
  InitDefaultsControllerState();
  InitDefaultsControllerElementState();
  InitDefaultsActionNotification();
  InitDefaultsTrajectoryInfo();
  InitDefaultsActionExecutionState();
  InitDefaultsRobotEventNotification();
  InitDefaultsFactoryNotification();
  InitDefaultsNetworkNotification();
  InitDefaultsConfigurationChangeNotificationList();
  InitDefaultsMappingInfoNotificationList();
  InitDefaultsControlModeNotificationList();
  InitDefaultsOperatingModeNotificationList();
  InitDefaultsServoingModeNotificationList();
  InitDefaultsSequenceInfoNotificationList();
  InitDefaultsProtectionZoneNotificationList();
  InitDefaultsUserNotificationList();
  InitDefaultsSafetyNotificationList();
  InitDefaultsControllerNotificationList();
  InitDefaultsActionNotificationList();
  InitDefaultsRobotEventNotificationList();
  InitDefaultsNetworkNotificationList();
  InitDefaultsMappingHandle();
  InitDefaultsSafetyEvent();
  InitDefaultsControllerEvent();
  InitDefaultsGpioEvent();
  InitDefaultsMapEvent();
  InitDefaultsMapElement();
  InitDefaultsActivateMapHandle();
  InitDefaultsMap();
  InitDefaultsMapHandle();
  InitDefaultsMapList();
  InitDefaultsMapGroupHandle();
  InitDefaultsMapGroup();
  InitDefaultsMapGroupList();
  InitDefaultsMapping();
  InitDefaultsMappingList();
  InitDefaultsTransformationMatrix();
  InitDefaultsTransformationRow();
  InitDefaultsPose();
  InitDefaultsPosition();
  InitDefaultsOrientation();
  InitDefaultsCartesianSpeed();
  InitDefaultsCartesianTrajectoryConstraint();
  InitDefaultsJointTrajectoryConstraint();
  InitDefaultsWrench();
  InitDefaultsTwist();
  InitDefaultsAdmittance();
  InitDefaultsConstrainedPose();
  InitDefaultsConstrainedPosition();
  InitDefaultsConstrainedOrientation();
  InitDefaultsWrenchCommand();
  InitDefaultsTwistCommand();
  InitDefaultsConstrainedJointAngles();
  InitDefaultsConstrainedJointAngle();
  InitDefaultsJointAngles();
  InitDefaultsJointAngle();
  InitDefaultsJointSpeeds();
  InitDefaultsJointSpeed();
  InitDefaultsJointTorques();
  InitDefaultsJointTorque();
  InitDefaultsGripperCommand();
  InitDefaultsGripperRequest();
  InitDefaultsGripper();
  InitDefaultsFinger();
  InitDefaultsGpioCommand();
  InitDefaultsSystemTime();
  InitDefaultsControllerConfigurationMode();
  InitDefaultsControllerConfiguration();
  InitDefaultsControllerConfigurationList();
  InitDefaultsActuatorInformation();
  InitDefaultsArmStateInformation();
  InitDefaultsArmStateNotification();
  InitDefaultsCapSenseConfig();
  InitDefaultsBridgeList();
  InitDefaultsBridgeResult();
  InitDefaultsBridgeIdentifier();
  InitDefaultsBridgeConfig();
  InitDefaultsBridgePortConfig();
  InitDefaultsPreComputedJointTrajectory();
  InitDefaultsPreComputedJointTrajectoryElement();
  InitDefaultsTrajectoryErrorElement();
  InitDefaultsTrajectoryErrorReport();
  InitDefaultsWaypointValidationReport();
  InitDefaultsWaypoint();
  InitDefaultsAngularWaypoint();
  InitDefaultsCartesianWaypoint();
  InitDefaultsWaypointList();
  InitDefaultsKinematicTrajectoryConstraints();
  InitDefaultsFirmwareBundleVersions();
  InitDefaultsFirmwareComponentVersion();
  InitDefaultsIKData();
}
}  // namespace protobuf_Base_2eproto
namespace Kinova {
namespace Api {
namespace Base {
class Action;
class ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class ActionExecutionState;
class ActionExecutionStateDefaultTypeInternal;
extern ActionExecutionStateDefaultTypeInternal _ActionExecutionState_default_instance_;
class ActionHandle;
class ActionHandleDefaultTypeInternal;
extern ActionHandleDefaultTypeInternal _ActionHandle_default_instance_;
class ActionList;
class ActionListDefaultTypeInternal;
extern ActionListDefaultTypeInternal _ActionList_default_instance_;
class ActionNotification;
class ActionNotificationDefaultTypeInternal;
extern ActionNotificationDefaultTypeInternal _ActionNotification_default_instance_;
class ActionNotificationList;
class ActionNotificationListDefaultTypeInternal;
extern ActionNotificationListDefaultTypeInternal _ActionNotificationList_default_instance_;
class ActivateMapHandle;
class ActivateMapHandleDefaultTypeInternal;
extern ActivateMapHandleDefaultTypeInternal _ActivateMapHandle_default_instance_;
class ActuatorInformation;
class ActuatorInformationDefaultTypeInternal;
extern ActuatorInformationDefaultTypeInternal _ActuatorInformation_default_instance_;
class Admittance;
class AdmittanceDefaultTypeInternal;
extern AdmittanceDefaultTypeInternal _Admittance_default_instance_;
class AdvancedSequenceHandle;
class AdvancedSequenceHandleDefaultTypeInternal;
extern AdvancedSequenceHandleDefaultTypeInternal _AdvancedSequenceHandle_default_instance_;
class AngularWaypoint;
class AngularWaypointDefaultTypeInternal;
extern AngularWaypointDefaultTypeInternal _AngularWaypoint_default_instance_;
class AppendActionInformation;
class AppendActionInformationDefaultTypeInternal;
extern AppendActionInformationDefaultTypeInternal _AppendActionInformation_default_instance_;
class ArmStateInformation;
class ArmStateInformationDefaultTypeInternal;
extern ArmStateInformationDefaultTypeInternal _ArmStateInformation_default_instance_;
class ArmStateNotification;
class ArmStateNotificationDefaultTypeInternal;
extern ArmStateNotificationDefaultTypeInternal _ArmStateNotification_default_instance_;
class BridgeConfig;
class BridgeConfigDefaultTypeInternal;
extern BridgeConfigDefaultTypeInternal _BridgeConfig_default_instance_;
class BridgeIdentifier;
class BridgeIdentifierDefaultTypeInternal;
extern BridgeIdentifierDefaultTypeInternal _BridgeIdentifier_default_instance_;
class BridgeList;
class BridgeListDefaultTypeInternal;
extern BridgeListDefaultTypeInternal _BridgeList_default_instance_;
class BridgePortConfig;
class BridgePortConfigDefaultTypeInternal;
extern BridgePortConfigDefaultTypeInternal _BridgePortConfig_default_instance_;
class BridgeResult;
class BridgeResultDefaultTypeInternal;
extern BridgeResultDefaultTypeInternal _BridgeResult_default_instance_;
class CapSenseConfig;
class CapSenseConfigDefaultTypeInternal;
extern CapSenseConfigDefaultTypeInternal _CapSenseConfig_default_instance_;
class CartesianLimitation;
class CartesianLimitationDefaultTypeInternal;
extern CartesianLimitationDefaultTypeInternal _CartesianLimitation_default_instance_;
class CartesianLimitationList;
class CartesianLimitationListDefaultTypeInternal;
extern CartesianLimitationListDefaultTypeInternal _CartesianLimitationList_default_instance_;
class CartesianSpeed;
class CartesianSpeedDefaultTypeInternal;
extern CartesianSpeedDefaultTypeInternal _CartesianSpeed_default_instance_;
class CartesianTrajectoryConstraint;
class CartesianTrajectoryConstraintDefaultTypeInternal;
extern CartesianTrajectoryConstraintDefaultTypeInternal _CartesianTrajectoryConstraint_default_instance_;
class CartesianWaypoint;
class CartesianWaypointDefaultTypeInternal;
extern CartesianWaypointDefaultTypeInternal _CartesianWaypoint_default_instance_;
class ChangeJointSpeeds;
class ChangeJointSpeedsDefaultTypeInternal;
extern ChangeJointSpeedsDefaultTypeInternal _ChangeJointSpeeds_default_instance_;
class ChangeTwist;
class ChangeTwistDefaultTypeInternal;
extern ChangeTwistDefaultTypeInternal _ChangeTwist_default_instance_;
class ChangeWrench;
class ChangeWrenchDefaultTypeInternal;
extern ChangeWrenchDefaultTypeInternal _ChangeWrench_default_instance_;
class CommunicationInterfaceConfiguration;
class CommunicationInterfaceConfigurationDefaultTypeInternal;
extern CommunicationInterfaceConfigurationDefaultTypeInternal _CommunicationInterfaceConfiguration_default_instance_;
class ConfigurationChangeNotification;
class ConfigurationChangeNotificationDefaultTypeInternal;
extern ConfigurationChangeNotificationDefaultTypeInternal _ConfigurationChangeNotification_default_instance_;
class ConfigurationChangeNotificationList;
class ConfigurationChangeNotificationListDefaultTypeInternal;
extern ConfigurationChangeNotificationListDefaultTypeInternal _ConfigurationChangeNotificationList_default_instance_;
class ConstrainedJointAngle;
class ConstrainedJointAngleDefaultTypeInternal;
extern ConstrainedJointAngleDefaultTypeInternal _ConstrainedJointAngle_default_instance_;
class ConstrainedJointAngles;
class ConstrainedJointAnglesDefaultTypeInternal;
extern ConstrainedJointAnglesDefaultTypeInternal _ConstrainedJointAngles_default_instance_;
class ConstrainedOrientation;
class ConstrainedOrientationDefaultTypeInternal;
extern ConstrainedOrientationDefaultTypeInternal _ConstrainedOrientation_default_instance_;
class ConstrainedPose;
class ConstrainedPoseDefaultTypeInternal;
extern ConstrainedPoseDefaultTypeInternal _ConstrainedPose_default_instance_;
class ConstrainedPosition;
class ConstrainedPositionDefaultTypeInternal;
extern ConstrainedPositionDefaultTypeInternal _ConstrainedPosition_default_instance_;
class ControlModeInformation;
class ControlModeInformationDefaultTypeInternal;
extern ControlModeInformationDefaultTypeInternal _ControlModeInformation_default_instance_;
class ControlModeNotification;
class ControlModeNotificationDefaultTypeInternal;
extern ControlModeNotificationDefaultTypeInternal _ControlModeNotification_default_instance_;
class ControlModeNotificationList;
class ControlModeNotificationListDefaultTypeInternal;
extern ControlModeNotificationListDefaultTypeInternal _ControlModeNotificationList_default_instance_;
class ControllerConfiguration;
class ControllerConfigurationDefaultTypeInternal;
extern ControllerConfigurationDefaultTypeInternal _ControllerConfiguration_default_instance_;
class ControllerConfigurationList;
class ControllerConfigurationListDefaultTypeInternal;
extern ControllerConfigurationListDefaultTypeInternal _ControllerConfigurationList_default_instance_;
class ControllerConfigurationMode;
class ControllerConfigurationModeDefaultTypeInternal;
extern ControllerConfigurationModeDefaultTypeInternal _ControllerConfigurationMode_default_instance_;
class ControllerElementHandle;
class ControllerElementHandleDefaultTypeInternal;
extern ControllerElementHandleDefaultTypeInternal _ControllerElementHandle_default_instance_;
class ControllerElementState;
class ControllerElementStateDefaultTypeInternal;
extern ControllerElementStateDefaultTypeInternal _ControllerElementState_default_instance_;
class ControllerEvent;
class ControllerEventDefaultTypeInternal;
extern ControllerEventDefaultTypeInternal _ControllerEvent_default_instance_;
class ControllerHandle;
class ControllerHandleDefaultTypeInternal;
extern ControllerHandleDefaultTypeInternal _ControllerHandle_default_instance_;
class ControllerList;
class ControllerListDefaultTypeInternal;
extern ControllerListDefaultTypeInternal _ControllerList_default_instance_;
class ControllerNotification;
class ControllerNotificationDefaultTypeInternal;
extern ControllerNotificationDefaultTypeInternal _ControllerNotification_default_instance_;
class ControllerNotificationList;
class ControllerNotificationListDefaultTypeInternal;
extern ControllerNotificationListDefaultTypeInternal _ControllerNotificationList_default_instance_;
class ControllerState;
class ControllerStateDefaultTypeInternal;
extern ControllerStateDefaultTypeInternal _ControllerState_default_instance_;
class Delay;
class DelayDefaultTypeInternal;
extern DelayDefaultTypeInternal _Delay_default_instance_;
class EmergencyStop;
class EmergencyStopDefaultTypeInternal;
extern EmergencyStopDefaultTypeInternal _EmergencyStop_default_instance_;
class FactoryNotification;
class FactoryNotificationDefaultTypeInternal;
extern FactoryNotificationDefaultTypeInternal _FactoryNotification_default_instance_;
class Faults;
class FaultsDefaultTypeInternal;
extern FaultsDefaultTypeInternal _Faults_default_instance_;
class Finger;
class FingerDefaultTypeInternal;
extern FingerDefaultTypeInternal _Finger_default_instance_;
class FirmwareBundleVersions;
class FirmwareBundleVersionsDefaultTypeInternal;
extern FirmwareBundleVersionsDefaultTypeInternal _FirmwareBundleVersions_default_instance_;
class FirmwareComponentVersion;
class FirmwareComponentVersionDefaultTypeInternal;
extern FirmwareComponentVersionDefaultTypeInternal _FirmwareComponentVersion_default_instance_;
class FullIPv4Configuration;
class FullIPv4ConfigurationDefaultTypeInternal;
extern FullIPv4ConfigurationDefaultTypeInternal _FullIPv4Configuration_default_instance_;
class FullUserProfile;
class FullUserProfileDefaultTypeInternal;
extern FullUserProfileDefaultTypeInternal _FullUserProfile_default_instance_;
class GpioCommand;
class GpioCommandDefaultTypeInternal;
extern GpioCommandDefaultTypeInternal _GpioCommand_default_instance_;
class GpioConfiguration;
class GpioConfigurationDefaultTypeInternal;
extern GpioConfigurationDefaultTypeInternal _GpioConfiguration_default_instance_;
class GpioConfigurationList;
class GpioConfigurationListDefaultTypeInternal;
extern GpioConfigurationListDefaultTypeInternal _GpioConfigurationList_default_instance_;
class GpioEvent;
class GpioEventDefaultTypeInternal;
extern GpioEventDefaultTypeInternal _GpioEvent_default_instance_;
class GpioPinConfiguration;
class GpioPinConfigurationDefaultTypeInternal;
extern GpioPinConfigurationDefaultTypeInternal _GpioPinConfiguration_default_instance_;
class Gripper;
class GripperDefaultTypeInternal;
extern GripperDefaultTypeInternal _Gripper_default_instance_;
class GripperCommand;
class GripperCommandDefaultTypeInternal;
extern GripperCommandDefaultTypeInternal _GripperCommand_default_instance_;
class GripperRequest;
class GripperRequestDefaultTypeInternal;
extern GripperRequestDefaultTypeInternal _GripperRequest_default_instance_;
class IKData;
class IKDataDefaultTypeInternal;
extern IKDataDefaultTypeInternal _IKData_default_instance_;
class IPv4Configuration;
class IPv4ConfigurationDefaultTypeInternal;
extern IPv4ConfigurationDefaultTypeInternal _IPv4Configuration_default_instance_;
class IPv4Information;
class IPv4InformationDefaultTypeInternal;
extern IPv4InformationDefaultTypeInternal _IPv4Information_default_instance_;
class JointAngle;
class JointAngleDefaultTypeInternal;
extern JointAngleDefaultTypeInternal _JointAngle_default_instance_;
class JointAngles;
class JointAnglesDefaultTypeInternal;
extern JointAnglesDefaultTypeInternal _JointAngles_default_instance_;
class JointLimitation;
class JointLimitationDefaultTypeInternal;
extern JointLimitationDefaultTypeInternal _JointLimitation_default_instance_;
class JointSpeed;
class JointSpeedDefaultTypeInternal;
extern JointSpeedDefaultTypeInternal _JointSpeed_default_instance_;
class JointSpeeds;
class JointSpeedsDefaultTypeInternal;
extern JointSpeedsDefaultTypeInternal _JointSpeeds_default_instance_;
class JointTorque;
class JointTorqueDefaultTypeInternal;
extern JointTorqueDefaultTypeInternal _JointTorque_default_instance_;
class JointTorques;
class JointTorquesDefaultTypeInternal;
extern JointTorquesDefaultTypeInternal _JointTorques_default_instance_;
class JointTrajectoryConstraint;
class JointTrajectoryConstraintDefaultTypeInternal;
extern JointTrajectoryConstraintDefaultTypeInternal _JointTrajectoryConstraint_default_instance_;
class JointsLimitationsList;
class JointsLimitationsListDefaultTypeInternal;
extern JointsLimitationsListDefaultTypeInternal _JointsLimitationsList_default_instance_;
class KinematicTrajectoryConstraints;
class KinematicTrajectoryConstraintsDefaultTypeInternal;
extern KinematicTrajectoryConstraintsDefaultTypeInternal _KinematicTrajectoryConstraints_default_instance_;
class Map;
class MapDefaultTypeInternal;
extern MapDefaultTypeInternal _Map_default_instance_;
class MapElement;
class MapElementDefaultTypeInternal;
extern MapElementDefaultTypeInternal _MapElement_default_instance_;
class MapEvent;
class MapEventDefaultTypeInternal;
extern MapEventDefaultTypeInternal _MapEvent_default_instance_;
class MapGroup;
class MapGroupDefaultTypeInternal;
extern MapGroupDefaultTypeInternal _MapGroup_default_instance_;
class MapGroupHandle;
class MapGroupHandleDefaultTypeInternal;
extern MapGroupHandleDefaultTypeInternal _MapGroupHandle_default_instance_;
class MapGroupList;
class MapGroupListDefaultTypeInternal;
extern MapGroupListDefaultTypeInternal _MapGroupList_default_instance_;
class MapHandle;
class MapHandleDefaultTypeInternal;
extern MapHandleDefaultTypeInternal _MapHandle_default_instance_;
class MapList;
class MapListDefaultTypeInternal;
extern MapListDefaultTypeInternal _MapList_default_instance_;
class Mapping;
class MappingDefaultTypeInternal;
extern MappingDefaultTypeInternal _Mapping_default_instance_;
class MappingHandle;
class MappingHandleDefaultTypeInternal;
extern MappingHandleDefaultTypeInternal _MappingHandle_default_instance_;
class MappingInfoNotification;
class MappingInfoNotificationDefaultTypeInternal;
extern MappingInfoNotificationDefaultTypeInternal _MappingInfoNotification_default_instance_;
class MappingInfoNotificationList;
class MappingInfoNotificationListDefaultTypeInternal;
extern MappingInfoNotificationListDefaultTypeInternal _MappingInfoNotificationList_default_instance_;
class MappingList;
class MappingListDefaultTypeInternal;
extern MappingListDefaultTypeInternal _MappingList_default_instance_;
class NetworkHandle;
class NetworkHandleDefaultTypeInternal;
extern NetworkHandleDefaultTypeInternal _NetworkHandle_default_instance_;
class NetworkNotification;
class NetworkNotificationDefaultTypeInternal;
extern NetworkNotificationDefaultTypeInternal _NetworkNotification_default_instance_;
class NetworkNotificationList;
class NetworkNotificationListDefaultTypeInternal;
extern NetworkNotificationListDefaultTypeInternal _NetworkNotificationList_default_instance_;
class OperatingModeInformation;
class OperatingModeInformationDefaultTypeInternal;
extern OperatingModeInformationDefaultTypeInternal _OperatingModeInformation_default_instance_;
class OperatingModeNotification;
class OperatingModeNotificationDefaultTypeInternal;
extern OperatingModeNotificationDefaultTypeInternal _OperatingModeNotification_default_instance_;
class OperatingModeNotificationList;
class OperatingModeNotificationListDefaultTypeInternal;
extern OperatingModeNotificationListDefaultTypeInternal _OperatingModeNotificationList_default_instance_;
class Orientation;
class OrientationDefaultTypeInternal;
extern OrientationDefaultTypeInternal _Orientation_default_instance_;
class PasswordChange;
class PasswordChangeDefaultTypeInternal;
extern PasswordChangeDefaultTypeInternal _PasswordChange_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class PreComputedJointTrajectory;
class PreComputedJointTrajectoryDefaultTypeInternal;
extern PreComputedJointTrajectoryDefaultTypeInternal _PreComputedJointTrajectory_default_instance_;
class PreComputedJointTrajectoryElement;
class PreComputedJointTrajectoryElementDefaultTypeInternal;
extern PreComputedJointTrajectoryElementDefaultTypeInternal _PreComputedJointTrajectoryElement_default_instance_;
class ProtectionZone;
class ProtectionZoneDefaultTypeInternal;
extern ProtectionZoneDefaultTypeInternal _ProtectionZone_default_instance_;
class ProtectionZoneHandle;
class ProtectionZoneHandleDefaultTypeInternal;
extern ProtectionZoneHandleDefaultTypeInternal _ProtectionZoneHandle_default_instance_;
class ProtectionZoneInformation;
class ProtectionZoneInformationDefaultTypeInternal;
extern ProtectionZoneInformationDefaultTypeInternal _ProtectionZoneInformation_default_instance_;
class ProtectionZoneList;
class ProtectionZoneListDefaultTypeInternal;
extern ProtectionZoneListDefaultTypeInternal _ProtectionZoneList_default_instance_;
class ProtectionZoneNotification;
class ProtectionZoneNotificationDefaultTypeInternal;
extern ProtectionZoneNotificationDefaultTypeInternal _ProtectionZoneNotification_default_instance_;
class ProtectionZoneNotificationList;
class ProtectionZoneNotificationListDefaultTypeInternal;
extern ProtectionZoneNotificationListDefaultTypeInternal _ProtectionZoneNotificationList_default_instance_;
class Query;
class QueryDefaultTypeInternal;
extern QueryDefaultTypeInternal _Query_default_instance_;
class RequestedActionType;
class RequestedActionTypeDefaultTypeInternal;
extern RequestedActionTypeDefaultTypeInternal _RequestedActionType_default_instance_;
class RobotEventNotification;
class RobotEventNotificationDefaultTypeInternal;
extern RobotEventNotificationDefaultTypeInternal _RobotEventNotification_default_instance_;
class RobotEventNotificationList;
class RobotEventNotificationListDefaultTypeInternal;
extern RobotEventNotificationListDefaultTypeInternal _RobotEventNotificationList_default_instance_;
class RotationMatrix;
class RotationMatrixDefaultTypeInternal;
extern RotationMatrixDefaultTypeInternal _RotationMatrix_default_instance_;
class RotationMatrixRow;
class RotationMatrixRowDefaultTypeInternal;
extern RotationMatrixRowDefaultTypeInternal _RotationMatrixRow_default_instance_;
class SafetyEvent;
class SafetyEventDefaultTypeInternal;
extern SafetyEventDefaultTypeInternal _SafetyEvent_default_instance_;
class SafetyNotificationList;
class SafetyNotificationListDefaultTypeInternal;
extern SafetyNotificationListDefaultTypeInternal _SafetyNotificationList_default_instance_;
class Sequence;
class SequenceDefaultTypeInternal;
extern SequenceDefaultTypeInternal _Sequence_default_instance_;
class SequenceHandle;
class SequenceHandleDefaultTypeInternal;
extern SequenceHandleDefaultTypeInternal _SequenceHandle_default_instance_;
class SequenceInfoNotification;
class SequenceInfoNotificationDefaultTypeInternal;
extern SequenceInfoNotificationDefaultTypeInternal _SequenceInfoNotification_default_instance_;
class SequenceInfoNotificationList;
class SequenceInfoNotificationListDefaultTypeInternal;
extern SequenceInfoNotificationListDefaultTypeInternal _SequenceInfoNotificationList_default_instance_;
class SequenceInformation;
class SequenceInformationDefaultTypeInternal;
extern SequenceInformationDefaultTypeInternal _SequenceInformation_default_instance_;
class SequenceList;
class SequenceListDefaultTypeInternal;
extern SequenceListDefaultTypeInternal _SequenceList_default_instance_;
class SequenceTask;
class SequenceTaskDefaultTypeInternal;
extern SequenceTaskDefaultTypeInternal _SequenceTask_default_instance_;
class SequenceTaskConfiguration;
class SequenceTaskConfigurationDefaultTypeInternal;
extern SequenceTaskConfigurationDefaultTypeInternal _SequenceTaskConfiguration_default_instance_;
class SequenceTaskHandle;
class SequenceTaskHandleDefaultTypeInternal;
extern SequenceTaskHandleDefaultTypeInternal _SequenceTaskHandle_default_instance_;
class SequenceTasks;
class SequenceTasksDefaultTypeInternal;
extern SequenceTasksDefaultTypeInternal _SequenceTasks_default_instance_;
class SequenceTasksConfiguration;
class SequenceTasksConfigurationDefaultTypeInternal;
extern SequenceTasksConfigurationDefaultTypeInternal _SequenceTasksConfiguration_default_instance_;
class SequenceTasksPair;
class SequenceTasksPairDefaultTypeInternal;
extern SequenceTasksPairDefaultTypeInternal _SequenceTasksPair_default_instance_;
class SequenceTasksRange;
class SequenceTasksRangeDefaultTypeInternal;
extern SequenceTasksRangeDefaultTypeInternal _SequenceTasksRange_default_instance_;
class ServoingModeInformation;
class ServoingModeInformationDefaultTypeInternal;
extern ServoingModeInformationDefaultTypeInternal _ServoingModeInformation_default_instance_;
class ServoingModeNotification;
class ServoingModeNotificationDefaultTypeInternal;
extern ServoingModeNotificationDefaultTypeInternal _ServoingModeNotification_default_instance_;
class ServoingModeNotificationList;
class ServoingModeNotificationListDefaultTypeInternal;
extern ServoingModeNotificationListDefaultTypeInternal _ServoingModeNotificationList_default_instance_;
class Snapshot;
class SnapshotDefaultTypeInternal;
extern SnapshotDefaultTypeInternal _Snapshot_default_instance_;
class Ssid;
class SsidDefaultTypeInternal;
extern SsidDefaultTypeInternal _Ssid_default_instance_;
class Stop;
class StopDefaultTypeInternal;
extern StopDefaultTypeInternal _Stop_default_instance_;
class SwitchControlMapping;
class SwitchControlMappingDefaultTypeInternal;
extern SwitchControlMappingDefaultTypeInternal _SwitchControlMapping_default_instance_;
class SystemTime;
class SystemTimeDefaultTypeInternal;
extern SystemTimeDefaultTypeInternal _SystemTime_default_instance_;
class Timeout;
class TimeoutDefaultTypeInternal;
extern TimeoutDefaultTypeInternal _Timeout_default_instance_;
class TrajectoryErrorElement;
class TrajectoryErrorElementDefaultTypeInternal;
extern TrajectoryErrorElementDefaultTypeInternal _TrajectoryErrorElement_default_instance_;
class TrajectoryErrorReport;
class TrajectoryErrorReportDefaultTypeInternal;
extern TrajectoryErrorReportDefaultTypeInternal _TrajectoryErrorReport_default_instance_;
class TrajectoryInfo;
class TrajectoryInfoDefaultTypeInternal;
extern TrajectoryInfoDefaultTypeInternal _TrajectoryInfo_default_instance_;
class TransformationMatrix;
class TransformationMatrixDefaultTypeInternal;
extern TransformationMatrixDefaultTypeInternal _TransformationMatrix_default_instance_;
class TransformationRow;
class TransformationRowDefaultTypeInternal;
extern TransformationRowDefaultTypeInternal _TransformationRow_default_instance_;
class Twist;
class TwistDefaultTypeInternal;
extern TwistDefaultTypeInternal _Twist_default_instance_;
class TwistCommand;
class TwistCommandDefaultTypeInternal;
extern TwistCommandDefaultTypeInternal _TwistCommand_default_instance_;
class TwistLimitation;
class TwistLimitationDefaultTypeInternal;
extern TwistLimitationDefaultTypeInternal _TwistLimitation_default_instance_;
class UserList;
class UserListDefaultTypeInternal;
extern UserListDefaultTypeInternal _UserList_default_instance_;
class UserNotification;
class UserNotificationDefaultTypeInternal;
extern UserNotificationDefaultTypeInternal _UserNotification_default_instance_;
class UserNotificationList;
class UserNotificationListDefaultTypeInternal;
extern UserNotificationListDefaultTypeInternal _UserNotificationList_default_instance_;
class UserProfile;
class UserProfileDefaultTypeInternal;
extern UserProfileDefaultTypeInternal _UserProfile_default_instance_;
class UserProfileList;
class UserProfileListDefaultTypeInternal;
extern UserProfileListDefaultTypeInternal _UserProfileList_default_instance_;
class Waypoint;
class WaypointDefaultTypeInternal;
extern WaypointDefaultTypeInternal _Waypoint_default_instance_;
class WaypointList;
class WaypointListDefaultTypeInternal;
extern WaypointListDefaultTypeInternal _WaypointList_default_instance_;
class WaypointValidationReport;
class WaypointValidationReportDefaultTypeInternal;
extern WaypointValidationReportDefaultTypeInternal _WaypointValidationReport_default_instance_;
class WifiConfiguration;
class WifiConfigurationDefaultTypeInternal;
extern WifiConfigurationDefaultTypeInternal _WifiConfiguration_default_instance_;
class WifiConfigurationList;
class WifiConfigurationListDefaultTypeInternal;
extern WifiConfigurationListDefaultTypeInternal _WifiConfigurationList_default_instance_;
class WifiInformation;
class WifiInformationDefaultTypeInternal;
extern WifiInformationDefaultTypeInternal _WifiInformation_default_instance_;
class WifiInformationList;
class WifiInformationListDefaultTypeInternal;
extern WifiInformationListDefaultTypeInternal _WifiInformationList_default_instance_;
class Wrench;
class WrenchDefaultTypeInternal;
extern WrenchDefaultTypeInternal _Wrench_default_instance_;
class WrenchCommand;
class WrenchCommandDefaultTypeInternal;
extern WrenchCommandDefaultTypeInternal _WrenchCommand_default_instance_;
class WrenchLimitation;
class WrenchLimitationDefaultTypeInternal;
extern WrenchLimitationDefaultTypeInternal _WrenchLimitation_default_instance_;
class ZoneShape;
class ZoneShapeDefaultTypeInternal;
extern ZoneShapeDefaultTypeInternal _ZoneShape_default_instance_;
}  // namespace Base
}  // namespace Api
}  // namespace Kinova
namespace Kinova {
namespace Api {
namespace Base {

enum GpioPinPropertyFlags {
  GPIOPROPERTY_UNKNOWN = 0,
  GPIOPROPERTY_INPUT = 1,
  GPIOPROPERTY_OUTPUT = 2,
  GPIOPROPERTY_ANALOG = 4,
  GpioPinPropertyFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GpioPinPropertyFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GpioPinPropertyFlags_IsValid(int value);
const GpioPinPropertyFlags GpioPinPropertyFlags_MIN = GPIOPROPERTY_UNKNOWN;
const GpioPinPropertyFlags GpioPinPropertyFlags_MAX = GPIOPROPERTY_ANALOG;
const int GpioPinPropertyFlags_ARRAYSIZE = GpioPinPropertyFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* GpioPinPropertyFlags_descriptor();
inline const ::std::string& GpioPinPropertyFlags_Name(GpioPinPropertyFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    GpioPinPropertyFlags_descriptor(), value);
}
inline bool GpioPinPropertyFlags_Parse(
    const ::std::string& name, GpioPinPropertyFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GpioPinPropertyFlags>(
    GpioPinPropertyFlags_descriptor(), name, value);
}
enum ServiceVersion {
  RESERVED_0 = 0,
  CURRENT_VERSION = 1,
  ServiceVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ServiceVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ServiceVersion_IsValid(int value);
const ServiceVersion ServiceVersion_MIN = RESERVED_0;
const ServiceVersion ServiceVersion_MAX = CURRENT_VERSION;
const int ServiceVersion_ARRAYSIZE = ServiceVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceVersion_descriptor();
inline const ::std::string& ServiceVersion_Name(ServiceVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceVersion_descriptor(), value);
}
inline bool ServiceVersion_Parse(
    const ::std::string& name, ServiceVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceVersion>(
    ServiceVersion_descriptor(), name, value);
}
enum ActionType {
  UNSPECIFIED_ACTION = 0,
  SEND_TWIST_COMMAND = 1,
  SEND_WRENCH_COMMAND = 2,
  SEND_JOINT_SPEEDS = 4,
  REACH_POSE = 6,
  REACH_JOINT_ANGLES = 7,
  TOGGLE_ADMITTANCE_MODE = 13,
  SNAPSHOT = 14,
  SWITCH_CONTROL_MAPPING = 16,
  NAVIGATE_JOINTS = 17,
  NAVIGATE_MAPPINGS = 18,
  CHANGE_TWIST = 22,
  CHANGE_JOINT_SPEEDS = 23,
  CHANGE_WRENCH = 25,
  APPLY_EMERGENCY_STOP = 28,
  CLEAR_FAULTS = 29,
  TIME_DELAY = 31,
  EXECUTE_ACTION = 32,
  SEND_GRIPPER_COMMAND = 33,
  SEND_GPIO_COMMAND = 34,
  STOP_ACTION = 35,
  PLAY_PRE_COMPUTED_TRAJECTORY = 39,
  EXECUTE_SEQUENCE = 40,
  EXECUTE_WAYPOINT_LIST = 41,
  ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ActionType_IsValid(int value);
const ActionType ActionType_MIN = UNSPECIFIED_ACTION;
const ActionType ActionType_MAX = EXECUTE_WAYPOINT_LIST;
const int ActionType_ARRAYSIZE = ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActionType_descriptor();
inline const ::std::string& ActionType_Name(ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActionType_descriptor(), value);
}
inline bool ActionType_Parse(
    const ::std::string& name, ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionType>(
    ActionType_descriptor(), name, value);
}
enum SnapshotType {
  UNSPECIFIED_SNAPSHOT = 0,
  CARTESIAN_POSITION_SNAPSHOT = 1,
  JOINT_POSITION_SNAPSHOT = 2,
  GRIPPER_SNAPSHOT = 3,
  COMBINED_SNAPSHOT = 4,
  SnapshotType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SnapshotType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SnapshotType_IsValid(int value);
const SnapshotType SnapshotType_MIN = UNSPECIFIED_SNAPSHOT;
const SnapshotType SnapshotType_MAX = COMBINED_SNAPSHOT;
const int SnapshotType_ARRAYSIZE = SnapshotType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SnapshotType_descriptor();
inline const ::std::string& SnapshotType_Name(SnapshotType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SnapshotType_descriptor(), value);
}
inline bool SnapshotType_Parse(
    const ::std::string& name, SnapshotType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SnapshotType>(
    SnapshotType_descriptor(), name, value);
}
enum NetworkType {
  UNSPECIFIED_NETWORK_TYPE = 0,
  WIFI = 1,
  WIRED_ETHERNET = 2,
  WIRED_MICROUSB = 3,
  WIRED_USB PROTOBUF_DEPRECATED = 4,
  NetworkType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NetworkType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NetworkType_IsValid(int value);
const NetworkType NetworkType_MIN = UNSPECIFIED_NETWORK_TYPE;
const NetworkType NetworkType_MAX = WIRED_USB;
const int NetworkType_ARRAYSIZE = NetworkType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NetworkType_descriptor();
inline const ::std::string& NetworkType_Name(NetworkType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NetworkType_descriptor(), value);
}
inline bool NetworkType_Parse(
    const ::std::string& name, NetworkType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetworkType>(
    NetworkType_descriptor(), name, value);
}
enum WifiSecurityType {
  UNSPECIFIED_AUTHENTICATION = 0,
  WEP = 1,
  WPA2_PERSONAL = 2,
  WPA_PERSONAL = 4,
  NO_AUTHENTICATION = 8,
  WifiSecurityType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  WifiSecurityType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool WifiSecurityType_IsValid(int value);
const WifiSecurityType WifiSecurityType_MIN = UNSPECIFIED_AUTHENTICATION;
const WifiSecurityType WifiSecurityType_MAX = NO_AUTHENTICATION;
const int WifiSecurityType_ARRAYSIZE = WifiSecurityType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WifiSecurityType_descriptor();
inline const ::std::string& WifiSecurityType_Name(WifiSecurityType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WifiSecurityType_descriptor(), value);
}
inline bool WifiSecurityType_Parse(
    const ::std::string& name, WifiSecurityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WifiSecurityType>(
    WifiSecurityType_descriptor(), name, value);
}
enum WifiEncryptionType {
  UNSPECIFIED_ENCRYPTION = 0,
  AES_ENCRYPTION = 1,
  TKIP_ENCRYPTION = 2,
  WEP_ENCRYPTION = 4,
  WifiEncryptionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  WifiEncryptionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool WifiEncryptionType_IsValid(int value);
const WifiEncryptionType WifiEncryptionType_MIN = UNSPECIFIED_ENCRYPTION;
const WifiEncryptionType WifiEncryptionType_MAX = WEP_ENCRYPTION;
const int WifiEncryptionType_ARRAYSIZE = WifiEncryptionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WifiEncryptionType_descriptor();
inline const ::std::string& WifiEncryptionType_Name(WifiEncryptionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WifiEncryptionType_descriptor(), value);
}
inline bool WifiEncryptionType_Parse(
    const ::std::string& name, WifiEncryptionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WifiEncryptionType>(
    WifiEncryptionType_descriptor(), name, value);
}
enum SignalQuality {
  UNSPECIFIED_SIGNAL_QUALITY = 0,
  POOR = 1,
  FAIR = 2,
  GOOD = 3,
  EXCELLENT = 4,
  NONE = 5,
  SignalQuality_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SignalQuality_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SignalQuality_IsValid(int value);
const SignalQuality SignalQuality_MIN = UNSPECIFIED_SIGNAL_QUALITY;
const SignalQuality SignalQuality_MAX = NONE;
const int SignalQuality_ARRAYSIZE = SignalQuality_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignalQuality_descriptor();
inline const ::std::string& SignalQuality_Name(SignalQuality value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignalQuality_descriptor(), value);
}
inline bool SignalQuality_Parse(
    const ::std::string& name, SignalQuality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignalQuality>(
    SignalQuality_descriptor(), name, value);
}
enum ShapeType {
  UNSPECIFIED_SHAPE = 0,
  CYLINDER = 1,
  SPHERE = 2,
  RECTANGULAR_PRISM = 3,
  ShapeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ShapeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ShapeType_IsValid(int value);
const ShapeType ShapeType_MIN = UNSPECIFIED_SHAPE;
const ShapeType ShapeType_MAX = RECTANGULAR_PRISM;
const int ShapeType_ARRAYSIZE = ShapeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShapeType_descriptor();
inline const ::std::string& ShapeType_Name(ShapeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShapeType_descriptor(), value);
}
inline bool ShapeType_Parse(
    const ::std::string& name, ShapeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShapeType>(
    ShapeType_descriptor(), name, value);
}
enum LimitationType {
  UNSPECIFIED_LIMITATION = 0,
  FORCE_LIMITATION = 1,
  ACCELERATION_LIMITATION = 2,
  VELOCITY_LIMITATION = 3,
  TORQUE_LIMITATION = 4,
  LimitationType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LimitationType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LimitationType_IsValid(int value);
const LimitationType LimitationType_MIN = UNSPECIFIED_LIMITATION;
const LimitationType LimitationType_MAX = TORQUE_LIMITATION;
const int LimitationType_ARRAYSIZE = LimitationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LimitationType_descriptor();
inline const ::std::string& LimitationType_Name(LimitationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LimitationType_descriptor(), value);
}
inline bool LimitationType_Parse(
    const ::std::string& name, LimitationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LimitationType>(
    LimitationType_descriptor(), name, value);
}
enum ConfigurationNotificationEvent {
  UNSPECIFIED_CONFIGURATION_EVENT = 0,
  CONFIGURATION_UPDATED = 1,
  CONFIGURATION_DELETED = 2,
  CONFIGURATION_DELETED_ALL = 3,
  CONFIGURATION_CREATED = 4,
  ConfigurationNotificationEvent_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ConfigurationNotificationEvent_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ConfigurationNotificationEvent_IsValid(int value);
const ConfigurationNotificationEvent ConfigurationNotificationEvent_MIN = UNSPECIFIED_CONFIGURATION_EVENT;
const ConfigurationNotificationEvent ConfigurationNotificationEvent_MAX = CONFIGURATION_CREATED;
const int ConfigurationNotificationEvent_ARRAYSIZE = ConfigurationNotificationEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConfigurationNotificationEvent_descriptor();
inline const ::std::string& ConfigurationNotificationEvent_Name(ConfigurationNotificationEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConfigurationNotificationEvent_descriptor(), value);
}
inline bool ConfigurationNotificationEvent_Parse(
    const ::std::string& name, ConfigurationNotificationEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConfigurationNotificationEvent>(
    ConfigurationNotificationEvent_descriptor(), name, value);
}
enum ControlMode {
  UNSPECIFIED_CONTROL_MODE = 0,
  ANGULAR_JOYSTICK = 1,
  CARTESIAN_JOYSTICK = 2,
  ANGULAR_TRAJECTORY = 4,
  CARTESIAN_TRAJECTORY = 5,
  CARTESIAN_ADMITTANCE = 6,
  JOINT_ADMITTANCE = 7,
  NULL_SPACE_ADMITTANCE = 8,
  FORCE_CONTROL = 10,
  FORCE_CONTROL_MOTION_RESTRICTED = 11,
  IDLE = 13,
  ControlMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ControlMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ControlMode_IsValid(int value);
const ControlMode ControlMode_MIN = UNSPECIFIED_CONTROL_MODE;
const ControlMode ControlMode_MAX = IDLE;
const int ControlMode_ARRAYSIZE = ControlMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControlMode_descriptor();
inline const ::std::string& ControlMode_Name(ControlMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControlMode_descriptor(), value);
}
inline bool ControlMode_Parse(
    const ::std::string& name, ControlMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlMode>(
    ControlMode_descriptor(), name, value);
}
enum OperatingMode {
  UNSPECIFIED_OPERATING_MODE = 0,
  MAINTENANCE_MODE = 1,
  UPDATE_MODE = 2,
  UPDATE_COMPLETED_MODE = 3,
  UPDATE_FAILED_MODE = 4,
  SHUTTING_DOWN_MODE = 5,
  RUN_MODE = 6,
  UPDATING_DEVICE_MODE = 7,
  OperatingMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OperatingMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OperatingMode_IsValid(int value);
const OperatingMode OperatingMode_MIN = UNSPECIFIED_OPERATING_MODE;
const OperatingMode OperatingMode_MAX = UPDATING_DEVICE_MODE;
const int OperatingMode_ARRAYSIZE = OperatingMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* OperatingMode_descriptor();
inline const ::std::string& OperatingMode_Name(OperatingMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    OperatingMode_descriptor(), value);
}
inline bool OperatingMode_Parse(
    const ::std::string& name, OperatingMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OperatingMode>(
    OperatingMode_descriptor(), name, value);
}
enum ServoingMode {
  UNSPECIFIED_SERVOING_MODE = 0,
  SINGLE_LEVEL_SERVOING = 2,
  LOW_LEVEL_SERVOING = 3,
  BYPASS_SERVOING = 4,
  ServoingMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ServoingMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ServoingMode_IsValid(int value);
const ServoingMode ServoingMode_MIN = UNSPECIFIED_SERVOING_MODE;
const ServoingMode ServoingMode_MAX = BYPASS_SERVOING;
const int ServoingMode_ARRAYSIZE = ServoingMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServoingMode_descriptor();
inline const ::std::string& ServoingMode_Name(ServoingMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServoingMode_descriptor(), value);
}
inline bool ServoingMode_Parse(
    const ::std::string& name, ServoingMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServoingMode>(
    ServoingMode_descriptor(), name, value);
}
enum EventIdSequenceInfoNotification {
  UNSPECIFIED_SEQUENCE_EVENT = 0,
  SEQUENCE_COMPLETED = 1,
  SEQUENCE_ABORTED = 2,
  SEQUENCE_PAUSED = 3,
  SEQUENCE_TASK_STARTED = 4,
  SEQUENCE_TASK_COMPLETED = 5,
  SEQUENCE_STARTED = 6,
  EventIdSequenceInfoNotification_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EventIdSequenceInfoNotification_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EventIdSequenceInfoNotification_IsValid(int value);
const EventIdSequenceInfoNotification EventIdSequenceInfoNotification_MIN = UNSPECIFIED_SEQUENCE_EVENT;
const EventIdSequenceInfoNotification EventIdSequenceInfoNotification_MAX = SEQUENCE_STARTED;
const int EventIdSequenceInfoNotification_ARRAYSIZE = EventIdSequenceInfoNotification_MAX + 1;

const ::google::protobuf::EnumDescriptor* EventIdSequenceInfoNotification_descriptor();
inline const ::std::string& EventIdSequenceInfoNotification_Name(EventIdSequenceInfoNotification value) {
  return ::google::protobuf::internal::NameOfEnum(
    EventIdSequenceInfoNotification_descriptor(), value);
}
inline bool EventIdSequenceInfoNotification_Parse(
    const ::std::string& name, EventIdSequenceInfoNotification* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventIdSequenceInfoNotification>(
    EventIdSequenceInfoNotification_descriptor(), name, value);
}
enum ProtectionZoneEvent {
  UNSPECIFIED_PROTECTION_ZONE_EVENT = 0,
  REACHED = 1,
  ENTERED = 2,
  EXITED = 3,
  ProtectionZoneEvent_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ProtectionZoneEvent_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ProtectionZoneEvent_IsValid(int value);
const ProtectionZoneEvent ProtectionZoneEvent_MIN = UNSPECIFIED_PROTECTION_ZONE_EVENT;
const ProtectionZoneEvent ProtectionZoneEvent_MAX = EXITED;
const int ProtectionZoneEvent_ARRAYSIZE = ProtectionZoneEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProtectionZoneEvent_descriptor();
inline const ::std::string& ProtectionZoneEvent_Name(ProtectionZoneEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProtectionZoneEvent_descriptor(), value);
}
inline bool ProtectionZoneEvent_Parse(
    const ::std::string& name, ProtectionZoneEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProtectionZoneEvent>(
    ProtectionZoneEvent_descriptor(), name, value);
}
enum UserEvent {
  UNSPECIFIED_USER_EVENT = 0,
  LOGGED_OUT = 1,
  LOGGED_IN = 2,
  UserEvent_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UserEvent_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UserEvent_IsValid(int value);
const UserEvent UserEvent_MIN = UNSPECIFIED_USER_EVENT;
const UserEvent UserEvent_MAX = LOGGED_IN;
const int UserEvent_ARRAYSIZE = UserEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserEvent_descriptor();
inline const ::std::string& UserEvent_Name(UserEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserEvent_descriptor(), value);
}
inline bool UserEvent_Parse(
    const ::std::string& name, UserEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserEvent>(
    UserEvent_descriptor(), name, value);
}
enum ControllerType {
  UNSPECIFIED_CONTROLLER_TYPE = 0,
  XBOX_CONTROLLER = 1,
  WRIST_CONTROLLER = 2,
  BASIC_JOYSTICK_CONTROLLER = 3,
  BASE_GPIO_CONTROLLER = 4,
  GPIO_JOYSTICK = 5,
  ControllerType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ControllerType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ControllerType_IsValid(int value);
const ControllerType ControllerType_MIN = UNSPECIFIED_CONTROLLER_TYPE;
const ControllerType ControllerType_MAX = GPIO_JOYSTICK;
const int ControllerType_ARRAYSIZE = ControllerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControllerType_descriptor();
inline const ::std::string& ControllerType_Name(ControllerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControllerType_descriptor(), value);
}
inline bool ControllerType_Parse(
    const ::std::string& name, ControllerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControllerType>(
    ControllerType_descriptor(), name, value);
}
enum ControllerEventType {
  UNSPECIFIED_CONTROLLER_EVENT = 0,
  CONTROLLER_DISCONNECTED = 1,
  CONTROLLER_CONNECTED = 2,
  ControllerEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ControllerEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ControllerEventType_IsValid(int value);
const ControllerEventType ControllerEventType_MIN = UNSPECIFIED_CONTROLLER_EVENT;
const ControllerEventType ControllerEventType_MAX = CONTROLLER_CONNECTED;
const int ControllerEventType_ARRAYSIZE = ControllerEventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControllerEventType_descriptor();
inline const ::std::string& ControllerEventType_Name(ControllerEventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControllerEventType_descriptor(), value);
}
inline bool ControllerEventType_Parse(
    const ::std::string& name, ControllerEventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControllerEventType>(
    ControllerEventType_descriptor(), name, value);
}
enum ControllerElementEventType {
  UNSPECIFIED_CONTROLLER_ELEMENT_EVENT = 0,
  AXIS_MOVED = 1,
  BUTTON_DOWN = 2,
  BUTTON_UP = 3,
  BUTTON_CLICK = 4,
  ControllerElementEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ControllerElementEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ControllerElementEventType_IsValid(int value);
const ControllerElementEventType ControllerElementEventType_MIN = UNSPECIFIED_CONTROLLER_ELEMENT_EVENT;
const ControllerElementEventType ControllerElementEventType_MAX = BUTTON_CLICK;
const int ControllerElementEventType_ARRAYSIZE = ControllerElementEventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControllerElementEventType_descriptor();
inline const ::std::string& ControllerElementEventType_Name(ControllerElementEventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControllerElementEventType_descriptor(), value);
}
inline bool ControllerElementEventType_Parse(
    const ::std::string& name, ControllerElementEventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControllerElementEventType>(
    ControllerElementEventType_descriptor(), name, value);
}
enum ActionEvent {
  UNSPECIFIED_ACTION_EVENT = 0,
  ACTION_END = 1,
  ACTION_ABORT = 2,
  ACTION_PAUSE = 3,
  ACTION_START = 4,
  ACTION_PREPROCESS_START = 5,
  ACTION_PREPROCESS_ABORT = 6,
  ACTION_PREPROCESS_END = 7,
  ACTION_POSTPROCESS_START = 8,
  ACTION_POSTPROCESS_ABORT = 9,
  ACTION_POSTPROCESS_END = 10,
  ACTION_FEEDBACK = 11,
  ActionEvent_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ActionEvent_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ActionEvent_IsValid(int value);
const ActionEvent ActionEvent_MIN = UNSPECIFIED_ACTION_EVENT;
const ActionEvent ActionEvent_MAX = ACTION_FEEDBACK;
const int ActionEvent_ARRAYSIZE = ActionEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActionEvent_descriptor();
inline const ::std::string& ActionEvent_Name(ActionEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActionEvent_descriptor(), value);
}
inline bool ActionEvent_Parse(
    const ::std::string& name, ActionEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionEvent>(
    ActionEvent_descriptor(), name, value);
}
enum RobotEvent {
  UNSPECIFIED_ROBOT_EVENT = 0,
  ARM_CONNECTED = 1,
  ARM_DISCONNECTED = 2,
  TOOL_CONNECTED = 5,
  TOOL_DISCONNECTED = 6,
  RobotEvent_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RobotEvent_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RobotEvent_IsValid(int value);
const RobotEvent RobotEvent_MIN = UNSPECIFIED_ROBOT_EVENT;
const RobotEvent RobotEvent_MAX = TOOL_DISCONNECTED;
const int RobotEvent_ARRAYSIZE = RobotEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* RobotEvent_descriptor();
inline const ::std::string& RobotEvent_Name(RobotEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    RobotEvent_descriptor(), value);
}
inline bool RobotEvent_Parse(
    const ::std::string& name, RobotEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RobotEvent>(
    RobotEvent_descriptor(), name, value);
}
enum BackupEvent {
  UNSPECIFIED_BACKUP_EVENT = 0,
  BACKUP_RESTORED = 1,
  BACKUP_UPLOADED = 2,
  BackupEvent_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BackupEvent_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BackupEvent_IsValid(int value);
const BackupEvent BackupEvent_MIN = UNSPECIFIED_BACKUP_EVENT;
const BackupEvent BackupEvent_MAX = BACKUP_UPLOADED;
const int BackupEvent_ARRAYSIZE = BackupEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* BackupEvent_descriptor();
inline const ::std::string& BackupEvent_Name(BackupEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    BackupEvent_descriptor(), value);
}
inline bool BackupEvent_Parse(
    const ::std::string& name, BackupEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BackupEvent>(
    BackupEvent_descriptor(), name, value);
}
enum FactoryEvent {
  UNSPECIFIED_FACTORY_EVENT = 0,
  FACTORY_DEFAULT_RESTORED = 1,
  NETWORK_FACTORY_DEFAULT_RESTORED = 2,
  FactoryEvent_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FactoryEvent_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FactoryEvent_IsValid(int value);
const FactoryEvent FactoryEvent_MIN = UNSPECIFIED_FACTORY_EVENT;
const FactoryEvent FactoryEvent_MAX = NETWORK_FACTORY_DEFAULT_RESTORED;
const int FactoryEvent_ARRAYSIZE = FactoryEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* FactoryEvent_descriptor();
inline const ::std::string& FactoryEvent_Name(FactoryEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    FactoryEvent_descriptor(), value);
}
inline bool FactoryEvent_Parse(
    const ::std::string& name, FactoryEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FactoryEvent>(
    FactoryEvent_descriptor(), name, value);
}
enum NetworkEvent {
  UNSPECIFIED_NETWORK_EVENT = 0,
  WIFI_CONNECTED = 1,
  WIFI_DISCONNECTED = 2,
  WIFI_SCAN_STARTED = 3,
  WIFI_SCAN_RESULTS = 4,
  WIFI_SCAN_FAILED = 5,
  WIFI_NOT_FOUND = 6,
  WIFI_ASSOC_REJECTED = 7,
  WIFI_AUTH_WRONG_KEY = 8,
  WIFI_AUTH_CONN_FAILED = 9,
  WIFI_AUTH_FAILED = 10,
  NetworkEvent_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NetworkEvent_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NetworkEvent_IsValid(int value);
const NetworkEvent NetworkEvent_MIN = UNSPECIFIED_NETWORK_EVENT;
const NetworkEvent NetworkEvent_MAX = WIFI_AUTH_FAILED;
const int NetworkEvent_ARRAYSIZE = NetworkEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* NetworkEvent_descriptor();
inline const ::std::string& NetworkEvent_Name(NetworkEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    NetworkEvent_descriptor(), value);
}
inline bool NetworkEvent_Parse(
    const ::std::string& name, NetworkEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetworkEvent>(
    NetworkEvent_descriptor(), name, value);
}
enum ControllerInputType {
  UNSPECIFIED_CONTROLLER_INPUT_TYPE = 0,
  ANALOG = 1,
  DIGITAL = 2,
  ControllerInputType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ControllerInputType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ControllerInputType_IsValid(int value);
const ControllerInputType ControllerInputType_MIN = UNSPECIFIED_CONTROLLER_INPUT_TYPE;
const ControllerInputType ControllerInputType_MAX = DIGITAL;
const int ControllerInputType_ARRAYSIZE = ControllerInputType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControllerInputType_descriptor();
inline const ::std::string& ControllerInputType_Name(ControllerInputType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControllerInputType_descriptor(), value);
}
inline bool ControllerInputType_Parse(
    const ::std::string& name, ControllerInputType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControllerInputType>(
    ControllerInputType_descriptor(), name, value);
}
enum ControllerBehavior {
  UNSPECIFIED_CONTROLLER_BEHAVIOR = 0,
  CONTROLLER_BUTTON_DOWN = 1,
  CONTROLLER_BUTTON_UP = 2,
  CONTROLLER_AXIS_POSITIVE = 3,
  CONTROLLER_AXIS_NEGATIVE = 4,
  CONTROLLER_BUTTON_CLICK = 5,
  ControllerBehavior_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ControllerBehavior_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ControllerBehavior_IsValid(int value);
const ControllerBehavior ControllerBehavior_MIN = UNSPECIFIED_CONTROLLER_BEHAVIOR;
const ControllerBehavior ControllerBehavior_MAX = CONTROLLER_BUTTON_CLICK;
const int ControllerBehavior_ARRAYSIZE = ControllerBehavior_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControllerBehavior_descriptor();
inline const ::std::string& ControllerBehavior_Name(ControllerBehavior value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControllerBehavior_descriptor(), value);
}
inline bool ControllerBehavior_Parse(
    const ::std::string& name, ControllerBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControllerBehavior>(
    ControllerBehavior_descriptor(), name, value);
}
enum SafetyIdentifier {
  UNSPECIFIED_BASE_SAFETY_IDENTIFIER = 0,
  FIRMWARE_UPDATE_FAILURE = 1,
  EXTERNAL_COMMUNICATION_ERROR = 2,
  MAXIMUM_AMBIENT_TEMPERATURE = 4,
  MAXIMUM_CORE_TEMPERATURE = 8,
  JOINT_FAULT = 16,
  CYCLIC_DATA_JITTER = 32,
  REACHED_MAXIMUM_EVENT_LOGS = 64,
  NO_KINEMATICS_SUPPORT = 128,
  ABOVE_MAXIMUM_DOF = 256,
  NETWORK_ERROR = 512,
  UNABLE_TO_REACH_POSE = 1024,
  JOINT_DETECTION_ERROR = 2048,
  NETWORK_INITIALIZATION_ERROR = 4096,
  MAXIMUM_CURRENT = 8192,
  MAXIMUM_VOLTAGE = 16384,
  MINIMUM_VOLTAGE = 32768,
  MAXIMUM_END_EFFECTOR_TRANSLATION_VELOCITY = 65536,
  MAXIMUM_END_EFFECTOR_ORIENTATION_VELOCITY = 131072,
  MAXIMUM_END_EFFECTOR_TRANSLATION_ACCELERATION = 262144,
  MAXIMUM_END_EFFECTOR_ORIENTATION_ACCELERATION = 524288,
  MAXIMUM_END_EFFECTOR_TRANSLATION_FORCE = 1048576,
  MAXIMUM_END_EFFECTOR_ORIENTATION_FORCE = 2097152,
  MAXIMUM_END_EFFECTOR_PAYLOAD = 4194304,
  EMERGENCY_STOP_ACTIVATED = 8388608,
  EMERGENCY_LINE_ACTIVATED = 16777216,
  INRUSH_CURRENT_LIMITER_FAULT = 33554432,
  NVRAM_CORRUPTED = 67108864,
  INCOMPATIBLE_FIRMWARE_VERSION = 134217728,
  POWERON_SELF_TEST_FAILURE = 268435456,
  DISCRETE_INPUT_STUCK_ACTIVE = 536870912,
  ARM_INTO_ILLEGAL_POSITION = 1073741824,
  SafetyIdentifier_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SafetyIdentifier_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SafetyIdentifier_IsValid(int value);
const SafetyIdentifier SafetyIdentifier_MIN = UNSPECIFIED_BASE_SAFETY_IDENTIFIER;
const SafetyIdentifier SafetyIdentifier_MAX = ARM_INTO_ILLEGAL_POSITION;
const int SafetyIdentifier_ARRAYSIZE = SafetyIdentifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* SafetyIdentifier_descriptor();
inline const ::std::string& SafetyIdentifier_Name(SafetyIdentifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    SafetyIdentifier_descriptor(), value);
}
inline bool SafetyIdentifier_Parse(
    const ::std::string& name, SafetyIdentifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SafetyIdentifier>(
    SafetyIdentifier_descriptor(), name, value);
}
enum JointTrajectoryConstraintType {
  UNSPECIFIED_JOINT_CONSTRAINT = 0,
  JOINT_CONSTRAINT_DURATION = 1,
  JOINT_CONSTRAINT_SPEED = 2,
  JointTrajectoryConstraintType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  JointTrajectoryConstraintType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool JointTrajectoryConstraintType_IsValid(int value);
const JointTrajectoryConstraintType JointTrajectoryConstraintType_MIN = UNSPECIFIED_JOINT_CONSTRAINT;
const JointTrajectoryConstraintType JointTrajectoryConstraintType_MAX = JOINT_CONSTRAINT_SPEED;
const int JointTrajectoryConstraintType_ARRAYSIZE = JointTrajectoryConstraintType_MAX + 1;

const ::google::protobuf::EnumDescriptor* JointTrajectoryConstraintType_descriptor();
inline const ::std::string& JointTrajectoryConstraintType_Name(JointTrajectoryConstraintType value) {
  return ::google::protobuf::internal::NameOfEnum(
    JointTrajectoryConstraintType_descriptor(), value);
}
inline bool JointTrajectoryConstraintType_Parse(
    const ::std::string& name, JointTrajectoryConstraintType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JointTrajectoryConstraintType>(
    JointTrajectoryConstraintType_descriptor(), name, value);
}
enum WrenchMode {
  UNSPECIFIED_WRENCH_MODE = 0,
  WRENCH_RESTRICTED = 1,
  WRENCH_NORMAL = 2,
  WrenchMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  WrenchMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool WrenchMode_IsValid(int value);
const WrenchMode WrenchMode_MIN = UNSPECIFIED_WRENCH_MODE;
const WrenchMode WrenchMode_MAX = WRENCH_NORMAL;
const int WrenchMode_ARRAYSIZE = WrenchMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* WrenchMode_descriptor();
inline const ::std::string& WrenchMode_Name(WrenchMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    WrenchMode_descriptor(), value);
}
inline bool WrenchMode_Parse(
    const ::std::string& name, WrenchMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WrenchMode>(
    WrenchMode_descriptor(), name, value);
}
enum AdmittanceMode {
  UNSPECIFIED_ADMITTANCE_MODE = 0,
  CARTESIAN = 1,
  JOINT = 2,
  NULL_SPACE = 3,
  DISABLED = 4,
  AdmittanceMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AdmittanceMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AdmittanceMode_IsValid(int value);
const AdmittanceMode AdmittanceMode_MIN = UNSPECIFIED_ADMITTANCE_MODE;
const AdmittanceMode AdmittanceMode_MAX = DISABLED;
const int AdmittanceMode_ARRAYSIZE = AdmittanceMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* AdmittanceMode_descriptor();
inline const ::std::string& AdmittanceMode_Name(AdmittanceMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    AdmittanceMode_descriptor(), value);
}
inline bool AdmittanceMode_Parse(
    const ::std::string& name, AdmittanceMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdmittanceMode>(
    AdmittanceMode_descriptor(), name, value);
}
enum GripperMode {
  UNSPECIFIED_GRIPPER_MODE = 0,
  GRIPPER_FORCE = 1,
  GRIPPER_SPEED = 2,
  GRIPPER_POSITION = 3,
  GripperMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GripperMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GripperMode_IsValid(int value);
const GripperMode GripperMode_MIN = UNSPECIFIED_GRIPPER_MODE;
const GripperMode GripperMode_MAX = GRIPPER_POSITION;
const int GripperMode_ARRAYSIZE = GripperMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GripperMode_descriptor();
inline const ::std::string& GripperMode_Name(GripperMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GripperMode_descriptor(), value);
}
inline bool GripperMode_Parse(
    const ::std::string& name, GripperMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GripperMode>(
    GripperMode_descriptor(), name, value);
}
enum GpioAction {
  UNSPECIFIED_GPIO_ACTION = 0,
  GPIOACTION_SET = 1,
  GPIOACTION_CLEAR = 2,
  GPIOACTION_PULSE_HIGH = 3,
  GPIOACTION_PULSE_LOW = 4,
  GpioAction_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GpioAction_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GpioAction_IsValid(int value);
const GpioAction GpioAction_MIN = UNSPECIFIED_GPIO_ACTION;
const GpioAction GpioAction_MAX = GPIOACTION_PULSE_LOW;
const int GpioAction_ARRAYSIZE = GpioAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* GpioAction_descriptor();
inline const ::std::string& GpioAction_Name(GpioAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    GpioAction_descriptor(), value);
}
inline bool GpioAction_Parse(
    const ::std::string& name, GpioAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GpioAction>(
    GpioAction_descriptor(), name, value);
}
enum NavigationDirection {
  UNSPECIFIED_NAVIGATION_DIRECTION = 0,
  NEXT = 1,
  UP = 2,
  DOWN = 3,
  PREVIOUS = 4,
  NavigationDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NavigationDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NavigationDirection_IsValid(int value);
const NavigationDirection NavigationDirection_MIN = UNSPECIFIED_NAVIGATION_DIRECTION;
const NavigationDirection NavigationDirection_MAX = PREVIOUS;
const int NavigationDirection_ARRAYSIZE = NavigationDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* NavigationDirection_descriptor();
inline const ::std::string& NavigationDirection_Name(NavigationDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    NavigationDirection_descriptor(), value);
}
inline bool NavigationDirection_Parse(
    const ::std::string& name, NavigationDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NavigationDirection>(
    NavigationDirection_descriptor(), name, value);
}
enum JointNavigationDirection {
  UNSPECIFIED_JOINT_NAVIGATION_DIRECTION = 0,
  JOINT_NEXT = 1,
  JOINT_PREVIOUS = 2,
  JointNavigationDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  JointNavigationDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool JointNavigationDirection_IsValid(int value);
const JointNavigationDirection JointNavigationDirection_MIN = UNSPECIFIED_JOINT_NAVIGATION_DIRECTION;
const JointNavigationDirection JointNavigationDirection_MAX = JOINT_PREVIOUS;
const int JointNavigationDirection_ARRAYSIZE = JointNavigationDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* JointNavigationDirection_descriptor();
inline const ::std::string& JointNavigationDirection_Name(JointNavigationDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    JointNavigationDirection_descriptor(), value);
}
inline bool JointNavigationDirection_Parse(
    const ::std::string& name, JointNavigationDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JointNavigationDirection>(
    JointNavigationDirection_descriptor(), name, value);
}
enum SoundType {
  UNSPECIFIED_SOUND_TYPE = 0,
  BIP_SERIES = 1,
  SINGLE_BIP = 2,
  SoundType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SoundType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SoundType_IsValid(int value);
const SoundType SoundType_MIN = UNSPECIFIED_SOUND_TYPE;
const SoundType SoundType_MAX = SINGLE_BIP;
const int SoundType_ARRAYSIZE = SoundType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SoundType_descriptor();
inline const ::std::string& SoundType_Name(SoundType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SoundType_descriptor(), value);
}
inline bool SoundType_Parse(
    const ::std::string& name, SoundType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SoundType>(
    SoundType_descriptor(), name, value);
}
enum LedState {
  UNSPECIFIED_LED_STATE = 0,
  LED_OFF = 1,
  LED_PULSE = 2,
  LED_ON = 3,
  LedState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LedState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LedState_IsValid(int value);
const LedState LedState_MIN = UNSPECIFIED_LED_STATE;
const LedState LedState_MAX = LED_ON;
const int LedState_ARRAYSIZE = LedState_MAX + 1;

const ::google::protobuf::EnumDescriptor* LedState_descriptor();
inline const ::std::string& LedState_Name(LedState value) {
  return ::google::protobuf::internal::NameOfEnum(
    LedState_descriptor(), value);
}
inline bool LedState_Parse(
    const ::std::string& name, LedState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LedState>(
    LedState_descriptor(), name, value);
}
enum GpioBehavior {
  UNSPECIFIED_GPIO_BEHAVIOR = 0,
  GPIO_FALLING = 1,
  GPIO_RISING = 2,
  GPIO_PULSE_LOW = 3,
  GPIO_PULSE_HIGH = 4,
  GPIO_ANALOG_CHANGE = 5,
  GpioBehavior_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GpioBehavior_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GpioBehavior_IsValid(int value);
const GpioBehavior GpioBehavior_MIN = UNSPECIFIED_GPIO_BEHAVIOR;
const GpioBehavior GpioBehavior_MAX = GPIO_ANALOG_CHANGE;
const int GpioBehavior_ARRAYSIZE = GpioBehavior_MAX + 1;

const ::google::protobuf::EnumDescriptor* GpioBehavior_descriptor();
inline const ::std::string& GpioBehavior_Name(GpioBehavior value) {
  return ::google::protobuf::internal::NameOfEnum(
    GpioBehavior_descriptor(), value);
}
inline bool GpioBehavior_Parse(
    const ::std::string& name, GpioBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GpioBehavior>(
    GpioBehavior_descriptor(), name, value);
}
enum Gen3GpioPinId {
  UNSPECIFIED_PIN = 0,
  GPIO_PIN_B = 1,
  GPIO_PIN_C = 2,
  GPIO_PIN_D = 3,
  GPIO_PIN_E = 4,
  GPIO_PIN_G = 5,
  GPIO_PIN_H = 6,
  GPIO_PIN_I = 7,
  GPIO_PIN_K = 8,
  GPIO_PIN_N = 9,
  GPIO_PIN_O = 10,
  GPIO_PIN_S = 11,
  GPIO_PIN_T = 12,
  Gen3GpioPinId_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Gen3GpioPinId_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Gen3GpioPinId_IsValid(int value);
const Gen3GpioPinId Gen3GpioPinId_MIN = UNSPECIFIED_PIN;
const Gen3GpioPinId Gen3GpioPinId_MAX = GPIO_PIN_T;
const int Gen3GpioPinId_ARRAYSIZE = Gen3GpioPinId_MAX + 1;

const ::google::protobuf::EnumDescriptor* Gen3GpioPinId_descriptor();
inline const ::std::string& Gen3GpioPinId_Name(Gen3GpioPinId value) {
  return ::google::protobuf::internal::NameOfEnum(
    Gen3GpioPinId_descriptor(), value);
}
inline bool Gen3GpioPinId_Parse(
    const ::std::string& name, Gen3GpioPinId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Gen3GpioPinId>(
    Gen3GpioPinId_descriptor(), name, value);
}
enum Xbox360DigitalInputIdentifier {
  UNSPECIFIED_XBOX360_DIGITAL = 0,
  XBOX360_PAD_UP = 1,
  XBOX360_PAD_DOWN = 2,
  XBOX360_PAD_LEFT = 3,
  XBOX360_PAD_RIGHT = 4,
  XBOX360_FILE_BUTTON_START = 5,
  XBOX360_DOCUMENT_BUTTON_BACK = 6,
  XBOX360_LEFT_THUMB_BUTTON = 7,
  XBOX360_RIGHT_THUMB_BUTTON = 8,
  XBOX360_LEFT_SHOULDER = 9,
  XBOX360_RIGHT_SHOULDER = 10,
  XBOX360_BUTTON_A = 13,
  XBOX360_BUTTON_B = 14,
  XBOX360_BUTTON_X = 15,
  XBOX360_BUTTON_Y = 16,
  Xbox360DigitalInputIdentifier_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Xbox360DigitalInputIdentifier_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Xbox360DigitalInputIdentifier_IsValid(int value);
const Xbox360DigitalInputIdentifier Xbox360DigitalInputIdentifier_MIN = UNSPECIFIED_XBOX360_DIGITAL;
const Xbox360DigitalInputIdentifier Xbox360DigitalInputIdentifier_MAX = XBOX360_BUTTON_Y;
const int Xbox360DigitalInputIdentifier_ARRAYSIZE = Xbox360DigitalInputIdentifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* Xbox360DigitalInputIdentifier_descriptor();
inline const ::std::string& Xbox360DigitalInputIdentifier_Name(Xbox360DigitalInputIdentifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    Xbox360DigitalInputIdentifier_descriptor(), value);
}
inline bool Xbox360DigitalInputIdentifier_Parse(
    const ::std::string& name, Xbox360DigitalInputIdentifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Xbox360DigitalInputIdentifier>(
    Xbox360DigitalInputIdentifier_descriptor(), name, value);
}
enum Xbox360AnalogInputIdentifier {
  UNSPECIFIED_XBOX360_ANALOG = 0,
  XBOX360_THUMB_LEFT_X = 1,
  XBOX360_THUMB_LEFT_Y = 2,
  XBOX360_THUMB_RIGHT_X = 3,
  XBOX360_THUMB_RIGHT_Y = 4,
  XBOX360_TRIGGER_LEFT = 5,
  XBOX360_TRIGGER_RIGHT = 6,
  Xbox360AnalogInputIdentifier_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Xbox360AnalogInputIdentifier_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Xbox360AnalogInputIdentifier_IsValid(int value);
const Xbox360AnalogInputIdentifier Xbox360AnalogInputIdentifier_MIN = UNSPECIFIED_XBOX360_ANALOG;
const Xbox360AnalogInputIdentifier Xbox360AnalogInputIdentifier_MAX = XBOX360_TRIGGER_RIGHT;
const int Xbox360AnalogInputIdentifier_ARRAYSIZE = Xbox360AnalogInputIdentifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* Xbox360AnalogInputIdentifier_descriptor();
inline const ::std::string& Xbox360AnalogInputIdentifier_Name(Xbox360AnalogInputIdentifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    Xbox360AnalogInputIdentifier_descriptor(), value);
}
inline bool Xbox360AnalogInputIdentifier_Parse(
    const ::std::string& name, Xbox360AnalogInputIdentifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Xbox360AnalogInputIdentifier>(
    Xbox360AnalogInputIdentifier_descriptor(), name, value);
}
enum WristDigitalInputIdentifier {
  UNSPECIFIED_WRIST_DIGITAL = 0,
  WRIST_BUTTON_1 = 1,
  WRIST_BUTTON_2 = 2,
  WRIST_BUTTON_BOTH = 3,
  WristDigitalInputIdentifier_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  WristDigitalInputIdentifier_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool WristDigitalInputIdentifier_IsValid(int value);
const WristDigitalInputIdentifier WristDigitalInputIdentifier_MIN = UNSPECIFIED_WRIST_DIGITAL;
const WristDigitalInputIdentifier WristDigitalInputIdentifier_MAX = WRIST_BUTTON_BOTH;
const int WristDigitalInputIdentifier_ARRAYSIZE = WristDigitalInputIdentifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* WristDigitalInputIdentifier_descriptor();
inline const ::std::string& WristDigitalInputIdentifier_Name(WristDigitalInputIdentifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    WristDigitalInputIdentifier_descriptor(), value);
}
inline bool WristDigitalInputIdentifier_Parse(
    const ::std::string& name, WristDigitalInputIdentifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WristDigitalInputIdentifier>(
    WristDigitalInputIdentifier_descriptor(), name, value);
}
enum CapSenseMode {
  RESERVED = 0,
  INACTIVE = 1,
  ACTIVE_AUTO_THRESHOLD = 2,
  ACTIVE_NOISE_ATT = 4,
  ACTIVE_NORMAL = 5,
  CONFIGURATION = 6,
  CapSenseMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CapSenseMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CapSenseMode_IsValid(int value);
const CapSenseMode CapSenseMode_MIN = RESERVED;
const CapSenseMode CapSenseMode_MAX = CONFIGURATION;
const int CapSenseMode_ARRAYSIZE = CapSenseMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CapSenseMode_descriptor();
inline const ::std::string& CapSenseMode_Name(CapSenseMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CapSenseMode_descriptor(), value);
}
inline bool CapSenseMode_Parse(
    const ::std::string& name, CapSenseMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CapSenseMode>(
    CapSenseMode_descriptor(), name, value);
}
enum BridgeStatus {
  BRIDGE_STATUS_OK = 0,
  BRIDGE_STATUS_OUTP_UNAVAILABLE = 1,
  BRIDGE_STATUS_UNKNOWN_DEVID = 2,
  BRIDGE_STATUS_UNKNOWN_BRIDGE_TYPE = 3,
  BRIDGE_STATUS_NOT_FOUND = 4,
  BRIDGE_STATUS_NOT_INITIALIZED = 5,
  BRIDGE_STATUS_UNKNOWN = 6,
  BridgeStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BridgeStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BridgeStatus_IsValid(int value);
const BridgeStatus BridgeStatus_MIN = BRIDGE_STATUS_OK;
const BridgeStatus BridgeStatus_MAX = BRIDGE_STATUS_UNKNOWN;
const int BridgeStatus_ARRAYSIZE = BridgeStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* BridgeStatus_descriptor();
inline const ::std::string& BridgeStatus_Name(BridgeStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    BridgeStatus_descriptor(), value);
}
inline bool BridgeStatus_Parse(
    const ::std::string& name, BridgeStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BridgeStatus>(
    BridgeStatus_descriptor(), name, value);
}
enum BridgeType {
  BRIDGE_TYPE_UNSPECIFIED = 0,
  BRIDGE_TYPE_UART = 1,
  BRIDGE_TYPE_TELNET = 2,
  BridgeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BridgeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BridgeType_IsValid(int value);
const BridgeType BridgeType_MIN = BRIDGE_TYPE_UNSPECIFIED;
const BridgeType BridgeType_MAX = BRIDGE_TYPE_TELNET;
const int BridgeType_ARRAYSIZE = BridgeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BridgeType_descriptor();
inline const ::std::string& BridgeType_Name(BridgeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BridgeType_descriptor(), value);
}
inline bool BridgeType_Parse(
    const ::std::string& name, BridgeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BridgeType>(
    BridgeType_descriptor(), name, value);
}
enum TrajectoryContinuityMode {
  TRAJECTORY_CONTINUITY_MODE_UNSPECIFIED = 0,
  TRAJECTORY_CONTINUITY_MODE_POSITION = 1,
  TRAJECTORY_CONTINUITY_MODE_SPEED = 2,
  TRAJECTORY_CONTINUITY_MODE_ACCELERATION = 3,
  TrajectoryContinuityMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrajectoryContinuityMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrajectoryContinuityMode_IsValid(int value);
const TrajectoryContinuityMode TrajectoryContinuityMode_MIN = TRAJECTORY_CONTINUITY_MODE_UNSPECIFIED;
const TrajectoryContinuityMode TrajectoryContinuityMode_MAX = TRAJECTORY_CONTINUITY_MODE_ACCELERATION;
const int TrajectoryContinuityMode_ARRAYSIZE = TrajectoryContinuityMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrajectoryContinuityMode_descriptor();
inline const ::std::string& TrajectoryContinuityMode_Name(TrajectoryContinuityMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrajectoryContinuityMode_descriptor(), value);
}
inline bool TrajectoryContinuityMode_Parse(
    const ::std::string& name, TrajectoryContinuityMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrajectoryContinuityMode>(
    TrajectoryContinuityMode_descriptor(), name, value);
}
enum TrajectoryErrorType {
  TRAJECTORY_ERROR_TYPE_UNSPECIFIED = 0,
  TRAJECTORY_ERROR_TYPE_OUTSIDE_WORKSPACE = 1,
  TRAJECTORY_ERROR_TYPE_ACTUATOR_COUNT_MISMATCH = 2,
  TRAJECTORY_ERROR_TYPE_INVALID_DURATION = 3,
  TRAJECTORY_ERROR_TYPE_JOINT_NO_MOTION = 4,
  TRAJECTORY_ERROR_TYPE_ZERO_DISTANCE PROTOBUF_DEPRECATED = 4,
  TRAJECTORY_ERROR_TYPE_INVALID_JOINT_SPEED = 5,
  TRAJECTORY_ERROR_TYPE_INVALID_SPEED PROTOBUF_DEPRECATED = 5,
  TRAJECTORY_ERROR_TYPE_LARGE_SPEED PROTOBUF_DEPRECATED = 6,
  TRAJECTORY_ERROR_TYPE_INVALID_JOINT_ACCELERATION = 7,
  TRAJECTORY_ERROR_TYPE_INVALID_ACCELERATION PROTOBUF_DEPRECATED = 7,
  TRAJECTORY_ERROR_TYPE_INVALID_TIME_STEP = 8,
  TRAJECTORY_ERROR_TYPE_INVALID_TRAJECTORY_SIZE = 9,
  TRAJECTORY_ERROR_TYPE_LARGE_SIZE PROTOBUF_DEPRECATED = 9,
  TRAJECTORY_ERROR_TYPE_WRONG_MODE PROTOBUF_DEPRECATED = 10,
  TRAJECTORY_ERROR_TYPE_INVALID_JOINT_POSITION = 11,
  TRAJECTORY_ERROR_TYPE_JOINT_POSITION_LIMIT PROTOBUF_DEPRECATED = 11,
  TRAJECTORY_ERROR_TYPE_FILE_ERROR PROTOBUF_DEPRECATED = 12,
  TRAJECTORY_ERROR_TYPE_NO_FILE_IN_MEMORY PROTOBUF_DEPRECATED = 13,
  TRAJECTORY_ERROR_TYPE_INDEX_OUT_OF_TRAJ PROTOBUF_DEPRECATED = 14,
  TRAJECTORY_ERROR_TYPE_TRAJECTORY_ALREADY_RUNNING = 15,
  TRAJECTORY_ERROR_TYPE_ALREADY_RUNNING PROTOBUF_DEPRECATED = 15,
  TRAJECTORY_ERROR_TYPE_WRONG_STARTING_POINT PROTOBUF_DEPRECATED = 16,
  TRAJECTORY_ERROR_TYPE_CARTESIAN_CANNOT_START PROTOBUF_DEPRECATED = 17,
  TRAJECTORY_ERROR_TYPE_WRONG_STARTING_SPEED PROTOBUF_DEPRECATED = 18,
  TRAJECTORY_ERROR_TYPE_INVALID_POSITION PROTOBUF_DEPRECATED = 19,
  TRAJECTORY_ERROR_TYPE_INVALID_CARTESIAN_POSITION = 20,
  TRAJECTORY_ERROR_TYPE_INVALID_CARTESIAN_ORIENTATION = 21,
  TRAJECTORY_ERROR_TYPE_INVALID_CARTESIAN_LINEAR_VELOCITY = 22,
  TRAJECTORY_ERROR_TYPE_INVALID_CARTESIAN_ANGULAR_VELOCITY = 23,
  TRAJECTORY_ERROR_TYPE_INVALID_JOINT_TORQUE = 24,
  TRAJECTORY_ERROR_TYPE_MULTIPLE_WAYPOINT_TYPE_LIST = 25,
  TRAJECTORY_ERROR_TYPE_INITIAL_WAYPOINT_NO_STOP = 26,
  TRAJECTORY_ERROR_TYPE_FINAL_WAYPOINT_NO_STOP = 27,
  TRAJECTORY_ERROR_TYPE_INVALID_BLENDING_RADIUS = 28,
  TRAJECTORY_ERROR_TYPE_INVALID_REFERENCE_FRAME = 29,
  TRAJECTORY_ERROR_TYPE_NUMERICAL_ERROR_IMPOSSIBLE_TRAJECTORY = 30,
  TrajectoryErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrajectoryErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrajectoryErrorType_IsValid(int value);
const TrajectoryErrorType TrajectoryErrorType_MIN = TRAJECTORY_ERROR_TYPE_UNSPECIFIED;
const TrajectoryErrorType TrajectoryErrorType_MAX = TRAJECTORY_ERROR_TYPE_NUMERICAL_ERROR_IMPOSSIBLE_TRAJECTORY;
const int TrajectoryErrorType_ARRAYSIZE = TrajectoryErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrajectoryErrorType_descriptor();
inline const ::std::string& TrajectoryErrorType_Name(TrajectoryErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrajectoryErrorType_descriptor(), value);
}
inline bool TrajectoryErrorType_Parse(
    const ::std::string& name, TrajectoryErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrajectoryErrorType>(
    TrajectoryErrorType_descriptor(), name, value);
}
enum TrajectoryErrorIdentifier {
  TRAJECTORY_ERROR_IDENTIFIER_UNSPECIFIED = 0,
  TRAJECTORY_ERROR_IDENTIFIER_UNAPPLICABLE = 1,
  TRAJECTORY_ERROR_IDENTIFIER_TIME = 2,
  TRAJECTORY_ERROR_IDENTIFIER_POSITION = 3,
  TRAJECTORY_ERROR_IDENTIFIER_VELOCITY = 4,
  TRAJECTORY_ERROR_IDENTIFIER_ACCELERATION = 5,
  TrajectoryErrorIdentifier_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrajectoryErrorIdentifier_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrajectoryErrorIdentifier_IsValid(int value);
const TrajectoryErrorIdentifier TrajectoryErrorIdentifier_MIN = TRAJECTORY_ERROR_IDENTIFIER_UNSPECIFIED;
const TrajectoryErrorIdentifier TrajectoryErrorIdentifier_MAX = TRAJECTORY_ERROR_IDENTIFIER_ACCELERATION;
const int TrajectoryErrorIdentifier_ARRAYSIZE = TrajectoryErrorIdentifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrajectoryErrorIdentifier_descriptor();
inline const ::std::string& TrajectoryErrorIdentifier_Name(TrajectoryErrorIdentifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrajectoryErrorIdentifier_descriptor(), value);
}
inline bool TrajectoryErrorIdentifier_Parse(
    const ::std::string& name, TrajectoryErrorIdentifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrajectoryErrorIdentifier>(
    TrajectoryErrorIdentifier_descriptor(), name, value);
}
enum TrajectoryInfoType {
  UNSPECIFIED_TRAJECTORY_INFORMATION = 0,
  JOINT_ACCELERATION_LIMIT_REACHED = 1,
  JOINT_SPEED_LIMIT_REACHED = 2,
  JOINT_POSITION_LIMIT_REACHED = 3,
  JOINT_TORQUE_LIMIT_REACHED = 4,
  SINGULARITY_REGION = 5,
  INVERSE_KINEMATIC_FAILED = 6,
  CARTESIAN_ACCELERATION_LIMIT_REACHED = 7,
  CARTESIAN_SPEED_LIMIT_REACHED = 8,
  CARTESIAN_POSITION_LIMIT_REACHED = 9,
  CARTESIAN_WRENCH_LIMIT_REACHED = 10,
  ENTERING_PROTECTION_ZONE = 11,
  WAYPOINT_REACHED = 12,
  TRAJECTORY_OK = 13,
  TrajectoryInfoType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrajectoryInfoType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrajectoryInfoType_IsValid(int value);
const TrajectoryInfoType TrajectoryInfoType_MIN = UNSPECIFIED_TRAJECTORY_INFORMATION;
const TrajectoryInfoType TrajectoryInfoType_MAX = TRAJECTORY_OK;
const int TrajectoryInfoType_ARRAYSIZE = TrajectoryInfoType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrajectoryInfoType_descriptor();
inline const ::std::string& TrajectoryInfoType_Name(TrajectoryInfoType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrajectoryInfoType_descriptor(), value);
}
inline bool TrajectoryInfoType_Parse(
    const ::std::string& name, TrajectoryInfoType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrajectoryInfoType>(
    TrajectoryInfoType_descriptor(), name, value);
}
// ===================================================================

class GpioConfigurationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.GpioConfigurationList) */ {
 public:
  GpioConfigurationList();
  virtual ~GpioConfigurationList();

  GpioConfigurationList(const GpioConfigurationList& from);

  inline GpioConfigurationList& operator=(const GpioConfigurationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GpioConfigurationList(GpioConfigurationList&& from) noexcept
    : GpioConfigurationList() {
    *this = ::std::move(from);
  }

  inline GpioConfigurationList& operator=(GpioConfigurationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpioConfigurationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GpioConfigurationList* internal_default_instance() {
    return reinterpret_cast<const GpioConfigurationList*>(
               &_GpioConfigurationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(GpioConfigurationList* other);
  friend void swap(GpioConfigurationList& a, GpioConfigurationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GpioConfigurationList* New() const PROTOBUF_FINAL { return New(NULL); }

  GpioConfigurationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GpioConfigurationList& from);
  void MergeFrom(const GpioConfigurationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GpioConfigurationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.GpioConfiguration port_configurations = 1;
  int port_configurations_size() const;
  void clear_port_configurations();
  static const int kPortConfigurationsFieldNumber = 1;
  const ::Kinova::Api::Base::GpioConfiguration& port_configurations(int index) const;
  ::Kinova::Api::Base::GpioConfiguration* mutable_port_configurations(int index);
  ::Kinova::Api::Base::GpioConfiguration* add_port_configurations();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::GpioConfiguration >*
      mutable_port_configurations();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::GpioConfiguration >&
      port_configurations() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.GpioConfigurationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::GpioConfiguration > port_configurations_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsGpioConfigurationListImpl();
};
// -------------------------------------------------------------------

class GpioConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.GpioConfiguration) */ {
 public:
  GpioConfiguration();
  virtual ~GpioConfiguration();

  GpioConfiguration(const GpioConfiguration& from);

  inline GpioConfiguration& operator=(const GpioConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GpioConfiguration(GpioConfiguration&& from) noexcept
    : GpioConfiguration() {
    *this = ::std::move(from);
  }

  inline GpioConfiguration& operator=(GpioConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpioConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GpioConfiguration* internal_default_instance() {
    return reinterpret_cast<const GpioConfiguration*>(
               &_GpioConfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(GpioConfiguration* other);
  friend void swap(GpioConfiguration& a, GpioConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GpioConfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  GpioConfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GpioConfiguration& from);
  void MergeFrom(const GpioConfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GpioConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.GpioPinConfiguration pin_configurations = 2;
  int pin_configurations_size() const;
  void clear_pin_configurations();
  static const int kPinConfigurationsFieldNumber = 2;
  const ::Kinova::Api::Base::GpioPinConfiguration& pin_configurations(int index) const;
  ::Kinova::Api::Base::GpioPinConfiguration* mutable_pin_configurations(int index);
  ::Kinova::Api::Base::GpioPinConfiguration* add_pin_configurations();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::GpioPinConfiguration >*
      mutable_pin_configurations();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::GpioPinConfiguration >&
      pin_configurations() const;

  // uint32 port_number = 1;
  void clear_port_number();
  static const int kPortNumberFieldNumber = 1;
  ::google::protobuf::uint32 port_number() const;
  void set_port_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.GpioConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::GpioPinConfiguration > pin_configurations_;
  ::google::protobuf::uint32 port_number_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsGpioConfigurationImpl();
};
// -------------------------------------------------------------------

class GpioPinConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.GpioPinConfiguration) */ {
 public:
  GpioPinConfiguration();
  virtual ~GpioPinConfiguration();

  GpioPinConfiguration(const GpioPinConfiguration& from);

  inline GpioPinConfiguration& operator=(const GpioPinConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GpioPinConfiguration(GpioPinConfiguration&& from) noexcept
    : GpioPinConfiguration() {
    *this = ::std::move(from);
  }

  inline GpioPinConfiguration& operator=(GpioPinConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpioPinConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GpioPinConfiguration* internal_default_instance() {
    return reinterpret_cast<const GpioPinConfiguration*>(
               &_GpioPinConfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(GpioPinConfiguration* other);
  friend void swap(GpioPinConfiguration& a, GpioPinConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GpioPinConfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  GpioPinConfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GpioPinConfiguration& from);
  void MergeFrom(const GpioPinConfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GpioPinConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 pin_id = 1;
  void clear_pin_id();
  static const int kPinIdFieldNumber = 1;
  ::google::protobuf::uint32 pin_id() const;
  void set_pin_id(::google::protobuf::uint32 value);

  // .Kinova.Api.Base.GpioPinPropertyFlags pin_property = 2;
  void clear_pin_property();
  static const int kPinPropertyFieldNumber = 2;
  ::Kinova::Api::Base::GpioPinPropertyFlags pin_property() const;
  void set_pin_property(::Kinova::Api::Base::GpioPinPropertyFlags value);

  // bool output_enable = 3;
  void clear_output_enable();
  static const int kOutputEnableFieldNumber = 3;
  bool output_enable() const;
  void set_output_enable(bool value);

  // bool default_output_value = 4;
  void clear_default_output_value();
  static const int kDefaultOutputValueFieldNumber = 4;
  bool default_output_value() const;
  void set_default_output_value(bool value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.GpioPinConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 pin_id_;
  int pin_property_;
  bool output_enable_;
  bool default_output_value_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsGpioPinConfigurationImpl();
};
// -------------------------------------------------------------------

class FullUserProfile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.FullUserProfile) */ {
 public:
  FullUserProfile();
  virtual ~FullUserProfile();

  FullUserProfile(const FullUserProfile& from);

  inline FullUserProfile& operator=(const FullUserProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FullUserProfile(FullUserProfile&& from) noexcept
    : FullUserProfile() {
    *this = ::std::move(from);
  }

  inline FullUserProfile& operator=(FullUserProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FullUserProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FullUserProfile* internal_default_instance() {
    return reinterpret_cast<const FullUserProfile*>(
               &_FullUserProfile_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(FullUserProfile* other);
  friend void swap(FullUserProfile& a, FullUserProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FullUserProfile* New() const PROTOBUF_FINAL { return New(NULL); }

  FullUserProfile* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FullUserProfile& from);
  void MergeFrom(const FullUserProfile& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FullUserProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // .Kinova.Api.Base.UserProfile user_profile = 1;
  bool has_user_profile() const;
  void clear_user_profile();
  static const int kUserProfileFieldNumber = 1;
  const ::Kinova::Api::Base::UserProfile& user_profile() const;
  ::Kinova::Api::Base::UserProfile* release_user_profile();
  ::Kinova::Api::Base::UserProfile* mutable_user_profile();
  void set_allocated_user_profile(::Kinova::Api::Base::UserProfile* user_profile);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.FullUserProfile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::Kinova::Api::Base::UserProfile* user_profile_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsFullUserProfileImpl();
};
// -------------------------------------------------------------------

class UserProfile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.UserProfile) */ {
 public:
  UserProfile();
  virtual ~UserProfile();

  UserProfile(const UserProfile& from);

  inline UserProfile& operator=(const UserProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserProfile(UserProfile&& from) noexcept
    : UserProfile() {
    *this = ::std::move(from);
  }

  inline UserProfile& operator=(UserProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserProfile* internal_default_instance() {
    return reinterpret_cast<const UserProfile*>(
               &_UserProfile_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(UserProfile* other);
  friend void swap(UserProfile& a, UserProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserProfile* New() const PROTOBUF_FINAL { return New(NULL); }

  UserProfile* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserProfile& from);
  void MergeFrom(const UserProfile& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 2;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string firstname = 3;
  void clear_firstname();
  static const int kFirstnameFieldNumber = 3;
  const ::std::string& firstname() const;
  void set_firstname(const ::std::string& value);
  #if LANG_CXX11
  void set_firstname(::std::string&& value);
  #endif
  void set_firstname(const char* value);
  void set_firstname(const char* value, size_t size);
  ::std::string* mutable_firstname();
  ::std::string* release_firstname();
  void set_allocated_firstname(::std::string* firstname);

  // string lastname = 4;
  void clear_lastname();
  static const int kLastnameFieldNumber = 4;
  const ::std::string& lastname() const;
  void set_lastname(const ::std::string& value);
  #if LANG_CXX11
  void set_lastname(::std::string&& value);
  #endif
  void set_lastname(const char* value);
  void set_lastname(const char* value, size_t size);
  ::std::string* mutable_lastname();
  ::std::string* release_lastname();
  void set_allocated_lastname(::std::string* lastname);

  // string application_data = 5;
  void clear_application_data();
  static const int kApplicationDataFieldNumber = 5;
  const ::std::string& application_data() const;
  void set_application_data(const ::std::string& value);
  #if LANG_CXX11
  void set_application_data(::std::string&& value);
  #endif
  void set_application_data(const char* value);
  void set_application_data(const char* value, size_t size);
  ::std::string* mutable_application_data();
  ::std::string* release_application_data();
  void set_allocated_application_data(::std::string* application_data);

  // .Kinova.Api.Common.UserProfileHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Common::UserProfileHandle& handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Common::UserProfileHandle* handle);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.UserProfile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr firstname_;
  ::google::protobuf::internal::ArenaStringPtr lastname_;
  ::google::protobuf::internal::ArenaStringPtr application_data_;
  ::Kinova::Api::Common::UserProfileHandle* handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsUserProfileImpl();
};
// -------------------------------------------------------------------

class UserProfileList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.UserProfileList) */ {
 public:
  UserProfileList();
  virtual ~UserProfileList();

  UserProfileList(const UserProfileList& from);

  inline UserProfileList& operator=(const UserProfileList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserProfileList(UserProfileList&& from) noexcept
    : UserProfileList() {
    *this = ::std::move(from);
  }

  inline UserProfileList& operator=(UserProfileList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserProfileList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserProfileList* internal_default_instance() {
    return reinterpret_cast<const UserProfileList*>(
               &_UserProfileList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(UserProfileList* other);
  friend void swap(UserProfileList& a, UserProfileList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserProfileList* New() const PROTOBUF_FINAL { return New(NULL); }

  UserProfileList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserProfileList& from);
  void MergeFrom(const UserProfileList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserProfileList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.UserProfile user_profiles = 1;
  int user_profiles_size() const;
  void clear_user_profiles();
  static const int kUserProfilesFieldNumber = 1;
  const ::Kinova::Api::Base::UserProfile& user_profiles(int index) const;
  ::Kinova::Api::Base::UserProfile* mutable_user_profiles(int index);
  ::Kinova::Api::Base::UserProfile* add_user_profiles();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::UserProfile >*
      mutable_user_profiles();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::UserProfile >&
      user_profiles() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.UserProfileList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::UserProfile > user_profiles_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsUserProfileListImpl();
};
// -------------------------------------------------------------------

class UserList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.UserList) */ {
 public:
  UserList();
  virtual ~UserList();

  UserList(const UserList& from);

  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserList(UserList&& from) noexcept
    : UserList() {
    *this = ::std::move(from);
  }

  inline UserList& operator=(UserList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserList* internal_default_instance() {
    return reinterpret_cast<const UserList*>(
               &_UserList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(UserList* other);
  friend void swap(UserList& a, UserList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserList* New() const PROTOBUF_FINAL { return New(NULL); }

  UserList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Common.UserProfileHandle user_handles = 1;
  int user_handles_size() const;
  void clear_user_handles();
  static const int kUserHandlesFieldNumber = 1;
  const ::Kinova::Api::Common::UserProfileHandle& user_handles(int index) const;
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handles(int index);
  ::Kinova::Api::Common::UserProfileHandle* add_user_handles();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Common::UserProfileHandle >*
      mutable_user_handles();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Common::UserProfileHandle >&
      user_handles() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.UserList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Common::UserProfileHandle > user_handles_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsUserListImpl();
};
// -------------------------------------------------------------------

class PasswordChange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.PasswordChange) */ {
 public:
  PasswordChange();
  virtual ~PasswordChange();

  PasswordChange(const PasswordChange& from);

  inline PasswordChange& operator=(const PasswordChange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PasswordChange(PasswordChange&& from) noexcept
    : PasswordChange() {
    *this = ::std::move(from);
  }

  inline PasswordChange& operator=(PasswordChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PasswordChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PasswordChange* internal_default_instance() {
    return reinterpret_cast<const PasswordChange*>(
               &_PasswordChange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(PasswordChange* other);
  friend void swap(PasswordChange& a, PasswordChange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PasswordChange* New() const PROTOBUF_FINAL { return New(NULL); }

  PasswordChange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PasswordChange& from);
  void MergeFrom(const PasswordChange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PasswordChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string old_password = 2;
  void clear_old_password();
  static const int kOldPasswordFieldNumber = 2;
  const ::std::string& old_password() const;
  void set_old_password(const ::std::string& value);
  #if LANG_CXX11
  void set_old_password(::std::string&& value);
  #endif
  void set_old_password(const char* value);
  void set_old_password(const char* value, size_t size);
  ::std::string* mutable_old_password();
  ::std::string* release_old_password();
  void set_allocated_old_password(::std::string* old_password);

  // string new_password = 3;
  void clear_new_password();
  static const int kNewPasswordFieldNumber = 3;
  const ::std::string& new_password() const;
  void set_new_password(const ::std::string& value);
  #if LANG_CXX11
  void set_new_password(::std::string&& value);
  #endif
  void set_new_password(const char* value);
  void set_new_password(const char* value, size_t size);
  ::std::string* mutable_new_password();
  ::std::string* release_new_password();
  void set_allocated_new_password(::std::string* new_password);

  // .Kinova.Api.Common.UserProfileHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Common::UserProfileHandle& handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Common::UserProfileHandle* handle);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.PasswordChange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr old_password_;
  ::google::protobuf::internal::ArenaStringPtr new_password_;
  ::Kinova::Api::Common::UserProfileHandle* handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsPasswordChangeImpl();
};
// -------------------------------------------------------------------

class SequenceHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SequenceHandle) */ {
 public:
  SequenceHandle();
  virtual ~SequenceHandle();

  SequenceHandle(const SequenceHandle& from);

  inline SequenceHandle& operator=(const SequenceHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SequenceHandle(SequenceHandle&& from) noexcept
    : SequenceHandle() {
    *this = ::std::move(from);
  }

  inline SequenceHandle& operator=(SequenceHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SequenceHandle* internal_default_instance() {
    return reinterpret_cast<const SequenceHandle*>(
               &_SequenceHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(SequenceHandle* other);
  friend void swap(SequenceHandle& a, SequenceHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SequenceHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  SequenceHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SequenceHandle& from);
  void MergeFrom(const SequenceHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SequenceHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 identifier() const;
  void set_identifier(::google::protobuf::uint32 value);

  // fixed32 permission = 2;
  void clear_permission();
  static const int kPermissionFieldNumber = 2;
  ::google::protobuf::uint32 permission() const;
  void set_permission(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SequenceHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 identifier_;
  ::google::protobuf::uint32 permission_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSequenceHandleImpl();
};
// -------------------------------------------------------------------

class AdvancedSequenceHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.AdvancedSequenceHandle) */ {
 public:
  AdvancedSequenceHandle();
  virtual ~AdvancedSequenceHandle();

  AdvancedSequenceHandle(const AdvancedSequenceHandle& from);

  inline AdvancedSequenceHandle& operator=(const AdvancedSequenceHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdvancedSequenceHandle(AdvancedSequenceHandle&& from) noexcept
    : AdvancedSequenceHandle() {
    *this = ::std::move(from);
  }

  inline AdvancedSequenceHandle& operator=(AdvancedSequenceHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AdvancedSequenceHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdvancedSequenceHandle* internal_default_instance() {
    return reinterpret_cast<const AdvancedSequenceHandle*>(
               &_AdvancedSequenceHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(AdvancedSequenceHandle* other);
  friend void swap(AdvancedSequenceHandle& a, AdvancedSequenceHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdvancedSequenceHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  AdvancedSequenceHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AdvancedSequenceHandle& from);
  void MergeFrom(const AdvancedSequenceHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AdvancedSequenceHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.SequenceHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Base::SequenceHandle& handle() const;
  ::Kinova::Api::Base::SequenceHandle* release_handle();
  ::Kinova::Api::Base::SequenceHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Base::SequenceHandle* handle);

  // bool in_loop = 2;
  void clear_in_loop();
  static const int kInLoopFieldNumber = 2;
  bool in_loop() const;
  void set_in_loop(bool value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.AdvancedSequenceHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::SequenceHandle* handle_;
  bool in_loop_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsAdvancedSequenceHandleImpl();
};
// -------------------------------------------------------------------

class SequenceTaskHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SequenceTaskHandle) */ {
 public:
  SequenceTaskHandle();
  virtual ~SequenceTaskHandle();

  SequenceTaskHandle(const SequenceTaskHandle& from);

  inline SequenceTaskHandle& operator=(const SequenceTaskHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SequenceTaskHandle(SequenceTaskHandle&& from) noexcept
    : SequenceTaskHandle() {
    *this = ::std::move(from);
  }

  inline SequenceTaskHandle& operator=(SequenceTaskHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceTaskHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SequenceTaskHandle* internal_default_instance() {
    return reinterpret_cast<const SequenceTaskHandle*>(
               &_SequenceTaskHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(SequenceTaskHandle* other);
  friend void swap(SequenceTaskHandle& a, SequenceTaskHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SequenceTaskHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  SequenceTaskHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SequenceTaskHandle& from);
  void MergeFrom(const SequenceTaskHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SequenceTaskHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.SequenceHandle sequence_handle = 1;
  bool has_sequence_handle() const;
  void clear_sequence_handle();
  static const int kSequenceHandleFieldNumber = 1;
  const ::Kinova::Api::Base::SequenceHandle& sequence_handle() const;
  ::Kinova::Api::Base::SequenceHandle* release_sequence_handle();
  ::Kinova::Api::Base::SequenceHandle* mutable_sequence_handle();
  void set_allocated_sequence_handle(::Kinova::Api::Base::SequenceHandle* sequence_handle);

  // uint32 task_index = 2;
  void clear_task_index();
  static const int kTaskIndexFieldNumber = 2;
  ::google::protobuf::uint32 task_index() const;
  void set_task_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SequenceTaskHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::SequenceHandle* sequence_handle_;
  ::google::protobuf::uint32 task_index_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSequenceTaskHandleImpl();
};
// -------------------------------------------------------------------

class SequenceTask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SequenceTask) */ {
 public:
  SequenceTask();
  virtual ~SequenceTask();

  SequenceTask(const SequenceTask& from);

  inline SequenceTask& operator=(const SequenceTask& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SequenceTask(SequenceTask&& from) noexcept
    : SequenceTask() {
    *this = ::std::move(from);
  }

  inline SequenceTask& operator=(SequenceTask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SequenceTask* internal_default_instance() {
    return reinterpret_cast<const SequenceTask*>(
               &_SequenceTask_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(SequenceTask* other);
  friend void swap(SequenceTask& a, SequenceTask& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SequenceTask* New() const PROTOBUF_FINAL { return New(NULL); }

  SequenceTask* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SequenceTask& from);
  void MergeFrom(const SequenceTask& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SequenceTask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string application_data = 3;
  void clear_application_data();
  static const int kApplicationDataFieldNumber = 3;
  const ::std::string& application_data() const;
  void set_application_data(const ::std::string& value);
  #if LANG_CXX11
  void set_application_data(::std::string&& value);
  #endif
  void set_application_data(const char* value);
  void set_application_data(const char* value, size_t size);
  ::std::string* mutable_application_data();
  ::std::string* release_application_data();
  void set_allocated_application_data(::std::string* application_data);

  // .Kinova.Api.Base.Action action = 2;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 2;
  const ::Kinova::Api::Base::Action& action() const;
  ::Kinova::Api::Base::Action* release_action();
  ::Kinova::Api::Base::Action* mutable_action();
  void set_allocated_action(::Kinova::Api::Base::Action* action);

  // uint32 group_identifier = 1;
  void clear_group_identifier();
  static const int kGroupIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 group_identifier() const;
  void set_group_identifier(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SequenceTask)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr application_data_;
  ::Kinova::Api::Base::Action* action_;
  ::google::protobuf::uint32 group_identifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSequenceTaskImpl();
};
// -------------------------------------------------------------------

class SequenceTasks : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SequenceTasks) */ {
 public:
  SequenceTasks();
  virtual ~SequenceTasks();

  SequenceTasks(const SequenceTasks& from);

  inline SequenceTasks& operator=(const SequenceTasks& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SequenceTasks(SequenceTasks&& from) noexcept
    : SequenceTasks() {
    *this = ::std::move(from);
  }

  inline SequenceTasks& operator=(SequenceTasks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceTasks& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SequenceTasks* internal_default_instance() {
    return reinterpret_cast<const SequenceTasks*>(
               &_SequenceTasks_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(SequenceTasks* other);
  friend void swap(SequenceTasks& a, SequenceTasks& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SequenceTasks* New() const PROTOBUF_FINAL { return New(NULL); }

  SequenceTasks* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SequenceTasks& from);
  void MergeFrom(const SequenceTasks& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SequenceTasks* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.SequenceTask sequence_tasks = 1;
  int sequence_tasks_size() const;
  void clear_sequence_tasks();
  static const int kSequenceTasksFieldNumber = 1;
  const ::Kinova::Api::Base::SequenceTask& sequence_tasks(int index) const;
  ::Kinova::Api::Base::SequenceTask* mutable_sequence_tasks(int index);
  ::Kinova::Api::Base::SequenceTask* add_sequence_tasks();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask >*
      mutable_sequence_tasks();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask >&
      sequence_tasks() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SequenceTasks)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask > sequence_tasks_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSequenceTasksImpl();
};
// -------------------------------------------------------------------

class SequenceTasksConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SequenceTasksConfiguration) */ {
 public:
  SequenceTasksConfiguration();
  virtual ~SequenceTasksConfiguration();

  SequenceTasksConfiguration(const SequenceTasksConfiguration& from);

  inline SequenceTasksConfiguration& operator=(const SequenceTasksConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SequenceTasksConfiguration(SequenceTasksConfiguration&& from) noexcept
    : SequenceTasksConfiguration() {
    *this = ::std::move(from);
  }

  inline SequenceTasksConfiguration& operator=(SequenceTasksConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceTasksConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SequenceTasksConfiguration* internal_default_instance() {
    return reinterpret_cast<const SequenceTasksConfiguration*>(
               &_SequenceTasksConfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(SequenceTasksConfiguration* other);
  friend void swap(SequenceTasksConfiguration& a, SequenceTasksConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SequenceTasksConfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  SequenceTasksConfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SequenceTasksConfiguration& from);
  void MergeFrom(const SequenceTasksConfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SequenceTasksConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.SequenceTask sequence_tasks = 2;
  int sequence_tasks_size() const;
  void clear_sequence_tasks();
  static const int kSequenceTasksFieldNumber = 2;
  const ::Kinova::Api::Base::SequenceTask& sequence_tasks(int index) const;
  ::Kinova::Api::Base::SequenceTask* mutable_sequence_tasks(int index);
  ::Kinova::Api::Base::SequenceTask* add_sequence_tasks();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask >*
      mutable_sequence_tasks();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask >&
      sequence_tasks() const;

  // .Kinova.Api.Base.SequenceTaskHandle sequence_task_handle = 1;
  bool has_sequence_task_handle() const;
  void clear_sequence_task_handle();
  static const int kSequenceTaskHandleFieldNumber = 1;
  const ::Kinova::Api::Base::SequenceTaskHandle& sequence_task_handle() const;
  ::Kinova::Api::Base::SequenceTaskHandle* release_sequence_task_handle();
  ::Kinova::Api::Base::SequenceTaskHandle* mutable_sequence_task_handle();
  void set_allocated_sequence_task_handle(::Kinova::Api::Base::SequenceTaskHandle* sequence_task_handle);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SequenceTasksConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask > sequence_tasks_;
  ::Kinova::Api::Base::SequenceTaskHandle* sequence_task_handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSequenceTasksConfigurationImpl();
};
// -------------------------------------------------------------------

class SequenceTaskConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SequenceTaskConfiguration) */ {
 public:
  SequenceTaskConfiguration();
  virtual ~SequenceTaskConfiguration();

  SequenceTaskConfiguration(const SequenceTaskConfiguration& from);

  inline SequenceTaskConfiguration& operator=(const SequenceTaskConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SequenceTaskConfiguration(SequenceTaskConfiguration&& from) noexcept
    : SequenceTaskConfiguration() {
    *this = ::std::move(from);
  }

  inline SequenceTaskConfiguration& operator=(SequenceTaskConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceTaskConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SequenceTaskConfiguration* internal_default_instance() {
    return reinterpret_cast<const SequenceTaskConfiguration*>(
               &_SequenceTaskConfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(SequenceTaskConfiguration* other);
  friend void swap(SequenceTaskConfiguration& a, SequenceTaskConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SequenceTaskConfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  SequenceTaskConfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SequenceTaskConfiguration& from);
  void MergeFrom(const SequenceTaskConfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SequenceTaskConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.SequenceTaskHandle sequence_task_handle = 1;
  bool has_sequence_task_handle() const;
  void clear_sequence_task_handle();
  static const int kSequenceTaskHandleFieldNumber = 1;
  const ::Kinova::Api::Base::SequenceTaskHandle& sequence_task_handle() const;
  ::Kinova::Api::Base::SequenceTaskHandle* release_sequence_task_handle();
  ::Kinova::Api::Base::SequenceTaskHandle* mutable_sequence_task_handle();
  void set_allocated_sequence_task_handle(::Kinova::Api::Base::SequenceTaskHandle* sequence_task_handle);

  // .Kinova.Api.Base.SequenceTask sequence_task = 2;
  bool has_sequence_task() const;
  void clear_sequence_task();
  static const int kSequenceTaskFieldNumber = 2;
  const ::Kinova::Api::Base::SequenceTask& sequence_task() const;
  ::Kinova::Api::Base::SequenceTask* release_sequence_task();
  ::Kinova::Api::Base::SequenceTask* mutable_sequence_task();
  void set_allocated_sequence_task(::Kinova::Api::Base::SequenceTask* sequence_task);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SequenceTaskConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::SequenceTaskHandle* sequence_task_handle_;
  ::Kinova::Api::Base::SequenceTask* sequence_task_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSequenceTaskConfigurationImpl();
};
// -------------------------------------------------------------------

class SequenceTasksRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SequenceTasksRange) */ {
 public:
  SequenceTasksRange();
  virtual ~SequenceTasksRange();

  SequenceTasksRange(const SequenceTasksRange& from);

  inline SequenceTasksRange& operator=(const SequenceTasksRange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SequenceTasksRange(SequenceTasksRange&& from) noexcept
    : SequenceTasksRange() {
    *this = ::std::move(from);
  }

  inline SequenceTasksRange& operator=(SequenceTasksRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceTasksRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SequenceTasksRange* internal_default_instance() {
    return reinterpret_cast<const SequenceTasksRange*>(
               &_SequenceTasksRange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(SequenceTasksRange* other);
  friend void swap(SequenceTasksRange& a, SequenceTasksRange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SequenceTasksRange* New() const PROTOBUF_FINAL { return New(NULL); }

  SequenceTasksRange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SequenceTasksRange& from);
  void MergeFrom(const SequenceTasksRange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SequenceTasksRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 first_task_index = 1;
  void clear_first_task_index();
  static const int kFirstTaskIndexFieldNumber = 1;
  ::google::protobuf::uint32 first_task_index() const;
  void set_first_task_index(::google::protobuf::uint32 value);

  // uint32 second_task_index = 2;
  void clear_second_task_index();
  static const int kSecondTaskIndexFieldNumber = 2;
  ::google::protobuf::uint32 second_task_index() const;
  void set_second_task_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SequenceTasksRange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 first_task_index_;
  ::google::protobuf::uint32 second_task_index_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSequenceTasksRangeImpl();
};
// -------------------------------------------------------------------

class SequenceTasksPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SequenceTasksPair) */ {
 public:
  SequenceTasksPair();
  virtual ~SequenceTasksPair();

  SequenceTasksPair(const SequenceTasksPair& from);

  inline SequenceTasksPair& operator=(const SequenceTasksPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SequenceTasksPair(SequenceTasksPair&& from) noexcept
    : SequenceTasksPair() {
    *this = ::std::move(from);
  }

  inline SequenceTasksPair& operator=(SequenceTasksPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceTasksPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SequenceTasksPair* internal_default_instance() {
    return reinterpret_cast<const SequenceTasksPair*>(
               &_SequenceTasksPair_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(SequenceTasksPair* other);
  friend void swap(SequenceTasksPair& a, SequenceTasksPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SequenceTasksPair* New() const PROTOBUF_FINAL { return New(NULL); }

  SequenceTasksPair* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SequenceTasksPair& from);
  void MergeFrom(const SequenceTasksPair& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SequenceTasksPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.SequenceHandle sequence_handle = 1;
  bool has_sequence_handle() const;
  void clear_sequence_handle();
  static const int kSequenceHandleFieldNumber = 1;
  const ::Kinova::Api::Base::SequenceHandle& sequence_handle() const;
  ::Kinova::Api::Base::SequenceHandle* release_sequence_handle();
  ::Kinova::Api::Base::SequenceHandle* mutable_sequence_handle();
  void set_allocated_sequence_handle(::Kinova::Api::Base::SequenceHandle* sequence_handle);

  // uint32 first_task_index = 2;
  void clear_first_task_index();
  static const int kFirstTaskIndexFieldNumber = 2;
  ::google::protobuf::uint32 first_task_index() const;
  void set_first_task_index(::google::protobuf::uint32 value);

  // uint32 second_task_index = 3;
  void clear_second_task_index();
  static const int kSecondTaskIndexFieldNumber = 3;
  ::google::protobuf::uint32 second_task_index() const;
  void set_second_task_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SequenceTasksPair)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::SequenceHandle* sequence_handle_;
  ::google::protobuf::uint32 first_task_index_;
  ::google::protobuf::uint32 second_task_index_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSequenceTasksPairImpl();
};
// -------------------------------------------------------------------

class Sequence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Sequence) */ {
 public:
  Sequence();
  virtual ~Sequence();

  Sequence(const Sequence& from);

  inline Sequence& operator=(const Sequence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sequence(Sequence&& from) noexcept
    : Sequence() {
    *this = ::std::move(from);
  }

  inline Sequence& operator=(Sequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sequence* internal_default_instance() {
    return reinterpret_cast<const Sequence*>(
               &_Sequence_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(Sequence* other);
  friend void swap(Sequence& a, Sequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sequence* New() const PROTOBUF_FINAL { return New(NULL); }

  Sequence* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Sequence& from);
  void MergeFrom(const Sequence& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Sequence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.SequenceTask tasks = 4;
  int tasks_size() const;
  void clear_tasks();
  static const int kTasksFieldNumber = 4;
  const ::Kinova::Api::Base::SequenceTask& tasks(int index) const;
  ::Kinova::Api::Base::SequenceTask* mutable_tasks(int index);
  ::Kinova::Api::Base::SequenceTask* add_tasks();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask >*
      mutable_tasks();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask >&
      tasks() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string application_data = 3;
  void clear_application_data();
  static const int kApplicationDataFieldNumber = 3;
  const ::std::string& application_data() const;
  void set_application_data(const ::std::string& value);
  #if LANG_CXX11
  void set_application_data(::std::string&& value);
  #endif
  void set_application_data(const char* value);
  void set_application_data(const char* value, size_t size);
  ::std::string* mutable_application_data();
  ::std::string* release_application_data();
  void set_allocated_application_data(::std::string* application_data);

  // .Kinova.Api.Base.SequenceHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Base::SequenceHandle& handle() const;
  ::Kinova::Api::Base::SequenceHandle* release_handle();
  ::Kinova::Api::Base::SequenceHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Base::SequenceHandle* handle);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Sequence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask > tasks_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr application_data_;
  ::Kinova::Api::Base::SequenceHandle* handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSequenceImpl();
};
// -------------------------------------------------------------------

class SequenceList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SequenceList) */ {
 public:
  SequenceList();
  virtual ~SequenceList();

  SequenceList(const SequenceList& from);

  inline SequenceList& operator=(const SequenceList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SequenceList(SequenceList&& from) noexcept
    : SequenceList() {
    *this = ::std::move(from);
  }

  inline SequenceList& operator=(SequenceList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SequenceList* internal_default_instance() {
    return reinterpret_cast<const SequenceList*>(
               &_SequenceList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(SequenceList* other);
  friend void swap(SequenceList& a, SequenceList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SequenceList* New() const PROTOBUF_FINAL { return New(NULL); }

  SequenceList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SequenceList& from);
  void MergeFrom(const SequenceList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SequenceList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.Sequence sequence_list = 1;
  int sequence_list_size() const;
  void clear_sequence_list();
  static const int kSequenceListFieldNumber = 1;
  const ::Kinova::Api::Base::Sequence& sequence_list(int index) const;
  ::Kinova::Api::Base::Sequence* mutable_sequence_list(int index);
  ::Kinova::Api::Base::Sequence* add_sequence_list();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Sequence >*
      mutable_sequence_list();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Sequence >&
      sequence_list() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SequenceList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Sequence > sequence_list_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSequenceListImpl();
};
// -------------------------------------------------------------------

class AppendActionInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.AppendActionInformation) */ {
 public:
  AppendActionInformation();
  virtual ~AppendActionInformation();

  AppendActionInformation(const AppendActionInformation& from);

  inline AppendActionInformation& operator=(const AppendActionInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppendActionInformation(AppendActionInformation&& from) noexcept
    : AppendActionInformation() {
    *this = ::std::move(from);
  }

  inline AppendActionInformation& operator=(AppendActionInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendActionInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppendActionInformation* internal_default_instance() {
    return reinterpret_cast<const AppendActionInformation*>(
               &_AppendActionInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(AppendActionInformation* other);
  friend void swap(AppendActionInformation& a, AppendActionInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppendActionInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  AppendActionInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AppendActionInformation& from);
  void MergeFrom(const AppendActionInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AppendActionInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.SequenceHandle sequence_handle = 1;
  bool has_sequence_handle() const;
  void clear_sequence_handle();
  static const int kSequenceHandleFieldNumber = 1;
  const ::Kinova::Api::Base::SequenceHandle& sequence_handle() const;
  ::Kinova::Api::Base::SequenceHandle* release_sequence_handle();
  ::Kinova::Api::Base::SequenceHandle* mutable_sequence_handle();
  void set_allocated_sequence_handle(::Kinova::Api::Base::SequenceHandle* sequence_handle);

  // .Kinova.Api.Base.Action action = 2;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 2;
  const ::Kinova::Api::Base::Action& action() const;
  ::Kinova::Api::Base::Action* release_action();
  ::Kinova::Api::Base::Action* mutable_action();
  void set_allocated_action(::Kinova::Api::Base::Action* action);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.AppendActionInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::SequenceHandle* sequence_handle_;
  ::Kinova::Api::Base::Action* action_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsAppendActionInformationImpl();
};
// -------------------------------------------------------------------

class ActionHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ActionHandle) */ {
 public:
  ActionHandle();
  virtual ~ActionHandle();

  ActionHandle(const ActionHandle& from);

  inline ActionHandle& operator=(const ActionHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionHandle(ActionHandle&& from) noexcept
    : ActionHandle() {
    *this = ::std::move(from);
  }

  inline ActionHandle& operator=(ActionHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionHandle* internal_default_instance() {
    return reinterpret_cast<const ActionHandle*>(
               &_ActionHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(ActionHandle* other);
  friend void swap(ActionHandle& a, ActionHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  ActionHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ActionHandle& from);
  void MergeFrom(const ActionHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ActionHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 identifier() const;
  void set_identifier(::google::protobuf::uint32 value);

  // .Kinova.Api.Base.ActionType action_type = 2;
  void clear_action_type();
  static const int kActionTypeFieldNumber = 2;
  ::Kinova::Api::Base::ActionType action_type() const;
  void set_action_type(::Kinova::Api::Base::ActionType value);

  // fixed32 permission = 3;
  void clear_permission();
  static const int kPermissionFieldNumber = 3;
  ::google::protobuf::uint32 permission() const;
  void set_permission(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ActionHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 identifier_;
  int action_type_;
  ::google::protobuf::uint32 permission_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsActionHandleImpl();
};
// -------------------------------------------------------------------

class RequestedActionType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.RequestedActionType) */ {
 public:
  RequestedActionType();
  virtual ~RequestedActionType();

  RequestedActionType(const RequestedActionType& from);

  inline RequestedActionType& operator=(const RequestedActionType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestedActionType(RequestedActionType&& from) noexcept
    : RequestedActionType() {
    *this = ::std::move(from);
  }

  inline RequestedActionType& operator=(RequestedActionType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestedActionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestedActionType* internal_default_instance() {
    return reinterpret_cast<const RequestedActionType*>(
               &_RequestedActionType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(RequestedActionType* other);
  friend void swap(RequestedActionType& a, RequestedActionType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestedActionType* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestedActionType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestedActionType& from);
  void MergeFrom(const RequestedActionType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestedActionType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.ActionType action_type = 1;
  void clear_action_type();
  static const int kActionTypeFieldNumber = 1;
  ::Kinova::Api::Base::ActionType action_type() const;
  void set_action_type(::Kinova::Api::Base::ActionType value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.RequestedActionType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int action_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsRequestedActionTypeImpl();
};
// -------------------------------------------------------------------

class Action : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Action) */ {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(Action&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Action& default_instance();

  enum ActionParametersCase {
    kSendTwistCommand = 4,
    kSendWrenchCommand = 5,
    kSendJointSpeeds = 7,
    kReachPose = 9,
    kReachJointAngles = 10,
    kToggleAdmittanceMode = 16,
    kSnapshot = 17,
    kSwitchControlMapping = 19,
    kNavigateJoints = 20,
    kNavigateMappings = 21,
    kChangeTwist = 25,
    kChangeJointSpeeds = 26,
    kChangeWrench = 28,
    kApplyEmergencyStop = 31,
    kClearFaults = 32,
    kDelay = 34,
    kExecuteAction = 35,
    kSendGripperCommand = 36,
    kSendGpioCommand = 37,
    kStopAction = 38,
    kPlayPreComputedTrajectory = 39,
    kExecuteSequence = 40,
    kExecuteWaypointList = 41,
    ACTION_PARAMETERS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Action* other);
  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Action* New() const PROTOBUF_FINAL { return New(NULL); }

  Action* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Action* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string application_data = 3;
  void clear_application_data();
  static const int kApplicationDataFieldNumber = 3;
  const ::std::string& application_data() const;
  void set_application_data(const ::std::string& value);
  #if LANG_CXX11
  void set_application_data(::std::string&& value);
  #endif
  void set_application_data(const char* value);
  void set_application_data(const char* value, size_t size);
  ::std::string* mutable_application_data();
  ::std::string* release_application_data();
  void set_allocated_application_data(::std::string* application_data);

  // .Kinova.Api.Base.ActionHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Base::ActionHandle& handle() const;
  ::Kinova::Api::Base::ActionHandle* release_handle();
  ::Kinova::Api::Base::ActionHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Base::ActionHandle* handle);

  // .Kinova.Api.Base.TwistCommand send_twist_command = 4;
  bool has_send_twist_command() const;
  void clear_send_twist_command();
  static const int kSendTwistCommandFieldNumber = 4;
  const ::Kinova::Api::Base::TwistCommand& send_twist_command() const;
  ::Kinova::Api::Base::TwistCommand* release_send_twist_command();
  ::Kinova::Api::Base::TwistCommand* mutable_send_twist_command();
  void set_allocated_send_twist_command(::Kinova::Api::Base::TwistCommand* send_twist_command);

  // .Kinova.Api.Base.WrenchCommand send_wrench_command = 5;
  bool has_send_wrench_command() const;
  void clear_send_wrench_command();
  static const int kSendWrenchCommandFieldNumber = 5;
  const ::Kinova::Api::Base::WrenchCommand& send_wrench_command() const;
  ::Kinova::Api::Base::WrenchCommand* release_send_wrench_command();
  ::Kinova::Api::Base::WrenchCommand* mutable_send_wrench_command();
  void set_allocated_send_wrench_command(::Kinova::Api::Base::WrenchCommand* send_wrench_command);

  // .Kinova.Api.Base.JointSpeeds send_joint_speeds = 7;
  bool has_send_joint_speeds() const;
  void clear_send_joint_speeds();
  static const int kSendJointSpeedsFieldNumber = 7;
  const ::Kinova::Api::Base::JointSpeeds& send_joint_speeds() const;
  ::Kinova::Api::Base::JointSpeeds* release_send_joint_speeds();
  ::Kinova::Api::Base::JointSpeeds* mutable_send_joint_speeds();
  void set_allocated_send_joint_speeds(::Kinova::Api::Base::JointSpeeds* send_joint_speeds);

  // .Kinova.Api.Base.ConstrainedPose reach_pose = 9;
  bool has_reach_pose() const;
  void clear_reach_pose();
  static const int kReachPoseFieldNumber = 9;
  const ::Kinova::Api::Base::ConstrainedPose& reach_pose() const;
  ::Kinova::Api::Base::ConstrainedPose* release_reach_pose();
  ::Kinova::Api::Base::ConstrainedPose* mutable_reach_pose();
  void set_allocated_reach_pose(::Kinova::Api::Base::ConstrainedPose* reach_pose);

  // .Kinova.Api.Base.ConstrainedJointAngles reach_joint_angles = 10;
  bool has_reach_joint_angles() const;
  void clear_reach_joint_angles();
  static const int kReachJointAnglesFieldNumber = 10;
  const ::Kinova::Api::Base::ConstrainedJointAngles& reach_joint_angles() const;
  ::Kinova::Api::Base::ConstrainedJointAngles* release_reach_joint_angles();
  ::Kinova::Api::Base::ConstrainedJointAngles* mutable_reach_joint_angles();
  void set_allocated_reach_joint_angles(::Kinova::Api::Base::ConstrainedJointAngles* reach_joint_angles);

  // .Kinova.Api.Base.AdmittanceMode toggle_admittance_mode = 16;
  private:
  bool has_toggle_admittance_mode() const;
  public:
  void clear_toggle_admittance_mode();
  static const int kToggleAdmittanceModeFieldNumber = 16;
  ::Kinova::Api::Base::AdmittanceMode toggle_admittance_mode() const;
  void set_toggle_admittance_mode(::Kinova::Api::Base::AdmittanceMode value);

  // .Kinova.Api.Base.Snapshot snapshot = 17;
  bool has_snapshot() const;
  void clear_snapshot();
  static const int kSnapshotFieldNumber = 17;
  const ::Kinova::Api::Base::Snapshot& snapshot() const;
  ::Kinova::Api::Base::Snapshot* release_snapshot();
  ::Kinova::Api::Base::Snapshot* mutable_snapshot();
  void set_allocated_snapshot(::Kinova::Api::Base::Snapshot* snapshot);

  // .Kinova.Api.Base.SwitchControlMapping switch_control_mapping = 19;
  bool has_switch_control_mapping() const;
  void clear_switch_control_mapping();
  static const int kSwitchControlMappingFieldNumber = 19;
  const ::Kinova::Api::Base::SwitchControlMapping& switch_control_mapping() const;
  ::Kinova::Api::Base::SwitchControlMapping* release_switch_control_mapping();
  ::Kinova::Api::Base::SwitchControlMapping* mutable_switch_control_mapping();
  void set_allocated_switch_control_mapping(::Kinova::Api::Base::SwitchControlMapping* switch_control_mapping);

  // .Kinova.Api.Base.JointNavigationDirection navigate_joints = 20;
  private:
  bool has_navigate_joints() const;
  public:
  void clear_navigate_joints();
  static const int kNavigateJointsFieldNumber = 20;
  ::Kinova::Api::Base::JointNavigationDirection navigate_joints() const;
  void set_navigate_joints(::Kinova::Api::Base::JointNavigationDirection value);

  // .Kinova.Api.Base.NavigationDirection navigate_mappings = 21;
  private:
  bool has_navigate_mappings() const;
  public:
  void clear_navigate_mappings();
  static const int kNavigateMappingsFieldNumber = 21;
  ::Kinova::Api::Base::NavigationDirection navigate_mappings() const;
  void set_navigate_mappings(::Kinova::Api::Base::NavigationDirection value);

  // .Kinova.Api.Base.ChangeTwist change_twist = 25;
  bool has_change_twist() const;
  void clear_change_twist();
  static const int kChangeTwistFieldNumber = 25;
  const ::Kinova::Api::Base::ChangeTwist& change_twist() const;
  ::Kinova::Api::Base::ChangeTwist* release_change_twist();
  ::Kinova::Api::Base::ChangeTwist* mutable_change_twist();
  void set_allocated_change_twist(::Kinova::Api::Base::ChangeTwist* change_twist);

  // .Kinova.Api.Base.ChangeJointSpeeds change_joint_speeds = 26;
  bool has_change_joint_speeds() const;
  void clear_change_joint_speeds();
  static const int kChangeJointSpeedsFieldNumber = 26;
  const ::Kinova::Api::Base::ChangeJointSpeeds& change_joint_speeds() const;
  ::Kinova::Api::Base::ChangeJointSpeeds* release_change_joint_speeds();
  ::Kinova::Api::Base::ChangeJointSpeeds* mutable_change_joint_speeds();
  void set_allocated_change_joint_speeds(::Kinova::Api::Base::ChangeJointSpeeds* change_joint_speeds);

  // .Kinova.Api.Base.ChangeWrench change_wrench = 28;
  bool has_change_wrench() const;
  void clear_change_wrench();
  static const int kChangeWrenchFieldNumber = 28;
  const ::Kinova::Api::Base::ChangeWrench& change_wrench() const;
  ::Kinova::Api::Base::ChangeWrench* release_change_wrench();
  ::Kinova::Api::Base::ChangeWrench* mutable_change_wrench();
  void set_allocated_change_wrench(::Kinova::Api::Base::ChangeWrench* change_wrench);

  // .Kinova.Api.Base.EmergencyStop apply_emergency_stop = 31;
  bool has_apply_emergency_stop() const;
  void clear_apply_emergency_stop();
  static const int kApplyEmergencyStopFieldNumber = 31;
  const ::Kinova::Api::Base::EmergencyStop& apply_emergency_stop() const;
  ::Kinova::Api::Base::EmergencyStop* release_apply_emergency_stop();
  ::Kinova::Api::Base::EmergencyStop* mutable_apply_emergency_stop();
  void set_allocated_apply_emergency_stop(::Kinova::Api::Base::EmergencyStop* apply_emergency_stop);

  // .Kinova.Api.Base.Faults clear_faults = 32;
  bool has_clear_faults() const;
  void clear_clear_faults();
  static const int kClearFaultsFieldNumber = 32;
  const ::Kinova::Api::Base::Faults& clear_faults() const;
  ::Kinova::Api::Base::Faults* release_clear_faults();
  ::Kinova::Api::Base::Faults* mutable_clear_faults();
  void set_allocated_clear_faults(::Kinova::Api::Base::Faults* clear_faults);

  // .Kinova.Api.Base.Delay delay = 34;
  bool has_delay() const;
  void clear_delay();
  static const int kDelayFieldNumber = 34;
  const ::Kinova::Api::Base::Delay& delay() const;
  ::Kinova::Api::Base::Delay* release_delay();
  ::Kinova::Api::Base::Delay* mutable_delay();
  void set_allocated_delay(::Kinova::Api::Base::Delay* delay);

  // .Kinova.Api.Base.ActionHandle execute_action = 35;
  bool has_execute_action() const;
  void clear_execute_action();
  static const int kExecuteActionFieldNumber = 35;
  const ::Kinova::Api::Base::ActionHandle& execute_action() const;
  ::Kinova::Api::Base::ActionHandle* release_execute_action();
  ::Kinova::Api::Base::ActionHandle* mutable_execute_action();
  void set_allocated_execute_action(::Kinova::Api::Base::ActionHandle* execute_action);

  // .Kinova.Api.Base.GripperCommand send_gripper_command = 36;
  bool has_send_gripper_command() const;
  void clear_send_gripper_command();
  static const int kSendGripperCommandFieldNumber = 36;
  const ::Kinova::Api::Base::GripperCommand& send_gripper_command() const;
  ::Kinova::Api::Base::GripperCommand* release_send_gripper_command();
  ::Kinova::Api::Base::GripperCommand* mutable_send_gripper_command();
  void set_allocated_send_gripper_command(::Kinova::Api::Base::GripperCommand* send_gripper_command);

  // .Kinova.Api.Base.GpioCommand send_gpio_command = 37;
  bool has_send_gpio_command() const;
  void clear_send_gpio_command();
  static const int kSendGpioCommandFieldNumber = 37;
  const ::Kinova::Api::Base::GpioCommand& send_gpio_command() const;
  ::Kinova::Api::Base::GpioCommand* release_send_gpio_command();
  ::Kinova::Api::Base::GpioCommand* mutable_send_gpio_command();
  void set_allocated_send_gpio_command(::Kinova::Api::Base::GpioCommand* send_gpio_command);

  // .Kinova.Api.Base.Stop stop_action = 38;
  bool has_stop_action() const;
  void clear_stop_action();
  static const int kStopActionFieldNumber = 38;
  const ::Kinova::Api::Base::Stop& stop_action() const;
  ::Kinova::Api::Base::Stop* release_stop_action();
  ::Kinova::Api::Base::Stop* mutable_stop_action();
  void set_allocated_stop_action(::Kinova::Api::Base::Stop* stop_action);

  // .Kinova.Api.Base.PreComputedJointTrajectory play_pre_computed_trajectory = 39;
  bool has_play_pre_computed_trajectory() const;
  void clear_play_pre_computed_trajectory();
  static const int kPlayPreComputedTrajectoryFieldNumber = 39;
  const ::Kinova::Api::Base::PreComputedJointTrajectory& play_pre_computed_trajectory() const;
  ::Kinova::Api::Base::PreComputedJointTrajectory* release_play_pre_computed_trajectory();
  ::Kinova::Api::Base::PreComputedJointTrajectory* mutable_play_pre_computed_trajectory();
  void set_allocated_play_pre_computed_trajectory(::Kinova::Api::Base::PreComputedJointTrajectory* play_pre_computed_trajectory);

  // .Kinova.Api.Base.SequenceHandle execute_sequence = 40;
  bool has_execute_sequence() const;
  void clear_execute_sequence();
  static const int kExecuteSequenceFieldNumber = 40;
  const ::Kinova::Api::Base::SequenceHandle& execute_sequence() const;
  ::Kinova::Api::Base::SequenceHandle* release_execute_sequence();
  ::Kinova::Api::Base::SequenceHandle* mutable_execute_sequence();
  void set_allocated_execute_sequence(::Kinova::Api::Base::SequenceHandle* execute_sequence);

  // .Kinova.Api.Base.WaypointList execute_waypoint_list = 41;
  bool has_execute_waypoint_list() const;
  void clear_execute_waypoint_list();
  static const int kExecuteWaypointListFieldNumber = 41;
  const ::Kinova::Api::Base::WaypointList& execute_waypoint_list() const;
  ::Kinova::Api::Base::WaypointList* release_execute_waypoint_list();
  ::Kinova::Api::Base::WaypointList* mutable_execute_waypoint_list();
  void set_allocated_execute_waypoint_list(::Kinova::Api::Base::WaypointList* execute_waypoint_list);

  ActionParametersCase action_parameters_case() const;
  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Action)
 private:
  void set_has_send_twist_command();
  void set_has_send_wrench_command();
  void set_has_send_joint_speeds();
  void set_has_reach_pose();
  void set_has_reach_joint_angles();
  void set_has_toggle_admittance_mode();
  void set_has_snapshot();
  void set_has_switch_control_mapping();
  void set_has_navigate_joints();
  void set_has_navigate_mappings();
  void set_has_change_twist();
  void set_has_change_joint_speeds();
  void set_has_change_wrench();
  void set_has_apply_emergency_stop();
  void set_has_clear_faults();
  void set_has_delay();
  void set_has_execute_action();
  void set_has_send_gripper_command();
  void set_has_send_gpio_command();
  void set_has_stop_action();
  void set_has_play_pre_computed_trajectory();
  void set_has_execute_sequence();
  void set_has_execute_waypoint_list();

  inline bool has_action_parameters() const;
  void clear_action_parameters();
  inline void clear_has_action_parameters();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr application_data_;
  ::Kinova::Api::Base::ActionHandle* handle_;
  union ActionParametersUnion {
    ActionParametersUnion() {}
    ::Kinova::Api::Base::TwistCommand* send_twist_command_;
    ::Kinova::Api::Base::WrenchCommand* send_wrench_command_;
    ::Kinova::Api::Base::JointSpeeds* send_joint_speeds_;
    ::Kinova::Api::Base::ConstrainedPose* reach_pose_;
    ::Kinova::Api::Base::ConstrainedJointAngles* reach_joint_angles_;
    int toggle_admittance_mode_;
    ::Kinova::Api::Base::Snapshot* snapshot_;
    ::Kinova::Api::Base::SwitchControlMapping* switch_control_mapping_;
    int navigate_joints_;
    int navigate_mappings_;
    ::Kinova::Api::Base::ChangeTwist* change_twist_;
    ::Kinova::Api::Base::ChangeJointSpeeds* change_joint_speeds_;
    ::Kinova::Api::Base::ChangeWrench* change_wrench_;
    ::Kinova::Api::Base::EmergencyStop* apply_emergency_stop_;
    ::Kinova::Api::Base::Faults* clear_faults_;
    ::Kinova::Api::Base::Delay* delay_;
    ::Kinova::Api::Base::ActionHandle* execute_action_;
    ::Kinova::Api::Base::GripperCommand* send_gripper_command_;
    ::Kinova::Api::Base::GpioCommand* send_gpio_command_;
    ::Kinova::Api::Base::Stop* stop_action_;
    ::Kinova::Api::Base::PreComputedJointTrajectory* play_pre_computed_trajectory_;
    ::Kinova::Api::Base::SequenceHandle* execute_sequence_;
    ::Kinova::Api::Base::WaypointList* execute_waypoint_list_;
  } action_parameters_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsActionImpl();
};
// -------------------------------------------------------------------

class Snapshot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Snapshot) */ {
 public:
  Snapshot();
  virtual ~Snapshot();

  Snapshot(const Snapshot& from);

  inline Snapshot& operator=(const Snapshot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Snapshot(Snapshot&& from) noexcept
    : Snapshot() {
    *this = ::std::move(from);
  }

  inline Snapshot& operator=(Snapshot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Snapshot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Snapshot* internal_default_instance() {
    return reinterpret_cast<const Snapshot*>(
               &_Snapshot_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(Snapshot* other);
  friend void swap(Snapshot& a, Snapshot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Snapshot* New() const PROTOBUF_FINAL { return New(NULL); }

  Snapshot* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Snapshot& from);
  void MergeFrom(const Snapshot& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Snapshot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.SnapshotType snapshot_type = 1;
  void clear_snapshot_type();
  static const int kSnapshotTypeFieldNumber = 1;
  ::Kinova::Api::Base::SnapshotType snapshot_type() const;
  void set_snapshot_type(::Kinova::Api::Base::SnapshotType value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Snapshot)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int snapshot_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSnapshotImpl();
};
// -------------------------------------------------------------------

class SwitchControlMapping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SwitchControlMapping) */ {
 public:
  SwitchControlMapping();
  virtual ~SwitchControlMapping();

  SwitchControlMapping(const SwitchControlMapping& from);

  inline SwitchControlMapping& operator=(const SwitchControlMapping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchControlMapping(SwitchControlMapping&& from) noexcept
    : SwitchControlMapping() {
    *this = ::std::move(from);
  }

  inline SwitchControlMapping& operator=(SwitchControlMapping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SwitchControlMapping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchControlMapping* internal_default_instance() {
    return reinterpret_cast<const SwitchControlMapping*>(
               &_SwitchControlMapping_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(SwitchControlMapping* other);
  friend void swap(SwitchControlMapping& a, SwitchControlMapping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchControlMapping* New() const PROTOBUF_FINAL { return New(NULL); }

  SwitchControlMapping* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SwitchControlMapping& from);
  void MergeFrom(const SwitchControlMapping& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SwitchControlMapping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.MapGroupHandle map_group_handle = 2;
  bool has_map_group_handle() const;
  void clear_map_group_handle();
  static const int kMapGroupHandleFieldNumber = 2;
  const ::Kinova::Api::Base::MapGroupHandle& map_group_handle() const;
  ::Kinova::Api::Base::MapGroupHandle* release_map_group_handle();
  ::Kinova::Api::Base::MapGroupHandle* mutable_map_group_handle();
  void set_allocated_map_group_handle(::Kinova::Api::Base::MapGroupHandle* map_group_handle);

  // .Kinova.Api.Base.MapHandle map_handle = 3;
  bool has_map_handle() const;
  void clear_map_handle();
  static const int kMapHandleFieldNumber = 3;
  const ::Kinova::Api::Base::MapHandle& map_handle() const;
  ::Kinova::Api::Base::MapHandle* release_map_handle();
  ::Kinova::Api::Base::MapHandle* mutable_map_handle();
  void set_allocated_map_handle(::Kinova::Api::Base::MapHandle* map_handle);

  // uint32 controller_identifier = 1;
  void clear_controller_identifier();
  static const int kControllerIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 controller_identifier() const;
  void set_controller_identifier(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SwitchControlMapping)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::MapGroupHandle* map_group_handle_;
  ::Kinova::Api::Base::MapHandle* map_handle_;
  ::google::protobuf::uint32 controller_identifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSwitchControlMappingImpl();
};
// -------------------------------------------------------------------

class ChangeTwist : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ChangeTwist) */ {
 public:
  ChangeTwist();
  virtual ~ChangeTwist();

  ChangeTwist(const ChangeTwist& from);

  inline ChangeTwist& operator=(const ChangeTwist& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeTwist(ChangeTwist&& from) noexcept
    : ChangeTwist() {
    *this = ::std::move(from);
  }

  inline ChangeTwist& operator=(ChangeTwist&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeTwist& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeTwist* internal_default_instance() {
    return reinterpret_cast<const ChangeTwist*>(
               &_ChangeTwist_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(ChangeTwist* other);
  friend void swap(ChangeTwist& a, ChangeTwist& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeTwist* New() const PROTOBUF_FINAL { return New(NULL); }

  ChangeTwist* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChangeTwist& from);
  void MergeFrom(const ChangeTwist& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChangeTwist* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float linear = 1;
  void clear_linear();
  static const int kLinearFieldNumber = 1;
  float linear() const;
  void set_linear(float value);

  // float angular = 2;
  void clear_angular();
  static const int kAngularFieldNumber = 2;
  float angular() const;
  void set_angular(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ChangeTwist)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float linear_;
  float angular_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsChangeTwistImpl();
};
// -------------------------------------------------------------------

class ChangeJointSpeeds : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ChangeJointSpeeds) */ {
 public:
  ChangeJointSpeeds();
  virtual ~ChangeJointSpeeds();

  ChangeJointSpeeds(const ChangeJointSpeeds& from);

  inline ChangeJointSpeeds& operator=(const ChangeJointSpeeds& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeJointSpeeds(ChangeJointSpeeds&& from) noexcept
    : ChangeJointSpeeds() {
    *this = ::std::move(from);
  }

  inline ChangeJointSpeeds& operator=(ChangeJointSpeeds&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeJointSpeeds& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeJointSpeeds* internal_default_instance() {
    return reinterpret_cast<const ChangeJointSpeeds*>(
               &_ChangeJointSpeeds_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(ChangeJointSpeeds* other);
  friend void swap(ChangeJointSpeeds& a, ChangeJointSpeeds& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeJointSpeeds* New() const PROTOBUF_FINAL { return New(NULL); }

  ChangeJointSpeeds* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChangeJointSpeeds& from);
  void MergeFrom(const ChangeJointSpeeds& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChangeJointSpeeds* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.JointSpeeds joint_speeds = 1;
  bool has_joint_speeds() const;
  void clear_joint_speeds();
  static const int kJointSpeedsFieldNumber = 1;
  const ::Kinova::Api::Base::JointSpeeds& joint_speeds() const;
  ::Kinova::Api::Base::JointSpeeds* release_joint_speeds();
  ::Kinova::Api::Base::JointSpeeds* mutable_joint_speeds();
  void set_allocated_joint_speeds(::Kinova::Api::Base::JointSpeeds* joint_speeds);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ChangeJointSpeeds)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::JointSpeeds* joint_speeds_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsChangeJointSpeedsImpl();
};
// -------------------------------------------------------------------

class ChangeWrench : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ChangeWrench) */ {
 public:
  ChangeWrench();
  virtual ~ChangeWrench();

  ChangeWrench(const ChangeWrench& from);

  inline ChangeWrench& operator=(const ChangeWrench& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeWrench(ChangeWrench&& from) noexcept
    : ChangeWrench() {
    *this = ::std::move(from);
  }

  inline ChangeWrench& operator=(ChangeWrench&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeWrench& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeWrench* internal_default_instance() {
    return reinterpret_cast<const ChangeWrench*>(
               &_ChangeWrench_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(ChangeWrench* other);
  friend void swap(ChangeWrench& a, ChangeWrench& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeWrench* New() const PROTOBUF_FINAL { return New(NULL); }

  ChangeWrench* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChangeWrench& from);
  void MergeFrom(const ChangeWrench& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChangeWrench* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float force = 1;
  void clear_force();
  static const int kForceFieldNumber = 1;
  float force() const;
  void set_force(float value);

  // float torque = 2;
  void clear_torque();
  static const int kTorqueFieldNumber = 2;
  float torque() const;
  void set_torque(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ChangeWrench)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float force_;
  float torque_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsChangeWrenchImpl();
};
// -------------------------------------------------------------------

class EmergencyStop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.EmergencyStop) */ {
 public:
  EmergencyStop();
  virtual ~EmergencyStop();

  EmergencyStop(const EmergencyStop& from);

  inline EmergencyStop& operator=(const EmergencyStop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EmergencyStop(EmergencyStop&& from) noexcept
    : EmergencyStop() {
    *this = ::std::move(from);
  }

  inline EmergencyStop& operator=(EmergencyStop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EmergencyStop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmergencyStop* internal_default_instance() {
    return reinterpret_cast<const EmergencyStop*>(
               &_EmergencyStop_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(EmergencyStop* other);
  friend void swap(EmergencyStop& a, EmergencyStop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EmergencyStop* New() const PROTOBUF_FINAL { return New(NULL); }

  EmergencyStop* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmergencyStop& from);
  void MergeFrom(const EmergencyStop& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmergencyStop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.EmergencyStop)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsEmergencyStopImpl();
};
// -------------------------------------------------------------------

class Faults : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Faults) */ {
 public:
  Faults();
  virtual ~Faults();

  Faults(const Faults& from);

  inline Faults& operator=(const Faults& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Faults(Faults&& from) noexcept
    : Faults() {
    *this = ::std::move(from);
  }

  inline Faults& operator=(Faults&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Faults& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Faults* internal_default_instance() {
    return reinterpret_cast<const Faults*>(
               &_Faults_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(Faults* other);
  friend void swap(Faults& a, Faults& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Faults* New() const PROTOBUF_FINAL { return New(NULL); }

  Faults* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Faults& from);
  void MergeFrom(const Faults& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Faults* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Faults)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsFaultsImpl();
};
// -------------------------------------------------------------------

class Delay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Delay) */ {
 public:
  Delay();
  virtual ~Delay();

  Delay(const Delay& from);

  inline Delay& operator=(const Delay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Delay(Delay&& from) noexcept
    : Delay() {
    *this = ::std::move(from);
  }

  inline Delay& operator=(Delay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Delay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Delay* internal_default_instance() {
    return reinterpret_cast<const Delay*>(
               &_Delay_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(Delay* other);
  friend void swap(Delay& a, Delay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Delay* New() const PROTOBUF_FINAL { return New(NULL); }

  Delay* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Delay& from);
  void MergeFrom(const Delay& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Delay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 duration = 1;
  void clear_duration();
  static const int kDurationFieldNumber = 1;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Delay)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsDelayImpl();
};
// -------------------------------------------------------------------

class Stop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Stop) */ {
 public:
  Stop();
  virtual ~Stop();

  Stop(const Stop& from);

  inline Stop& operator=(const Stop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Stop(Stop&& from) noexcept
    : Stop() {
    *this = ::std::move(from);
  }

  inline Stop& operator=(Stop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Stop* internal_default_instance() {
    return reinterpret_cast<const Stop*>(
               &_Stop_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(Stop* other);
  friend void swap(Stop& a, Stop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Stop* New() const PROTOBUF_FINAL { return New(NULL); }

  Stop* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Stop& from);
  void MergeFrom(const Stop& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Stop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Stop)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsStopImpl();
};
// -------------------------------------------------------------------

class ActionList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ActionList) */ {
 public:
  ActionList();
  virtual ~ActionList();

  ActionList(const ActionList& from);

  inline ActionList& operator=(const ActionList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionList(ActionList&& from) noexcept
    : ActionList() {
    *this = ::std::move(from);
  }

  inline ActionList& operator=(ActionList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionList* internal_default_instance() {
    return reinterpret_cast<const ActionList*>(
               &_ActionList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(ActionList* other);
  friend void swap(ActionList& a, ActionList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionList* New() const PROTOBUF_FINAL { return New(NULL); }

  ActionList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ActionList& from);
  void MergeFrom(const ActionList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ActionList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.Action action_list = 1;
  int action_list_size() const;
  void clear_action_list();
  static const int kActionListFieldNumber = 1;
  const ::Kinova::Api::Base::Action& action_list(int index) const;
  ::Kinova::Api::Base::Action* mutable_action_list(int index);
  ::Kinova::Api::Base::Action* add_action_list();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Action >*
      mutable_action_list();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Action >&
      action_list() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ActionList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Action > action_list_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsActionListImpl();
};
// -------------------------------------------------------------------

class Timeout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Timeout) */ {
 public:
  Timeout();
  virtual ~Timeout();

  Timeout(const Timeout& from);

  inline Timeout& operator=(const Timeout& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Timeout(Timeout&& from) noexcept
    : Timeout() {
    *this = ::std::move(from);
  }

  inline Timeout& operator=(Timeout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Timeout& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Timeout* internal_default_instance() {
    return reinterpret_cast<const Timeout*>(
               &_Timeout_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(Timeout* other);
  friend void swap(Timeout& a, Timeout& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Timeout* New() const PROTOBUF_FINAL { return New(NULL); }

  Timeout* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Timeout& from);
  void MergeFrom(const Timeout& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Timeout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Timeout)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 value_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsTimeoutImpl();
};
// -------------------------------------------------------------------

class Ssid : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Ssid) */ {
 public:
  Ssid();
  virtual ~Ssid();

  Ssid(const Ssid& from);

  inline Ssid& operator=(const Ssid& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ssid(Ssid&& from) noexcept
    : Ssid() {
    *this = ::std::move(from);
  }

  inline Ssid& operator=(Ssid&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ssid& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ssid* internal_default_instance() {
    return reinterpret_cast<const Ssid*>(
               &_Ssid_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(Ssid* other);
  friend void swap(Ssid& a, Ssid& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ssid* New() const PROTOBUF_FINAL { return New(NULL); }

  Ssid* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ssid& from);
  void MergeFrom(const Ssid& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ssid* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  const ::std::string& identifier() const;
  void set_identifier(const ::std::string& value);
  #if LANG_CXX11
  void set_identifier(::std::string&& value);
  #endif
  void set_identifier(const char* value);
  void set_identifier(const char* value, size_t size);
  ::std::string* mutable_identifier();
  ::std::string* release_identifier();
  void set_allocated_identifier(::std::string* identifier);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Ssid)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr identifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSsidImpl();
};
// -------------------------------------------------------------------

class CommunicationInterfaceConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.CommunicationInterfaceConfiguration) */ {
 public:
  CommunicationInterfaceConfiguration();
  virtual ~CommunicationInterfaceConfiguration();

  CommunicationInterfaceConfiguration(const CommunicationInterfaceConfiguration& from);

  inline CommunicationInterfaceConfiguration& operator=(const CommunicationInterfaceConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommunicationInterfaceConfiguration(CommunicationInterfaceConfiguration&& from) noexcept
    : CommunicationInterfaceConfiguration() {
    *this = ::std::move(from);
  }

  inline CommunicationInterfaceConfiguration& operator=(CommunicationInterfaceConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommunicationInterfaceConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommunicationInterfaceConfiguration* internal_default_instance() {
    return reinterpret_cast<const CommunicationInterfaceConfiguration*>(
               &_CommunicationInterfaceConfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(CommunicationInterfaceConfiguration* other);
  friend void swap(CommunicationInterfaceConfiguration& a, CommunicationInterfaceConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommunicationInterfaceConfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  CommunicationInterfaceConfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CommunicationInterfaceConfiguration& from);
  void MergeFrom(const CommunicationInterfaceConfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CommunicationInterfaceConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.NetworkType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Kinova::Api::Base::NetworkType type() const;
  void set_type(::Kinova::Api::Base::NetworkType value);

  // bool enable = 2;
  void clear_enable();
  static const int kEnableFieldNumber = 2;
  bool enable() const;
  void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.CommunicationInterfaceConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int type_;
  bool enable_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsCommunicationInterfaceConfigurationImpl();
};
// -------------------------------------------------------------------

class NetworkHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.NetworkHandle) */ {
 public:
  NetworkHandle();
  virtual ~NetworkHandle();

  NetworkHandle(const NetworkHandle& from);

  inline NetworkHandle& operator=(const NetworkHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkHandle(NetworkHandle&& from) noexcept
    : NetworkHandle() {
    *this = ::std::move(from);
  }

  inline NetworkHandle& operator=(NetworkHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkHandle* internal_default_instance() {
    return reinterpret_cast<const NetworkHandle*>(
               &_NetworkHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(NetworkHandle* other);
  friend void swap(NetworkHandle& a, NetworkHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetworkHandle& from);
  void MergeFrom(const NetworkHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetworkHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.NetworkType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Kinova::Api::Base::NetworkType type() const;
  void set_type(::Kinova::Api::Base::NetworkType value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.NetworkHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsNetworkHandleImpl();
};
// -------------------------------------------------------------------

class IPv4Configuration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.IPv4Configuration) */ {
 public:
  IPv4Configuration();
  virtual ~IPv4Configuration();

  IPv4Configuration(const IPv4Configuration& from);

  inline IPv4Configuration& operator=(const IPv4Configuration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IPv4Configuration(IPv4Configuration&& from) noexcept
    : IPv4Configuration() {
    *this = ::std::move(from);
  }

  inline IPv4Configuration& operator=(IPv4Configuration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IPv4Configuration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IPv4Configuration* internal_default_instance() {
    return reinterpret_cast<const IPv4Configuration*>(
               &_IPv4Configuration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(IPv4Configuration* other);
  friend void swap(IPv4Configuration& a, IPv4Configuration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IPv4Configuration* New() const PROTOBUF_FINAL { return New(NULL); }

  IPv4Configuration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IPv4Configuration& from);
  void MergeFrom(const IPv4Configuration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IPv4Configuration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ip_address = 1;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 1;
  ::google::protobuf::uint32 ip_address() const;
  void set_ip_address(::google::protobuf::uint32 value);

  // uint32 subnet_mask = 2;
  void clear_subnet_mask();
  static const int kSubnetMaskFieldNumber = 2;
  ::google::protobuf::uint32 subnet_mask() const;
  void set_subnet_mask(::google::protobuf::uint32 value);

  // uint32 default_gateway = 3;
  void clear_default_gateway();
  static const int kDefaultGatewayFieldNumber = 3;
  ::google::protobuf::uint32 default_gateway() const;
  void set_default_gateway(::google::protobuf::uint32 value);

  // bool dhcp_enabled = 4;
  void clear_dhcp_enabled();
  static const int kDhcpEnabledFieldNumber = 4;
  bool dhcp_enabled() const;
  void set_dhcp_enabled(bool value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.IPv4Configuration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 ip_address_;
  ::google::protobuf::uint32 subnet_mask_;
  ::google::protobuf::uint32 default_gateway_;
  bool dhcp_enabled_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsIPv4ConfigurationImpl();
};
// -------------------------------------------------------------------

class IPv4Information : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.IPv4Information) */ {
 public:
  IPv4Information();
  virtual ~IPv4Information();

  IPv4Information(const IPv4Information& from);

  inline IPv4Information& operator=(const IPv4Information& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IPv4Information(IPv4Information&& from) noexcept
    : IPv4Information() {
    *this = ::std::move(from);
  }

  inline IPv4Information& operator=(IPv4Information&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IPv4Information& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IPv4Information* internal_default_instance() {
    return reinterpret_cast<const IPv4Information*>(
               &_IPv4Information_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(IPv4Information* other);
  friend void swap(IPv4Information& a, IPv4Information& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IPv4Information* New() const PROTOBUF_FINAL { return New(NULL); }

  IPv4Information* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IPv4Information& from);
  void MergeFrom(const IPv4Information& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IPv4Information* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ip_address = 1;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 1;
  ::google::protobuf::uint32 ip_address() const;
  void set_ip_address(::google::protobuf::uint32 value);

  // uint32 subnet_mask = 2;
  void clear_subnet_mask();
  static const int kSubnetMaskFieldNumber = 2;
  ::google::protobuf::uint32 subnet_mask() const;
  void set_subnet_mask(::google::protobuf::uint32 value);

  // uint32 default_gateway = 3;
  void clear_default_gateway();
  static const int kDefaultGatewayFieldNumber = 3;
  ::google::protobuf::uint32 default_gateway() const;
  void set_default_gateway(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.IPv4Information)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 ip_address_;
  ::google::protobuf::uint32 subnet_mask_;
  ::google::protobuf::uint32 default_gateway_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsIPv4InformationImpl();
};
// -------------------------------------------------------------------

class FullIPv4Configuration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.FullIPv4Configuration) */ {
 public:
  FullIPv4Configuration();
  virtual ~FullIPv4Configuration();

  FullIPv4Configuration(const FullIPv4Configuration& from);

  inline FullIPv4Configuration& operator=(const FullIPv4Configuration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FullIPv4Configuration(FullIPv4Configuration&& from) noexcept
    : FullIPv4Configuration() {
    *this = ::std::move(from);
  }

  inline FullIPv4Configuration& operator=(FullIPv4Configuration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FullIPv4Configuration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FullIPv4Configuration* internal_default_instance() {
    return reinterpret_cast<const FullIPv4Configuration*>(
               &_FullIPv4Configuration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(FullIPv4Configuration* other);
  friend void swap(FullIPv4Configuration& a, FullIPv4Configuration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FullIPv4Configuration* New() const PROTOBUF_FINAL { return New(NULL); }

  FullIPv4Configuration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FullIPv4Configuration& from);
  void MergeFrom(const FullIPv4Configuration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FullIPv4Configuration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.NetworkHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Base::NetworkHandle& handle() const;
  ::Kinova::Api::Base::NetworkHandle* release_handle();
  ::Kinova::Api::Base::NetworkHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Base::NetworkHandle* handle);

  // .Kinova.Api.Base.IPv4Configuration ipv4_configuration = 2;
  bool has_ipv4_configuration() const;
  void clear_ipv4_configuration();
  static const int kIpv4ConfigurationFieldNumber = 2;
  const ::Kinova::Api::Base::IPv4Configuration& ipv4_configuration() const;
  ::Kinova::Api::Base::IPv4Configuration* release_ipv4_configuration();
  ::Kinova::Api::Base::IPv4Configuration* mutable_ipv4_configuration();
  void set_allocated_ipv4_configuration(::Kinova::Api::Base::IPv4Configuration* ipv4_configuration);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.FullIPv4Configuration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::NetworkHandle* handle_;
  ::Kinova::Api::Base::IPv4Configuration* ipv4_configuration_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsFullIPv4ConfigurationImpl();
};
// -------------------------------------------------------------------

class WifiInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.WifiInformation) */ {
 public:
  WifiInformation();
  virtual ~WifiInformation();

  WifiInformation(const WifiInformation& from);

  inline WifiInformation& operator=(const WifiInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WifiInformation(WifiInformation&& from) noexcept
    : WifiInformation() {
    *this = ::std::move(from);
  }

  inline WifiInformation& operator=(WifiInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WifiInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WifiInformation* internal_default_instance() {
    return reinterpret_cast<const WifiInformation*>(
               &_WifiInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(WifiInformation* other);
  friend void swap(WifiInformation& a, WifiInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WifiInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  WifiInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WifiInformation& from);
  void MergeFrom(const WifiInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WifiInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.Ssid ssid = 1;
  bool has_ssid() const;
  void clear_ssid();
  static const int kSsidFieldNumber = 1;
  const ::Kinova::Api::Base::Ssid& ssid() const;
  ::Kinova::Api::Base::Ssid* release_ssid();
  ::Kinova::Api::Base::Ssid* mutable_ssid();
  void set_allocated_ssid(::Kinova::Api::Base::Ssid* ssid);

  // fixed32 security_type = 2;
  void clear_security_type();
  static const int kSecurityTypeFieldNumber = 2;
  ::google::protobuf::uint32 security_type() const;
  void set_security_type(::google::protobuf::uint32 value);

  // fixed32 encryption_type = 3;
  void clear_encryption_type();
  static const int kEncryptionTypeFieldNumber = 3;
  ::google::protobuf::uint32 encryption_type() const;
  void set_encryption_type(::google::protobuf::uint32 value);

  // .Kinova.Api.Base.SignalQuality signal_quality = 4;
  void clear_signal_quality();
  static const int kSignalQualityFieldNumber = 4;
  ::Kinova::Api::Base::SignalQuality signal_quality() const;
  void set_signal_quality(::Kinova::Api::Base::SignalQuality value);

  // int32 signal_strength = 5;
  void clear_signal_strength();
  static const int kSignalStrengthFieldNumber = 5;
  ::google::protobuf::int32 signal_strength() const;
  void set_signal_strength(::google::protobuf::int32 value);

  // uint32 frequency = 6;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 6;
  ::google::protobuf::uint32 frequency() const;
  void set_frequency(::google::protobuf::uint32 value);

  // uint32 channel = 7;
  void clear_channel();
  static const int kChannelFieldNumber = 7;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.WifiInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::Ssid* ssid_;
  ::google::protobuf::uint32 security_type_;
  ::google::protobuf::uint32 encryption_type_;
  int signal_quality_;
  ::google::protobuf::int32 signal_strength_;
  ::google::protobuf::uint32 frequency_;
  ::google::protobuf::uint32 channel_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsWifiInformationImpl();
};
// -------------------------------------------------------------------

class WifiInformationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.WifiInformationList) */ {
 public:
  WifiInformationList();
  virtual ~WifiInformationList();

  WifiInformationList(const WifiInformationList& from);

  inline WifiInformationList& operator=(const WifiInformationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WifiInformationList(WifiInformationList&& from) noexcept
    : WifiInformationList() {
    *this = ::std::move(from);
  }

  inline WifiInformationList& operator=(WifiInformationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WifiInformationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WifiInformationList* internal_default_instance() {
    return reinterpret_cast<const WifiInformationList*>(
               &_WifiInformationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(WifiInformationList* other);
  friend void swap(WifiInformationList& a, WifiInformationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WifiInformationList* New() const PROTOBUF_FINAL { return New(NULL); }

  WifiInformationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WifiInformationList& from);
  void MergeFrom(const WifiInformationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WifiInformationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.WifiInformation wifi_information_list = 1;
  int wifi_information_list_size() const;
  void clear_wifi_information_list();
  static const int kWifiInformationListFieldNumber = 1;
  const ::Kinova::Api::Base::WifiInformation& wifi_information_list(int index) const;
  ::Kinova::Api::Base::WifiInformation* mutable_wifi_information_list(int index);
  ::Kinova::Api::Base::WifiInformation* add_wifi_information_list();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::WifiInformation >*
      mutable_wifi_information_list();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::WifiInformation >&
      wifi_information_list() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.WifiInformationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::WifiInformation > wifi_information_list_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsWifiInformationListImpl();
};
// -------------------------------------------------------------------

class WifiConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.WifiConfiguration) */ {
 public:
  WifiConfiguration();
  virtual ~WifiConfiguration();

  WifiConfiguration(const WifiConfiguration& from);

  inline WifiConfiguration& operator=(const WifiConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WifiConfiguration(WifiConfiguration&& from) noexcept
    : WifiConfiguration() {
    *this = ::std::move(from);
  }

  inline WifiConfiguration& operator=(WifiConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WifiConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WifiConfiguration* internal_default_instance() {
    return reinterpret_cast<const WifiConfiguration*>(
               &_WifiConfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(WifiConfiguration* other);
  friend void swap(WifiConfiguration& a, WifiConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WifiConfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  WifiConfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WifiConfiguration& from);
  void MergeFrom(const WifiConfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WifiConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string security_key = 2;
  void clear_security_key();
  static const int kSecurityKeyFieldNumber = 2;
  const ::std::string& security_key() const;
  void set_security_key(const ::std::string& value);
  #if LANG_CXX11
  void set_security_key(::std::string&& value);
  #endif
  void set_security_key(const char* value);
  void set_security_key(const char* value, size_t size);
  ::std::string* mutable_security_key();
  ::std::string* release_security_key();
  void set_allocated_security_key(::std::string* security_key);

  // .Kinova.Api.Base.Ssid ssid = 1;
  bool has_ssid() const;
  void clear_ssid();
  static const int kSsidFieldNumber = 1;
  const ::Kinova::Api::Base::Ssid& ssid() const;
  ::Kinova::Api::Base::Ssid* release_ssid();
  ::Kinova::Api::Base::Ssid* mutable_ssid();
  void set_allocated_ssid(::Kinova::Api::Base::Ssid* ssid);

  // bool connect_automatically = 3;
  void clear_connect_automatically();
  static const int kConnectAutomaticallyFieldNumber = 3;
  bool connect_automatically() const;
  void set_connect_automatically(bool value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.WifiConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr security_key_;
  ::Kinova::Api::Base::Ssid* ssid_;
  bool connect_automatically_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsWifiConfigurationImpl();
};
// -------------------------------------------------------------------

class WifiConfigurationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.WifiConfigurationList) */ {
 public:
  WifiConfigurationList();
  virtual ~WifiConfigurationList();

  WifiConfigurationList(const WifiConfigurationList& from);

  inline WifiConfigurationList& operator=(const WifiConfigurationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WifiConfigurationList(WifiConfigurationList&& from) noexcept
    : WifiConfigurationList() {
    *this = ::std::move(from);
  }

  inline WifiConfigurationList& operator=(WifiConfigurationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WifiConfigurationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WifiConfigurationList* internal_default_instance() {
    return reinterpret_cast<const WifiConfigurationList*>(
               &_WifiConfigurationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(WifiConfigurationList* other);
  friend void swap(WifiConfigurationList& a, WifiConfigurationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WifiConfigurationList* New() const PROTOBUF_FINAL { return New(NULL); }

  WifiConfigurationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WifiConfigurationList& from);
  void MergeFrom(const WifiConfigurationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WifiConfigurationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.WifiConfiguration wifi_configuration_list = 1;
  int wifi_configuration_list_size() const;
  void clear_wifi_configuration_list();
  static const int kWifiConfigurationListFieldNumber = 1;
  const ::Kinova::Api::Base::WifiConfiguration& wifi_configuration_list(int index) const;
  ::Kinova::Api::Base::WifiConfiguration* mutable_wifi_configuration_list(int index);
  ::Kinova::Api::Base::WifiConfiguration* add_wifi_configuration_list();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::WifiConfiguration >*
      mutable_wifi_configuration_list();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::WifiConfiguration >&
      wifi_configuration_list() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.WifiConfigurationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::WifiConfiguration > wifi_configuration_list_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsWifiConfigurationListImpl();
};
// -------------------------------------------------------------------

class ProtectionZoneHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ProtectionZoneHandle) */ {
 public:
  ProtectionZoneHandle();
  virtual ~ProtectionZoneHandle();

  ProtectionZoneHandle(const ProtectionZoneHandle& from);

  inline ProtectionZoneHandle& operator=(const ProtectionZoneHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtectionZoneHandle(ProtectionZoneHandle&& from) noexcept
    : ProtectionZoneHandle() {
    *this = ::std::move(from);
  }

  inline ProtectionZoneHandle& operator=(ProtectionZoneHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtectionZoneHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtectionZoneHandle* internal_default_instance() {
    return reinterpret_cast<const ProtectionZoneHandle*>(
               &_ProtectionZoneHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(ProtectionZoneHandle* other);
  friend void swap(ProtectionZoneHandle& a, ProtectionZoneHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtectionZoneHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtectionZoneHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtectionZoneHandle& from);
  void MergeFrom(const ProtectionZoneHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtectionZoneHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 identifier() const;
  void set_identifier(::google::protobuf::uint32 value);

  // fixed32 permission = 2;
  void clear_permission();
  static const int kPermissionFieldNumber = 2;
  ::google::protobuf::uint32 permission() const;
  void set_permission(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ProtectionZoneHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 identifier_;
  ::google::protobuf::uint32 permission_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsProtectionZoneHandleImpl();
};
// -------------------------------------------------------------------

class RotationMatrixRow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.RotationMatrixRow) */ {
 public:
  RotationMatrixRow();
  virtual ~RotationMatrixRow();

  RotationMatrixRow(const RotationMatrixRow& from);

  inline RotationMatrixRow& operator=(const RotationMatrixRow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RotationMatrixRow(RotationMatrixRow&& from) noexcept
    : RotationMatrixRow() {
    *this = ::std::move(from);
  }

  inline RotationMatrixRow& operator=(RotationMatrixRow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RotationMatrixRow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RotationMatrixRow* internal_default_instance() {
    return reinterpret_cast<const RotationMatrixRow*>(
               &_RotationMatrixRow_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(RotationMatrixRow* other);
  friend void swap(RotationMatrixRow& a, RotationMatrixRow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RotationMatrixRow* New() const PROTOBUF_FINAL { return New(NULL); }

  RotationMatrixRow* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RotationMatrixRow& from);
  void MergeFrom(const RotationMatrixRow& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RotationMatrixRow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float column1 = 1;
  void clear_column1();
  static const int kColumn1FieldNumber = 1;
  float column1() const;
  void set_column1(float value);

  // float column2 = 2;
  void clear_column2();
  static const int kColumn2FieldNumber = 2;
  float column2() const;
  void set_column2(float value);

  // float column3 = 3;
  void clear_column3();
  static const int kColumn3FieldNumber = 3;
  float column3() const;
  void set_column3(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.RotationMatrixRow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float column1_;
  float column2_;
  float column3_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsRotationMatrixRowImpl();
};
// -------------------------------------------------------------------

class RotationMatrix : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.RotationMatrix) */ {
 public:
  RotationMatrix();
  virtual ~RotationMatrix();

  RotationMatrix(const RotationMatrix& from);

  inline RotationMatrix& operator=(const RotationMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RotationMatrix(RotationMatrix&& from) noexcept
    : RotationMatrix() {
    *this = ::std::move(from);
  }

  inline RotationMatrix& operator=(RotationMatrix&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RotationMatrix& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RotationMatrix* internal_default_instance() {
    return reinterpret_cast<const RotationMatrix*>(
               &_RotationMatrix_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(RotationMatrix* other);
  friend void swap(RotationMatrix& a, RotationMatrix& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RotationMatrix* New() const PROTOBUF_FINAL { return New(NULL); }

  RotationMatrix* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RotationMatrix& from);
  void MergeFrom(const RotationMatrix& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RotationMatrix* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.RotationMatrixRow row1 = 1;
  bool has_row1() const;
  void clear_row1();
  static const int kRow1FieldNumber = 1;
  const ::Kinova::Api::Base::RotationMatrixRow& row1() const;
  ::Kinova::Api::Base::RotationMatrixRow* release_row1();
  ::Kinova::Api::Base::RotationMatrixRow* mutable_row1();
  void set_allocated_row1(::Kinova::Api::Base::RotationMatrixRow* row1);

  // .Kinova.Api.Base.RotationMatrixRow row2 = 2;
  bool has_row2() const;
  void clear_row2();
  static const int kRow2FieldNumber = 2;
  const ::Kinova::Api::Base::RotationMatrixRow& row2() const;
  ::Kinova::Api::Base::RotationMatrixRow* release_row2();
  ::Kinova::Api::Base::RotationMatrixRow* mutable_row2();
  void set_allocated_row2(::Kinova::Api::Base::RotationMatrixRow* row2);

  // .Kinova.Api.Base.RotationMatrixRow row3 = 3;
  bool has_row3() const;
  void clear_row3();
  static const int kRow3FieldNumber = 3;
  const ::Kinova::Api::Base::RotationMatrixRow& row3() const;
  ::Kinova::Api::Base::RotationMatrixRow* release_row3();
  ::Kinova::Api::Base::RotationMatrixRow* mutable_row3();
  void set_allocated_row3(::Kinova::Api::Base::RotationMatrixRow* row3);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.RotationMatrix)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::RotationMatrixRow* row1_;
  ::Kinova::Api::Base::RotationMatrixRow* row2_;
  ::Kinova::Api::Base::RotationMatrixRow* row3_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsRotationMatrixImpl();
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const PROTOBUF_FINAL { return New(NULL); }

  Point* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Point)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsPointImpl();
};
// -------------------------------------------------------------------

class ZoneShape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ZoneShape) */ {
 public:
  ZoneShape();
  virtual ~ZoneShape();

  ZoneShape(const ZoneShape& from);

  inline ZoneShape& operator=(const ZoneShape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ZoneShape(ZoneShape&& from) noexcept
    : ZoneShape() {
    *this = ::std::move(from);
  }

  inline ZoneShape& operator=(ZoneShape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ZoneShape& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ZoneShape* internal_default_instance() {
    return reinterpret_cast<const ZoneShape*>(
               &_ZoneShape_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(ZoneShape* other);
  friend void swap(ZoneShape& a, ZoneShape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ZoneShape* New() const PROTOBUF_FINAL { return New(NULL); }

  ZoneShape* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ZoneShape& from);
  void MergeFrom(const ZoneShape& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ZoneShape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float dimensions = 4;
  int dimensions_size() const;
  void clear_dimensions();
  static const int kDimensionsFieldNumber = 4;
  float dimensions(int index) const;
  void set_dimensions(int index, float value);
  void add_dimensions(float value);
  const ::google::protobuf::RepeatedField< float >&
      dimensions() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_dimensions();

  // .Kinova.Api.Base.Point origin = 2;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 2;
  const ::Kinova::Api::Base::Point& origin() const;
  ::Kinova::Api::Base::Point* release_origin();
  ::Kinova::Api::Base::Point* mutable_origin();
  void set_allocated_origin(::Kinova::Api::Base::Point* origin);

  // .Kinova.Api.Base.RotationMatrix orientation = 3;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 3;
  const ::Kinova::Api::Base::RotationMatrix& orientation() const;
  ::Kinova::Api::Base::RotationMatrix* release_orientation();
  ::Kinova::Api::Base::RotationMatrix* mutable_orientation();
  void set_allocated_orientation(::Kinova::Api::Base::RotationMatrix* orientation);

  // .Kinova.Api.Base.ShapeType shape_type = 1;
  void clear_shape_type();
  static const int kShapeTypeFieldNumber = 1;
  ::Kinova::Api::Base::ShapeType shape_type() const;
  void set_shape_type(::Kinova::Api::Base::ShapeType value);

  // float envelope_thickness = 5;
  void clear_envelope_thickness();
  static const int kEnvelopeThicknessFieldNumber = 5;
  float envelope_thickness() const;
  void set_envelope_thickness(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ZoneShape)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > dimensions_;
  mutable int _dimensions_cached_byte_size_;
  ::Kinova::Api::Base::Point* origin_;
  ::Kinova::Api::Base::RotationMatrix* orientation_;
  int shape_type_;
  float envelope_thickness_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsZoneShapeImpl();
};
// -------------------------------------------------------------------

class ProtectionZone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ProtectionZone) */ {
 public:
  ProtectionZone();
  virtual ~ProtectionZone();

  ProtectionZone(const ProtectionZone& from);

  inline ProtectionZone& operator=(const ProtectionZone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtectionZone(ProtectionZone&& from) noexcept
    : ProtectionZone() {
    *this = ::std::move(from);
  }

  inline ProtectionZone& operator=(ProtectionZone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtectionZone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtectionZone* internal_default_instance() {
    return reinterpret_cast<const ProtectionZone*>(
               &_ProtectionZone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(ProtectionZone* other);
  friend void swap(ProtectionZone& a, ProtectionZone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtectionZone* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtectionZone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtectionZone& from);
  void MergeFrom(const ProtectionZone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtectionZone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.CartesianLimitation limitations = 6;
  int limitations_size() const;
  void clear_limitations();
  static const int kLimitationsFieldNumber = 6;
  const ::Kinova::Api::Base::CartesianLimitation& limitations(int index) const;
  ::Kinova::Api::Base::CartesianLimitation* mutable_limitations(int index);
  ::Kinova::Api::Base::CartesianLimitation* add_limitations();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation >*
      mutable_limitations();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation >&
      limitations() const;

  // repeated .Kinova.Api.Base.CartesianLimitation envelope_limitations = 7;
  int envelope_limitations_size() const;
  void clear_envelope_limitations();
  static const int kEnvelopeLimitationsFieldNumber = 7;
  const ::Kinova::Api::Base::CartesianLimitation& envelope_limitations(int index) const;
  ::Kinova::Api::Base::CartesianLimitation* mutable_envelope_limitations(int index);
  ::Kinova::Api::Base::CartesianLimitation* add_envelope_limitations();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation >*
      mutable_envelope_limitations();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation >&
      envelope_limitations() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string application_data = 3;
  void clear_application_data();
  static const int kApplicationDataFieldNumber = 3;
  const ::std::string& application_data() const;
  void set_application_data(const ::std::string& value);
  #if LANG_CXX11
  void set_application_data(::std::string&& value);
  #endif
  void set_application_data(const char* value);
  void set_application_data(const char* value, size_t size);
  ::std::string* mutable_application_data();
  ::std::string* release_application_data();
  void set_allocated_application_data(::std::string* application_data);

  // .Kinova.Api.Base.ProtectionZoneHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Base::ProtectionZoneHandle& handle() const;
  ::Kinova::Api::Base::ProtectionZoneHandle* release_handle();
  ::Kinova::Api::Base::ProtectionZoneHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Base::ProtectionZoneHandle* handle);

  // .Kinova.Api.Base.ZoneShape shape = 5;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 5;
  const ::Kinova::Api::Base::ZoneShape& shape() const;
  ::Kinova::Api::Base::ZoneShape* release_shape();
  ::Kinova::Api::Base::ZoneShape* mutable_shape();
  void set_allocated_shape(::Kinova::Api::Base::ZoneShape* shape);

  // bool is_enabled = 4;
  void clear_is_enabled();
  static const int kIsEnabledFieldNumber = 4;
  bool is_enabled() const;
  void set_is_enabled(bool value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ProtectionZone)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation > limitations_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation > envelope_limitations_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr application_data_;
  ::Kinova::Api::Base::ProtectionZoneHandle* handle_;
  ::Kinova::Api::Base::ZoneShape* shape_;
  bool is_enabled_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsProtectionZoneImpl();
};
// -------------------------------------------------------------------

class ProtectionZoneList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ProtectionZoneList) */ {
 public:
  ProtectionZoneList();
  virtual ~ProtectionZoneList();

  ProtectionZoneList(const ProtectionZoneList& from);

  inline ProtectionZoneList& operator=(const ProtectionZoneList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtectionZoneList(ProtectionZoneList&& from) noexcept
    : ProtectionZoneList() {
    *this = ::std::move(from);
  }

  inline ProtectionZoneList& operator=(ProtectionZoneList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtectionZoneList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtectionZoneList* internal_default_instance() {
    return reinterpret_cast<const ProtectionZoneList*>(
               &_ProtectionZoneList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(ProtectionZoneList* other);
  friend void swap(ProtectionZoneList& a, ProtectionZoneList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtectionZoneList* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtectionZoneList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtectionZoneList& from);
  void MergeFrom(const ProtectionZoneList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtectionZoneList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.ProtectionZone protection_zones = 1;
  int protection_zones_size() const;
  void clear_protection_zones();
  static const int kProtectionZonesFieldNumber = 1;
  const ::Kinova::Api::Base::ProtectionZone& protection_zones(int index) const;
  ::Kinova::Api::Base::ProtectionZone* mutable_protection_zones(int index);
  ::Kinova::Api::Base::ProtectionZone* add_protection_zones();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ProtectionZone >*
      mutable_protection_zones();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ProtectionZone >&
      protection_zones() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ProtectionZoneList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ProtectionZone > protection_zones_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsProtectionZoneListImpl();
};
// -------------------------------------------------------------------

class CartesianLimitation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.CartesianLimitation) */ {
 public:
  CartesianLimitation();
  virtual ~CartesianLimitation();

  CartesianLimitation(const CartesianLimitation& from);

  inline CartesianLimitation& operator=(const CartesianLimitation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianLimitation(CartesianLimitation&& from) noexcept
    : CartesianLimitation() {
    *this = ::std::move(from);
  }

  inline CartesianLimitation& operator=(CartesianLimitation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianLimitation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianLimitation* internal_default_instance() {
    return reinterpret_cast<const CartesianLimitation*>(
               &_CartesianLimitation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(CartesianLimitation* other);
  friend void swap(CartesianLimitation& a, CartesianLimitation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianLimitation* New() const PROTOBUF_FINAL { return New(NULL); }

  CartesianLimitation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CartesianLimitation& from);
  void MergeFrom(const CartesianLimitation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CartesianLimitation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.LimitationType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Kinova::Api::Base::LimitationType type() const;
  void set_type(::Kinova::Api::Base::LimitationType value);

  // float translation = 2;
  void clear_translation();
  static const int kTranslationFieldNumber = 2;
  float translation() const;
  void set_translation(float value);

  // float orientation = 3;
  void clear_orientation();
  static const int kOrientationFieldNumber = 3;
  float orientation() const;
  void set_orientation(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.CartesianLimitation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int type_;
  float translation_;
  float orientation_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsCartesianLimitationImpl();
};
// -------------------------------------------------------------------

class TwistLimitation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.TwistLimitation) */ {
 public:
  TwistLimitation();
  virtual ~TwistLimitation();

  TwistLimitation(const TwistLimitation& from);

  inline TwistLimitation& operator=(const TwistLimitation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TwistLimitation(TwistLimitation&& from) noexcept
    : TwistLimitation() {
    *this = ::std::move(from);
  }

  inline TwistLimitation& operator=(TwistLimitation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TwistLimitation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TwistLimitation* internal_default_instance() {
    return reinterpret_cast<const TwistLimitation*>(
               &_TwistLimitation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(TwistLimitation* other);
  friend void swap(TwistLimitation& a, TwistLimitation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TwistLimitation* New() const PROTOBUF_FINAL { return New(NULL); }

  TwistLimitation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TwistLimitation& from);
  void MergeFrom(const TwistLimitation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TwistLimitation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float linear = 1;
  void clear_linear();
  static const int kLinearFieldNumber = 1;
  float linear() const;
  void set_linear(float value);

  // float angular = 2;
  void clear_angular();
  static const int kAngularFieldNumber = 2;
  float angular() const;
  void set_angular(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.TwistLimitation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float linear_;
  float angular_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsTwistLimitationImpl();
};
// -------------------------------------------------------------------

class WrenchLimitation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.WrenchLimitation) */ {
 public:
  WrenchLimitation();
  virtual ~WrenchLimitation();

  WrenchLimitation(const WrenchLimitation& from);

  inline WrenchLimitation& operator=(const WrenchLimitation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WrenchLimitation(WrenchLimitation&& from) noexcept
    : WrenchLimitation() {
    *this = ::std::move(from);
  }

  inline WrenchLimitation& operator=(WrenchLimitation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WrenchLimitation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WrenchLimitation* internal_default_instance() {
    return reinterpret_cast<const WrenchLimitation*>(
               &_WrenchLimitation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(WrenchLimitation* other);
  friend void swap(WrenchLimitation& a, WrenchLimitation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WrenchLimitation* New() const PROTOBUF_FINAL { return New(NULL); }

  WrenchLimitation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WrenchLimitation& from);
  void MergeFrom(const WrenchLimitation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WrenchLimitation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float force = 1;
  void clear_force();
  static const int kForceFieldNumber = 1;
  float force() const;
  void set_force(float value);

  // float torque = 2;
  void clear_torque();
  static const int kTorqueFieldNumber = 2;
  float torque() const;
  void set_torque(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.WrenchLimitation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float force_;
  float torque_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsWrenchLimitationImpl();
};
// -------------------------------------------------------------------

class CartesianLimitationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.CartesianLimitationList) */ {
 public:
  CartesianLimitationList();
  virtual ~CartesianLimitationList();

  CartesianLimitationList(const CartesianLimitationList& from);

  inline CartesianLimitationList& operator=(const CartesianLimitationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianLimitationList(CartesianLimitationList&& from) noexcept
    : CartesianLimitationList() {
    *this = ::std::move(from);
  }

  inline CartesianLimitationList& operator=(CartesianLimitationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianLimitationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianLimitationList* internal_default_instance() {
    return reinterpret_cast<const CartesianLimitationList*>(
               &_CartesianLimitationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(CartesianLimitationList* other);
  friend void swap(CartesianLimitationList& a, CartesianLimitationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianLimitationList* New() const PROTOBUF_FINAL { return New(NULL); }

  CartesianLimitationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CartesianLimitationList& from);
  void MergeFrom(const CartesianLimitationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CartesianLimitationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.CartesianLimitation limitations = 1;
  int limitations_size() const;
  void clear_limitations();
  static const int kLimitationsFieldNumber = 1;
  const ::Kinova::Api::Base::CartesianLimitation& limitations(int index) const;
  ::Kinova::Api::Base::CartesianLimitation* mutable_limitations(int index);
  ::Kinova::Api::Base::CartesianLimitation* add_limitations();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation >*
      mutable_limitations();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation >&
      limitations() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.CartesianLimitationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation > limitations_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsCartesianLimitationListImpl();
};
// -------------------------------------------------------------------

class JointLimitation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.JointLimitation) */ {
 public:
  JointLimitation();
  virtual ~JointLimitation();

  JointLimitation(const JointLimitation& from);

  inline JointLimitation& operator=(const JointLimitation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointLimitation(JointLimitation&& from) noexcept
    : JointLimitation() {
    *this = ::std::move(from);
  }

  inline JointLimitation& operator=(JointLimitation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JointLimitation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointLimitation* internal_default_instance() {
    return reinterpret_cast<const JointLimitation*>(
               &_JointLimitation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(JointLimitation* other);
  friend void swap(JointLimitation& a, JointLimitation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointLimitation* New() const PROTOBUF_FINAL { return New(NULL); }

  JointLimitation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JointLimitation& from);
  void MergeFrom(const JointLimitation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JointLimitation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 joint_identifier = 1;
  void clear_joint_identifier();
  static const int kJointIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 joint_identifier() const;
  void set_joint_identifier(::google::protobuf::uint32 value);

  // .Kinova.Api.Base.LimitationType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::Kinova::Api::Base::LimitationType type() const;
  void set_type(::Kinova::Api::Base::LimitationType value);

  // float value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.JointLimitation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 joint_identifier_;
  int type_;
  float value_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsJointLimitationImpl();
};
// -------------------------------------------------------------------

class JointsLimitationsList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.JointsLimitationsList) */ {
 public:
  JointsLimitationsList();
  virtual ~JointsLimitationsList();

  JointsLimitationsList(const JointsLimitationsList& from);

  inline JointsLimitationsList& operator=(const JointsLimitationsList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointsLimitationsList(JointsLimitationsList&& from) noexcept
    : JointsLimitationsList() {
    *this = ::std::move(from);
  }

  inline JointsLimitationsList& operator=(JointsLimitationsList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JointsLimitationsList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointsLimitationsList* internal_default_instance() {
    return reinterpret_cast<const JointsLimitationsList*>(
               &_JointsLimitationsList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(JointsLimitationsList* other);
  friend void swap(JointsLimitationsList& a, JointsLimitationsList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointsLimitationsList* New() const PROTOBUF_FINAL { return New(NULL); }

  JointsLimitationsList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JointsLimitationsList& from);
  void MergeFrom(const JointsLimitationsList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JointsLimitationsList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.JointLimitation joints_limitations = 1;
  int joints_limitations_size() const;
  void clear_joints_limitations();
  static const int kJointsLimitationsFieldNumber = 1;
  const ::Kinova::Api::Base::JointLimitation& joints_limitations(int index) const;
  ::Kinova::Api::Base::JointLimitation* mutable_joints_limitations(int index);
  ::Kinova::Api::Base::JointLimitation* add_joints_limitations();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointLimitation >*
      mutable_joints_limitations();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointLimitation >&
      joints_limitations() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.JointsLimitationsList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointLimitation > joints_limitations_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsJointsLimitationsListImpl();
};
// -------------------------------------------------------------------

class Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Query) */ {
 public:
  Query();
  virtual ~Query();

  Query(const Query& from);

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Query(Query&& from) noexcept
    : Query() {
    *this = ::std::move(from);
  }

  inline Query& operator=(Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Query* internal_default_instance() {
    return reinterpret_cast<const Query*>(
               &_Query_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(Query* other);
  friend void swap(Query& a, Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Query* New() const PROTOBUF_FINAL { return New(NULL); }

  Query* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Query& from);
  void MergeFrom(const Query& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 3;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // .Kinova.Api.Common.Timestamp start_timestamp = 1;
  bool has_start_timestamp() const;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 1;
  const ::Kinova::Api::Common::Timestamp& start_timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_start_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_start_timestamp();
  void set_allocated_start_timestamp(::Kinova::Api::Common::Timestamp* start_timestamp);

  // .Kinova.Api.Common.Timestamp end_timestamp = 2;
  bool has_end_timestamp() const;
  void clear_end_timestamp();
  static const int kEndTimestampFieldNumber = 2;
  const ::Kinova::Api::Common::Timestamp& end_timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_end_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_end_timestamp();
  void set_allocated_end_timestamp(::Kinova::Api::Common::Timestamp* end_timestamp);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Query)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::Kinova::Api::Common::Timestamp* start_timestamp_;
  ::Kinova::Api::Common::Timestamp* end_timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsQueryImpl();
};
// -------------------------------------------------------------------

class ConfigurationChangeNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ConfigurationChangeNotification) */ {
 public:
  ConfigurationChangeNotification();
  virtual ~ConfigurationChangeNotification();

  ConfigurationChangeNotification(const ConfigurationChangeNotification& from);

  inline ConfigurationChangeNotification& operator=(const ConfigurationChangeNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConfigurationChangeNotification(ConfigurationChangeNotification&& from) noexcept
    : ConfigurationChangeNotification() {
    *this = ::std::move(from);
  }

  inline ConfigurationChangeNotification& operator=(ConfigurationChangeNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigurationChangeNotification& default_instance();

  enum ConfigurationChangeCase {
    kSequenceHandle = 4,
    kActionHandle = 5,
    kMappingHandle = 6,
    kMapGroupHandle = 7,
    kMapHandle = 8,
    kUserProfileHandle = 9,
    kProtectionZoneHandle = 10,
    kSafetyHandle = 11,
    kNetworkHandle = 12,
    kSsid = 14,
    kControllerHandle = 16,
    CONFIGURATION_CHANGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigurationChangeNotification* internal_default_instance() {
    return reinterpret_cast<const ConfigurationChangeNotification*>(
               &_ConfigurationChangeNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(ConfigurationChangeNotification* other);
  friend void swap(ConfigurationChangeNotification& a, ConfigurationChangeNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConfigurationChangeNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  ConfigurationChangeNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConfigurationChangeNotification& from);
  void MergeFrom(const ConfigurationChangeNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConfigurationChangeNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.Timestamp timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 3;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 3;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 15;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 15;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Base.ConfigurationNotificationEvent event = 1;
  void clear_event();
  static const int kEventFieldNumber = 1;
  ::Kinova::Api::Base::ConfigurationNotificationEvent event() const;
  void set_event(::Kinova::Api::Base::ConfigurationNotificationEvent value);

  // .Kinova.Api.Base.SequenceHandle sequence_handle = 4;
  bool has_sequence_handle() const;
  void clear_sequence_handle();
  static const int kSequenceHandleFieldNumber = 4;
  const ::Kinova::Api::Base::SequenceHandle& sequence_handle() const;
  ::Kinova::Api::Base::SequenceHandle* release_sequence_handle();
  ::Kinova::Api::Base::SequenceHandle* mutable_sequence_handle();
  void set_allocated_sequence_handle(::Kinova::Api::Base::SequenceHandle* sequence_handle);

  // .Kinova.Api.Base.ActionHandle action_handle = 5;
  bool has_action_handle() const;
  void clear_action_handle();
  static const int kActionHandleFieldNumber = 5;
  const ::Kinova::Api::Base::ActionHandle& action_handle() const;
  ::Kinova::Api::Base::ActionHandle* release_action_handle();
  ::Kinova::Api::Base::ActionHandle* mutable_action_handle();
  void set_allocated_action_handle(::Kinova::Api::Base::ActionHandle* action_handle);

  // .Kinova.Api.Base.MappingHandle mapping_handle = 6;
  bool has_mapping_handle() const;
  void clear_mapping_handle();
  static const int kMappingHandleFieldNumber = 6;
  const ::Kinova::Api::Base::MappingHandle& mapping_handle() const;
  ::Kinova::Api::Base::MappingHandle* release_mapping_handle();
  ::Kinova::Api::Base::MappingHandle* mutable_mapping_handle();
  void set_allocated_mapping_handle(::Kinova::Api::Base::MappingHandle* mapping_handle);

  // .Kinova.Api.Base.MapGroupHandle map_group_handle = 7;
  bool has_map_group_handle() const;
  void clear_map_group_handle();
  static const int kMapGroupHandleFieldNumber = 7;
  const ::Kinova::Api::Base::MapGroupHandle& map_group_handle() const;
  ::Kinova::Api::Base::MapGroupHandle* release_map_group_handle();
  ::Kinova::Api::Base::MapGroupHandle* mutable_map_group_handle();
  void set_allocated_map_group_handle(::Kinova::Api::Base::MapGroupHandle* map_group_handle);

  // .Kinova.Api.Base.MapHandle map_handle = 8;
  bool has_map_handle() const;
  void clear_map_handle();
  static const int kMapHandleFieldNumber = 8;
  const ::Kinova::Api::Base::MapHandle& map_handle() const;
  ::Kinova::Api::Base::MapHandle* release_map_handle();
  ::Kinova::Api::Base::MapHandle* mutable_map_handle();
  void set_allocated_map_handle(::Kinova::Api::Base::MapHandle* map_handle);

  // .Kinova.Api.Common.UserProfileHandle user_profile_handle = 9;
  bool has_user_profile_handle() const;
  void clear_user_profile_handle();
  static const int kUserProfileHandleFieldNumber = 9;
  const ::Kinova::Api::Common::UserProfileHandle& user_profile_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_profile_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_profile_handle();
  void set_allocated_user_profile_handle(::Kinova::Api::Common::UserProfileHandle* user_profile_handle);

  // .Kinova.Api.Base.ProtectionZoneHandle protection_zone_handle = 10;
  bool has_protection_zone_handle() const;
  void clear_protection_zone_handle();
  static const int kProtectionZoneHandleFieldNumber = 10;
  const ::Kinova::Api::Base::ProtectionZoneHandle& protection_zone_handle() const;
  ::Kinova::Api::Base::ProtectionZoneHandle* release_protection_zone_handle();
  ::Kinova::Api::Base::ProtectionZoneHandle* mutable_protection_zone_handle();
  void set_allocated_protection_zone_handle(::Kinova::Api::Base::ProtectionZoneHandle* protection_zone_handle);

  // .Kinova.Api.Common.SafetyHandle safety_handle = 11;
  bool has_safety_handle() const;
  void clear_safety_handle();
  static const int kSafetyHandleFieldNumber = 11;
  const ::Kinova::Api::Common::SafetyHandle& safety_handle() const;
  ::Kinova::Api::Common::SafetyHandle* release_safety_handle();
  ::Kinova::Api::Common::SafetyHandle* mutable_safety_handle();
  void set_allocated_safety_handle(::Kinova::Api::Common::SafetyHandle* safety_handle);

  // .Kinova.Api.Base.NetworkHandle network_handle = 12;
  bool has_network_handle() const;
  void clear_network_handle();
  static const int kNetworkHandleFieldNumber = 12;
  const ::Kinova::Api::Base::NetworkHandle& network_handle() const;
  ::Kinova::Api::Base::NetworkHandle* release_network_handle();
  ::Kinova::Api::Base::NetworkHandle* mutable_network_handle();
  void set_allocated_network_handle(::Kinova::Api::Base::NetworkHandle* network_handle);

  // .Kinova.Api.Base.Ssid ssid = 14;
  bool has_ssid() const;
  void clear_ssid();
  static const int kSsidFieldNumber = 14;
  const ::Kinova::Api::Base::Ssid& ssid() const;
  ::Kinova::Api::Base::Ssid* release_ssid();
  ::Kinova::Api::Base::Ssid* mutable_ssid();
  void set_allocated_ssid(::Kinova::Api::Base::Ssid* ssid);

  // .Kinova.Api.Base.ControllerHandle controller_handle = 16;
  bool has_controller_handle() const;
  void clear_controller_handle();
  static const int kControllerHandleFieldNumber = 16;
  const ::Kinova::Api::Base::ControllerHandle& controller_handle() const;
  ::Kinova::Api::Base::ControllerHandle* release_controller_handle();
  ::Kinova::Api::Base::ControllerHandle* mutable_controller_handle();
  void set_allocated_controller_handle(::Kinova::Api::Base::ControllerHandle* controller_handle);

  ConfigurationChangeCase configuration_change_case() const;
  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ConfigurationChangeNotification)
 private:
  void set_has_sequence_handle();
  void set_has_action_handle();
  void set_has_mapping_handle();
  void set_has_map_group_handle();
  void set_has_map_handle();
  void set_has_user_profile_handle();
  void set_has_protection_zone_handle();
  void set_has_safety_handle();
  void set_has_network_handle();
  void set_has_ssid();
  void set_has_controller_handle();

  inline bool has_configuration_change() const;
  void clear_configuration_change();
  inline void clear_has_configuration_change();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  int event_;
  union ConfigurationChangeUnion {
    ConfigurationChangeUnion() {}
    ::Kinova::Api::Base::SequenceHandle* sequence_handle_;
    ::Kinova::Api::Base::ActionHandle* action_handle_;
    ::Kinova::Api::Base::MappingHandle* mapping_handle_;
    ::Kinova::Api::Base::MapGroupHandle* map_group_handle_;
    ::Kinova::Api::Base::MapHandle* map_handle_;
    ::Kinova::Api::Common::UserProfileHandle* user_profile_handle_;
    ::Kinova::Api::Base::ProtectionZoneHandle* protection_zone_handle_;
    ::Kinova::Api::Common::SafetyHandle* safety_handle_;
    ::Kinova::Api::Base::NetworkHandle* network_handle_;
    ::Kinova::Api::Base::Ssid* ssid_;
    ::Kinova::Api::Base::ControllerHandle* controller_handle_;
  } configuration_change_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsConfigurationChangeNotificationImpl();
};
// -------------------------------------------------------------------

class MappingInfoNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.MappingInfoNotification) */ {
 public:
  MappingInfoNotification();
  virtual ~MappingInfoNotification();

  MappingInfoNotification(const MappingInfoNotification& from);

  inline MappingInfoNotification& operator=(const MappingInfoNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MappingInfoNotification(MappingInfoNotification&& from) noexcept
    : MappingInfoNotification() {
    *this = ::std::move(from);
  }

  inline MappingInfoNotification& operator=(MappingInfoNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MappingInfoNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MappingInfoNotification* internal_default_instance() {
    return reinterpret_cast<const MappingInfoNotification*>(
               &_MappingInfoNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(MappingInfoNotification* other);
  friend void swap(MappingInfoNotification& a, MappingInfoNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MappingInfoNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  MappingInfoNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MappingInfoNotification& from);
  void MergeFrom(const MappingInfoNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MappingInfoNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.MapHandle active_map_handle = 2;
  bool has_active_map_handle() const;
  void clear_active_map_handle();
  static const int kActiveMapHandleFieldNumber = 2;
  const ::Kinova::Api::Base::MapHandle& active_map_handle() const;
  ::Kinova::Api::Base::MapHandle* release_active_map_handle();
  ::Kinova::Api::Base::MapHandle* mutable_active_map_handle();
  void set_allocated_active_map_handle(::Kinova::Api::Base::MapHandle* active_map_handle);

  // .Kinova.Api.Common.Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 4;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 4;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 5;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 5;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Base.MappingHandle mapping_handle = 6;
  bool has_mapping_handle() const;
  void clear_mapping_handle();
  static const int kMappingHandleFieldNumber = 6;
  const ::Kinova::Api::Base::MappingHandle& mapping_handle() const;
  ::Kinova::Api::Base::MappingHandle* release_mapping_handle();
  ::Kinova::Api::Base::MappingHandle* mutable_mapping_handle();
  void set_allocated_mapping_handle(::Kinova::Api::Base::MappingHandle* mapping_handle);

  // uint32 controller_identifier = 1;
  void clear_controller_identifier();
  static const int kControllerIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 controller_identifier() const;
  void set_controller_identifier(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.MappingInfoNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::MapHandle* active_map_handle_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  ::Kinova::Api::Base::MappingHandle* mapping_handle_;
  ::google::protobuf::uint32 controller_identifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsMappingInfoNotificationImpl();
};
// -------------------------------------------------------------------

class ControlModeInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ControlModeInformation) */ {
 public:
  ControlModeInformation();
  virtual ~ControlModeInformation();

  ControlModeInformation(const ControlModeInformation& from);

  inline ControlModeInformation& operator=(const ControlModeInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlModeInformation(ControlModeInformation&& from) noexcept
    : ControlModeInformation() {
    *this = ::std::move(from);
  }

  inline ControlModeInformation& operator=(ControlModeInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlModeInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlModeInformation* internal_default_instance() {
    return reinterpret_cast<const ControlModeInformation*>(
               &_ControlModeInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    60;

  void Swap(ControlModeInformation* other);
  friend void swap(ControlModeInformation& a, ControlModeInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlModeInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  ControlModeInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControlModeInformation& from);
  void MergeFrom(const ControlModeInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControlModeInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.ControlMode mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::Kinova::Api::Base::ControlMode mode() const;
  void set_mode(::Kinova::Api::Base::ControlMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ControlModeInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsControlModeInformationImpl();
};
// -------------------------------------------------------------------

class ControlModeNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ControlModeNotification) */ {
 public:
  ControlModeNotification();
  virtual ~ControlModeNotification();

  ControlModeNotification(const ControlModeNotification& from);

  inline ControlModeNotification& operator=(const ControlModeNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlModeNotification(ControlModeNotification&& from) noexcept
    : ControlModeNotification() {
    *this = ::std::move(from);
  }

  inline ControlModeNotification& operator=(ControlModeNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlModeNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlModeNotification* internal_default_instance() {
    return reinterpret_cast<const ControlModeNotification*>(
               &_ControlModeNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    61;

  void Swap(ControlModeNotification* other);
  friend void swap(ControlModeNotification& a, ControlModeNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlModeNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  ControlModeNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControlModeNotification& from);
  void MergeFrom(const ControlModeNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControlModeNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.Timestamp timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 3;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 3;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 4;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 4;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Base.ControlMode control_mode = 1;
  void clear_control_mode();
  static const int kControlModeFieldNumber = 1;
  ::Kinova::Api::Base::ControlMode control_mode() const;
  void set_control_mode(::Kinova::Api::Base::ControlMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ControlModeNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  int control_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsControlModeNotificationImpl();
};
// -------------------------------------------------------------------

class ServoingModeInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ServoingModeInformation) */ {
 public:
  ServoingModeInformation();
  virtual ~ServoingModeInformation();

  ServoingModeInformation(const ServoingModeInformation& from);

  inline ServoingModeInformation& operator=(const ServoingModeInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServoingModeInformation(ServoingModeInformation&& from) noexcept
    : ServoingModeInformation() {
    *this = ::std::move(from);
  }

  inline ServoingModeInformation& operator=(ServoingModeInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServoingModeInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServoingModeInformation* internal_default_instance() {
    return reinterpret_cast<const ServoingModeInformation*>(
               &_ServoingModeInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    62;

  void Swap(ServoingModeInformation* other);
  friend void swap(ServoingModeInformation& a, ServoingModeInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServoingModeInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  ServoingModeInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServoingModeInformation& from);
  void MergeFrom(const ServoingModeInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServoingModeInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.ServoingMode servoing_mode = 1;
  void clear_servoing_mode();
  static const int kServoingModeFieldNumber = 1;
  ::Kinova::Api::Base::ServoingMode servoing_mode() const;
  void set_servoing_mode(::Kinova::Api::Base::ServoingMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ServoingModeInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int servoing_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsServoingModeInformationImpl();
};
// -------------------------------------------------------------------

class OperatingModeInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.OperatingModeInformation) */ {
 public:
  OperatingModeInformation();
  virtual ~OperatingModeInformation();

  OperatingModeInformation(const OperatingModeInformation& from);

  inline OperatingModeInformation& operator=(const OperatingModeInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperatingModeInformation(OperatingModeInformation&& from) noexcept
    : OperatingModeInformation() {
    *this = ::std::move(from);
  }

  inline OperatingModeInformation& operator=(OperatingModeInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperatingModeInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperatingModeInformation* internal_default_instance() {
    return reinterpret_cast<const OperatingModeInformation*>(
               &_OperatingModeInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    63;

  void Swap(OperatingModeInformation* other);
  friend void swap(OperatingModeInformation& a, OperatingModeInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperatingModeInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  OperatingModeInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperatingModeInformation& from);
  void MergeFrom(const OperatingModeInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperatingModeInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.DeviceHandle device_handle = 2;
  bool has_device_handle() const;
  void clear_device_handle();
  static const int kDeviceHandleFieldNumber = 2;
  const ::Kinova::Api::Common::DeviceHandle& device_handle() const;
  ::Kinova::Api::Common::DeviceHandle* release_device_handle();
  ::Kinova::Api::Common::DeviceHandle* mutable_device_handle();
  void set_allocated_device_handle(::Kinova::Api::Common::DeviceHandle* device_handle);

  // .Kinova.Api.Base.OperatingMode operating_mode = 1;
  void clear_operating_mode();
  static const int kOperatingModeFieldNumber = 1;
  ::Kinova::Api::Base::OperatingMode operating_mode() const;
  void set_operating_mode(::Kinova::Api::Base::OperatingMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.OperatingModeInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::DeviceHandle* device_handle_;
  int operating_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsOperatingModeInformationImpl();
};
// -------------------------------------------------------------------

class OperatingModeNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.OperatingModeNotification) */ {
 public:
  OperatingModeNotification();
  virtual ~OperatingModeNotification();

  OperatingModeNotification(const OperatingModeNotification& from);

  inline OperatingModeNotification& operator=(const OperatingModeNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperatingModeNotification(OperatingModeNotification&& from) noexcept
    : OperatingModeNotification() {
    *this = ::std::move(from);
  }

  inline OperatingModeNotification& operator=(OperatingModeNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperatingModeNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperatingModeNotification* internal_default_instance() {
    return reinterpret_cast<const OperatingModeNotification*>(
               &_OperatingModeNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    64;

  void Swap(OperatingModeNotification* other);
  friend void swap(OperatingModeNotification& a, OperatingModeNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperatingModeNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  OperatingModeNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperatingModeNotification& from);
  void MergeFrom(const OperatingModeNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperatingModeNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.Timestamp timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 3;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 3;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 4;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 4;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Common.DeviceHandle device_handle = 5;
  bool has_device_handle() const;
  void clear_device_handle();
  static const int kDeviceHandleFieldNumber = 5;
  const ::Kinova::Api::Common::DeviceHandle& device_handle() const;
  ::Kinova::Api::Common::DeviceHandle* release_device_handle();
  ::Kinova::Api::Common::DeviceHandle* mutable_device_handle();
  void set_allocated_device_handle(::Kinova::Api::Common::DeviceHandle* device_handle);

  // .Kinova.Api.Base.OperatingMode operating_mode = 1;
  void clear_operating_mode();
  static const int kOperatingModeFieldNumber = 1;
  ::Kinova::Api::Base::OperatingMode operating_mode() const;
  void set_operating_mode(::Kinova::Api::Base::OperatingMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.OperatingModeNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  ::Kinova::Api::Common::DeviceHandle* device_handle_;
  int operating_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsOperatingModeNotificationImpl();
};
// -------------------------------------------------------------------

class ServoingModeNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ServoingModeNotification) */ {
 public:
  ServoingModeNotification();
  virtual ~ServoingModeNotification();

  ServoingModeNotification(const ServoingModeNotification& from);

  inline ServoingModeNotification& operator=(const ServoingModeNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServoingModeNotification(ServoingModeNotification&& from) noexcept
    : ServoingModeNotification() {
    *this = ::std::move(from);
  }

  inline ServoingModeNotification& operator=(ServoingModeNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServoingModeNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServoingModeNotification* internal_default_instance() {
    return reinterpret_cast<const ServoingModeNotification*>(
               &_ServoingModeNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    65;

  void Swap(ServoingModeNotification* other);
  friend void swap(ServoingModeNotification& a, ServoingModeNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServoingModeNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  ServoingModeNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServoingModeNotification& from);
  void MergeFrom(const ServoingModeNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServoingModeNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.Timestamp timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 3;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 3;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 4;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 4;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Base.ServoingMode servoing_mode = 1;
  void clear_servoing_mode();
  static const int kServoingModeFieldNumber = 1;
  ::Kinova::Api::Base::ServoingMode servoing_mode() const;
  void set_servoing_mode(::Kinova::Api::Base::ServoingMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ServoingModeNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  int servoing_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsServoingModeNotificationImpl();
};
// -------------------------------------------------------------------

class SequenceInfoNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SequenceInfoNotification) */ {
 public:
  SequenceInfoNotification();
  virtual ~SequenceInfoNotification();

  SequenceInfoNotification(const SequenceInfoNotification& from);

  inline SequenceInfoNotification& operator=(const SequenceInfoNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SequenceInfoNotification(SequenceInfoNotification&& from) noexcept
    : SequenceInfoNotification() {
    *this = ::std::move(from);
  }

  inline SequenceInfoNotification& operator=(SequenceInfoNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceInfoNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SequenceInfoNotification* internal_default_instance() {
    return reinterpret_cast<const SequenceInfoNotification*>(
               &_SequenceInfoNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    66;

  void Swap(SequenceInfoNotification* other);
  friend void swap(SequenceInfoNotification& a, SequenceInfoNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SequenceInfoNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  SequenceInfoNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SequenceInfoNotification& from);
  void MergeFrom(const SequenceInfoNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SequenceInfoNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.SequenceHandle sequence_handle = 2;
  bool has_sequence_handle() const;
  void clear_sequence_handle();
  static const int kSequenceHandleFieldNumber = 2;
  const ::Kinova::Api::Base::SequenceHandle& sequence_handle() const;
  ::Kinova::Api::Base::SequenceHandle* release_sequence_handle();
  ::Kinova::Api::Base::SequenceHandle* mutable_sequence_handle();
  void set_allocated_sequence_handle(::Kinova::Api::Base::SequenceHandle* sequence_handle);

  // .Kinova.Api.Common.Timestamp timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 6;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 6;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 8;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 8;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Base.EventIdSequenceInfoNotification event_identifier = 1;
  void clear_event_identifier();
  static const int kEventIdentifierFieldNumber = 1;
  ::Kinova::Api::Base::EventIdSequenceInfoNotification event_identifier() const;
  void set_event_identifier(::Kinova::Api::Base::EventIdSequenceInfoNotification value);

  // uint32 task_index = 3;
  void clear_task_index();
  static const int kTaskIndexFieldNumber = 3;
  ::google::protobuf::uint32 task_index() const;
  void set_task_index(::google::protobuf::uint32 value);

  // uint32 group_identifier = 4;
  void clear_group_identifier();
  static const int kGroupIdentifierFieldNumber = 4;
  ::google::protobuf::uint32 group_identifier() const;
  void set_group_identifier(::google::protobuf::uint32 value);

  // .Kinova.Api.SubErrorCodes abort_details = 7;
  void clear_abort_details();
  static const int kAbortDetailsFieldNumber = 7;
  ::Kinova::Api::SubErrorCodes abort_details() const;
  void set_abort_details(::Kinova::Api::SubErrorCodes value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SequenceInfoNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::SequenceHandle* sequence_handle_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  int event_identifier_;
  ::google::protobuf::uint32 task_index_;
  ::google::protobuf::uint32 group_identifier_;
  int abort_details_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSequenceInfoNotificationImpl();
};
// -------------------------------------------------------------------

class SequenceInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SequenceInformation) */ {
 public:
  SequenceInformation();
  virtual ~SequenceInformation();

  SequenceInformation(const SequenceInformation& from);

  inline SequenceInformation& operator=(const SequenceInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SequenceInformation(SequenceInformation&& from) noexcept
    : SequenceInformation() {
    *this = ::std::move(from);
  }

  inline SequenceInformation& operator=(SequenceInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SequenceInformation* internal_default_instance() {
    return reinterpret_cast<const SequenceInformation*>(
               &_SequenceInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    67;

  void Swap(SequenceInformation* other);
  friend void swap(SequenceInformation& a, SequenceInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SequenceInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  SequenceInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SequenceInformation& from);
  void MergeFrom(const SequenceInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SequenceInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.EventIdSequenceInfoNotification event_identifier = 1;
  void clear_event_identifier();
  static const int kEventIdentifierFieldNumber = 1;
  ::Kinova::Api::Base::EventIdSequenceInfoNotification event_identifier() const;
  void set_event_identifier(::Kinova::Api::Base::EventIdSequenceInfoNotification value);

  // uint32 task_index = 2;
  void clear_task_index();
  static const int kTaskIndexFieldNumber = 2;
  ::google::protobuf::uint32 task_index() const;
  void set_task_index(::google::protobuf::uint32 value);

  // uint32 task_identifier = 3;
  void clear_task_identifier();
  static const int kTaskIdentifierFieldNumber = 3;
  ::google::protobuf::uint32 task_identifier() const;
  void set_task_identifier(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SequenceInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int event_identifier_;
  ::google::protobuf::uint32 task_index_;
  ::google::protobuf::uint32 task_identifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSequenceInformationImpl();
};
// -------------------------------------------------------------------

class ProtectionZoneNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ProtectionZoneNotification) */ {
 public:
  ProtectionZoneNotification();
  virtual ~ProtectionZoneNotification();

  ProtectionZoneNotification(const ProtectionZoneNotification& from);

  inline ProtectionZoneNotification& operator=(const ProtectionZoneNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtectionZoneNotification(ProtectionZoneNotification&& from) noexcept
    : ProtectionZoneNotification() {
    *this = ::std::move(from);
  }

  inline ProtectionZoneNotification& operator=(ProtectionZoneNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtectionZoneNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtectionZoneNotification* internal_default_instance() {
    return reinterpret_cast<const ProtectionZoneNotification*>(
               &_ProtectionZoneNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    68;

  void Swap(ProtectionZoneNotification* other);
  friend void swap(ProtectionZoneNotification& a, ProtectionZoneNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtectionZoneNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtectionZoneNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtectionZoneNotification& from);
  void MergeFrom(const ProtectionZoneNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtectionZoneNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.ProtectionZoneHandle handle = 2;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 2;
  const ::Kinova::Api::Base::ProtectionZoneHandle& handle() const;
  ::Kinova::Api::Base::ProtectionZoneHandle* release_handle();
  ::Kinova::Api::Base::ProtectionZoneHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Base::ProtectionZoneHandle* handle);

  // .Kinova.Api.Common.Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 4;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 4;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 5;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 5;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Base.ProtectionZoneEvent event = 1;
  void clear_event();
  static const int kEventFieldNumber = 1;
  ::Kinova::Api::Base::ProtectionZoneEvent event() const;
  void set_event(::Kinova::Api::Base::ProtectionZoneEvent value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ProtectionZoneNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::ProtectionZoneHandle* handle_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  int event_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsProtectionZoneNotificationImpl();
};
// -------------------------------------------------------------------

class ProtectionZoneInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ProtectionZoneInformation) */ {
 public:
  ProtectionZoneInformation();
  virtual ~ProtectionZoneInformation();

  ProtectionZoneInformation(const ProtectionZoneInformation& from);

  inline ProtectionZoneInformation& operator=(const ProtectionZoneInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtectionZoneInformation(ProtectionZoneInformation&& from) noexcept
    : ProtectionZoneInformation() {
    *this = ::std::move(from);
  }

  inline ProtectionZoneInformation& operator=(ProtectionZoneInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtectionZoneInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtectionZoneInformation* internal_default_instance() {
    return reinterpret_cast<const ProtectionZoneInformation*>(
               &_ProtectionZoneInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    69;

  void Swap(ProtectionZoneInformation* other);
  friend void swap(ProtectionZoneInformation& a, ProtectionZoneInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtectionZoneInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtectionZoneInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtectionZoneInformation& from);
  void MergeFrom(const ProtectionZoneInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtectionZoneInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.ProtectionZoneEvent event = 1;
  void clear_event();
  static const int kEventFieldNumber = 1;
  ::Kinova::Api::Base::ProtectionZoneEvent event() const;
  void set_event(::Kinova::Api::Base::ProtectionZoneEvent value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ProtectionZoneInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int event_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsProtectionZoneInformationImpl();
};
// -------------------------------------------------------------------

class UserNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.UserNotification) */ {
 public:
  UserNotification();
  virtual ~UserNotification();

  UserNotification(const UserNotification& from);

  inline UserNotification& operator=(const UserNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserNotification(UserNotification&& from) noexcept
    : UserNotification() {
    *this = ::std::move(from);
  }

  inline UserNotification& operator=(UserNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserNotification* internal_default_instance() {
    return reinterpret_cast<const UserNotification*>(
               &_UserNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    70;

  void Swap(UserNotification* other);
  friend void swap(UserNotification& a, UserNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  UserNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserNotification& from);
  void MergeFrom(const UserNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.UserProfileHandle modified_user = 2;
  bool has_modified_user() const;
  void clear_modified_user();
  static const int kModifiedUserFieldNumber = 2;
  const ::Kinova::Api::Common::UserProfileHandle& modified_user() const;
  ::Kinova::Api::Common::UserProfileHandle* release_modified_user();
  ::Kinova::Api::Common::UserProfileHandle* mutable_modified_user();
  void set_allocated_modified_user(::Kinova::Api::Common::UserProfileHandle* modified_user);

  // .Kinova.Api.Common.Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 4;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 4;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 5;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 5;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Base.UserEvent user_event = 1;
  void clear_user_event();
  static const int kUserEventFieldNumber = 1;
  ::Kinova::Api::Base::UserEvent user_event() const;
  void set_user_event(::Kinova::Api::Base::UserEvent value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.UserNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::UserProfileHandle* modified_user_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  int user_event_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsUserNotificationImpl();
};
// -------------------------------------------------------------------

class ControllerHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ControllerHandle) */ {
 public:
  ControllerHandle();
  virtual ~ControllerHandle();

  ControllerHandle(const ControllerHandle& from);

  inline ControllerHandle& operator=(const ControllerHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerHandle(ControllerHandle&& from) noexcept
    : ControllerHandle() {
    *this = ::std::move(from);
  }

  inline ControllerHandle& operator=(ControllerHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerHandle* internal_default_instance() {
    return reinterpret_cast<const ControllerHandle*>(
               &_ControllerHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    71;

  void Swap(ControllerHandle* other);
  friend void swap(ControllerHandle& a, ControllerHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  ControllerHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControllerHandle& from);
  void MergeFrom(const ControllerHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControllerHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.ControllerType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Kinova::Api::Base::ControllerType type() const;
  void set_type(::Kinova::Api::Base::ControllerType value);

  // uint32 controller_identifier = 2;
  void clear_controller_identifier();
  static const int kControllerIdentifierFieldNumber = 2;
  ::google::protobuf::uint32 controller_identifier() const;
  void set_controller_identifier(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ControllerHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int type_;
  ::google::protobuf::uint32 controller_identifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsControllerHandleImpl();
};
// -------------------------------------------------------------------

class ControllerElementHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ControllerElementHandle) */ {
 public:
  ControllerElementHandle();
  virtual ~ControllerElementHandle();

  ControllerElementHandle(const ControllerElementHandle& from);

  inline ControllerElementHandle& operator=(const ControllerElementHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerElementHandle(ControllerElementHandle&& from) noexcept
    : ControllerElementHandle() {
    *this = ::std::move(from);
  }

  inline ControllerElementHandle& operator=(ControllerElementHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerElementHandle& default_instance();

  enum IdentifierCase {
    kButton = 2,
    kAxis = 3,
    IDENTIFIER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerElementHandle* internal_default_instance() {
    return reinterpret_cast<const ControllerElementHandle*>(
               &_ControllerElementHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    72;

  void Swap(ControllerElementHandle* other);
  friend void swap(ControllerElementHandle& a, ControllerElementHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerElementHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  ControllerElementHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControllerElementHandle& from);
  void MergeFrom(const ControllerElementHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControllerElementHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.ControllerHandle controller_handle = 1;
  bool has_controller_handle() const;
  void clear_controller_handle();
  static const int kControllerHandleFieldNumber = 1;
  const ::Kinova::Api::Base::ControllerHandle& controller_handle() const;
  ::Kinova::Api::Base::ControllerHandle* release_controller_handle();
  ::Kinova::Api::Base::ControllerHandle* mutable_controller_handle();
  void set_allocated_controller_handle(::Kinova::Api::Base::ControllerHandle* controller_handle);

  // uint32 button = 2;
  private:
  bool has_button() const;
  public:
  void clear_button();
  static const int kButtonFieldNumber = 2;
  ::google::protobuf::uint32 button() const;
  void set_button(::google::protobuf::uint32 value);

  // uint32 axis = 3;
  private:
  bool has_axis() const;
  public:
  void clear_axis();
  static const int kAxisFieldNumber = 3;
  ::google::protobuf::uint32 axis() const;
  void set_axis(::google::protobuf::uint32 value);

  IdentifierCase identifier_case() const;
  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ControllerElementHandle)
 private:
  void set_has_button();
  void set_has_axis();

  inline bool has_identifier() const;
  void clear_identifier();
  inline void clear_has_identifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::ControllerHandle* controller_handle_;
  union IdentifierUnion {
    IdentifierUnion() {}
    ::google::protobuf::uint32 button_;
    ::google::protobuf::uint32 axis_;
  } identifier_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsControllerElementHandleImpl();
};
// -------------------------------------------------------------------

class ControllerNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ControllerNotification) */ {
 public:
  ControllerNotification();
  virtual ~ControllerNotification();

  ControllerNotification(const ControllerNotification& from);

  inline ControllerNotification& operator=(const ControllerNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerNotification(ControllerNotification&& from) noexcept
    : ControllerNotification() {
    *this = ::std::move(from);
  }

  inline ControllerNotification& operator=(ControllerNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerNotification& default_instance();

  enum StateCase {
    kControllerState = 1,
    kControllerElement = 2,
    STATE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerNotification* internal_default_instance() {
    return reinterpret_cast<const ControllerNotification*>(
               &_ControllerNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    73;

  void Swap(ControllerNotification* other);
  friend void swap(ControllerNotification& a, ControllerNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  ControllerNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControllerNotification& from);
  void MergeFrom(const ControllerNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControllerNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 4;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 4;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 5;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 5;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Base.ControllerState controller_state = 1;
  bool has_controller_state() const;
  void clear_controller_state();
  static const int kControllerStateFieldNumber = 1;
  const ::Kinova::Api::Base::ControllerState& controller_state() const;
  ::Kinova::Api::Base::ControllerState* release_controller_state();
  ::Kinova::Api::Base::ControllerState* mutable_controller_state();
  void set_allocated_controller_state(::Kinova::Api::Base::ControllerState* controller_state);

  // .Kinova.Api.Base.ControllerElementState controller_element = 2;
  bool has_controller_element() const;
  void clear_controller_element();
  static const int kControllerElementFieldNumber = 2;
  const ::Kinova::Api::Base::ControllerElementState& controller_element() const;
  ::Kinova::Api::Base::ControllerElementState* release_controller_element();
  ::Kinova::Api::Base::ControllerElementState* mutable_controller_element();
  void set_allocated_controller_element(::Kinova::Api::Base::ControllerElementState* controller_element);

  StateCase state_case() const;
  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ControllerNotification)
 private:
  void set_has_controller_state();
  void set_has_controller_element();

  inline bool has_state() const;
  void clear_state();
  inline void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  union StateUnion {
    StateUnion() {}
    ::Kinova::Api::Base::ControllerState* controller_state_;
    ::Kinova::Api::Base::ControllerElementState* controller_element_;
  } state_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsControllerNotificationImpl();
};
// -------------------------------------------------------------------

class ControllerList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ControllerList) */ {
 public:
  ControllerList();
  virtual ~ControllerList();

  ControllerList(const ControllerList& from);

  inline ControllerList& operator=(const ControllerList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerList(ControllerList&& from) noexcept
    : ControllerList() {
    *this = ::std::move(from);
  }

  inline ControllerList& operator=(ControllerList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerList* internal_default_instance() {
    return reinterpret_cast<const ControllerList*>(
               &_ControllerList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    74;

  void Swap(ControllerList* other);
  friend void swap(ControllerList& a, ControllerList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerList* New() const PROTOBUF_FINAL { return New(NULL); }

  ControllerList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControllerList& from);
  void MergeFrom(const ControllerList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControllerList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.ControllerHandle handles = 1;
  int handles_size() const;
  void clear_handles();
  static const int kHandlesFieldNumber = 1;
  const ::Kinova::Api::Base::ControllerHandle& handles(int index) const;
  ::Kinova::Api::Base::ControllerHandle* mutable_handles(int index);
  ::Kinova::Api::Base::ControllerHandle* add_handles();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerHandle >*
      mutable_handles();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerHandle >&
      handles() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ControllerList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerHandle > handles_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsControllerListImpl();
};
// -------------------------------------------------------------------

class ControllerState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ControllerState) */ {
 public:
  ControllerState();
  virtual ~ControllerState();

  ControllerState(const ControllerState& from);

  inline ControllerState& operator=(const ControllerState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerState(ControllerState&& from) noexcept
    : ControllerState() {
    *this = ::std::move(from);
  }

  inline ControllerState& operator=(ControllerState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerState* internal_default_instance() {
    return reinterpret_cast<const ControllerState*>(
               &_ControllerState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    75;

  void Swap(ControllerState* other);
  friend void swap(ControllerState& a, ControllerState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerState* New() const PROTOBUF_FINAL { return New(NULL); }

  ControllerState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControllerState& from);
  void MergeFrom(const ControllerState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControllerState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.ControllerHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Base::ControllerHandle& handle() const;
  ::Kinova::Api::Base::ControllerHandle* release_handle();
  ::Kinova::Api::Base::ControllerHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Base::ControllerHandle* handle);

  // .Kinova.Api.Base.ControllerEventType event_type = 2;
  void clear_event_type();
  static const int kEventTypeFieldNumber = 2;
  ::Kinova::Api::Base::ControllerEventType event_type() const;
  void set_event_type(::Kinova::Api::Base::ControllerEventType value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ControllerState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::ControllerHandle* handle_;
  int event_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsControllerStateImpl();
};
// -------------------------------------------------------------------

class ControllerElementState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ControllerElementState) */ {
 public:
  ControllerElementState();
  virtual ~ControllerElementState();

  ControllerElementState(const ControllerElementState& from);

  inline ControllerElementState& operator=(const ControllerElementState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerElementState(ControllerElementState&& from) noexcept
    : ControllerElementState() {
    *this = ::std::move(from);
  }

  inline ControllerElementState& operator=(ControllerElementState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerElementState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerElementState* internal_default_instance() {
    return reinterpret_cast<const ControllerElementState*>(
               &_ControllerElementState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    76;

  void Swap(ControllerElementState* other);
  friend void swap(ControllerElementState& a, ControllerElementState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerElementState* New() const PROTOBUF_FINAL { return New(NULL); }

  ControllerElementState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControllerElementState& from);
  void MergeFrom(const ControllerElementState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControllerElementState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.ControllerElementHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Base::ControllerElementHandle& handle() const;
  ::Kinova::Api::Base::ControllerElementHandle* release_handle();
  ::Kinova::Api::Base::ControllerElementHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Base::ControllerElementHandle* handle);

  // .Kinova.Api.Base.ControllerElementEventType event_type = 2;
  void clear_event_type();
  static const int kEventTypeFieldNumber = 2;
  ::Kinova::Api::Base::ControllerElementEventType event_type() const;
  void set_event_type(::Kinova::Api::Base::ControllerElementEventType value);

  // float axis_value = 3;
  void clear_axis_value();
  static const int kAxisValueFieldNumber = 3;
  float axis_value() const;
  void set_axis_value(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ControllerElementState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::ControllerElementHandle* handle_;
  int event_type_;
  float axis_value_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsControllerElementStateImpl();
};
// -------------------------------------------------------------------

class ActionNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ActionNotification) */ {
 public:
  ActionNotification();
  virtual ~ActionNotification();

  ActionNotification(const ActionNotification& from);

  inline ActionNotification& operator=(const ActionNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionNotification(ActionNotification&& from) noexcept
    : ActionNotification() {
    *this = ::std::move(from);
  }

  inline ActionNotification& operator=(ActionNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionNotification* internal_default_instance() {
    return reinterpret_cast<const ActionNotification*>(
               &_ActionNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    77;

  void Swap(ActionNotification* other);
  friend void swap(ActionNotification& a, ActionNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  ActionNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ActionNotification& from);
  void MergeFrom(const ActionNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ActionNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.TrajectoryInfo trajectory_info = 7;
  int trajectory_info_size() const;
  void clear_trajectory_info();
  static const int kTrajectoryInfoFieldNumber = 7;
  const ::Kinova::Api::Base::TrajectoryInfo& trajectory_info(int index) const;
  ::Kinova::Api::Base::TrajectoryInfo* mutable_trajectory_info(int index);
  ::Kinova::Api::Base::TrajectoryInfo* add_trajectory_info();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::TrajectoryInfo >*
      mutable_trajectory_info();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::TrajectoryInfo >&
      trajectory_info() const;

  // .Kinova.Api.Base.ActionHandle handle = 2;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 2;
  const ::Kinova::Api::Base::ActionHandle& handle() const;
  ::Kinova::Api::Base::ActionHandle* release_handle();
  ::Kinova::Api::Base::ActionHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Base::ActionHandle* handle);

  // .Kinova.Api.Common.Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 4;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 4;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 6;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 6;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Base.ActionEvent action_event = 1;
  void clear_action_event();
  static const int kActionEventFieldNumber = 1;
  ::Kinova::Api::Base::ActionEvent action_event() const;
  void set_action_event(::Kinova::Api::Base::ActionEvent value);

  // .Kinova.Api.SubErrorCodes abort_details = 5;
  void clear_abort_details();
  static const int kAbortDetailsFieldNumber = 5;
  ::Kinova::Api::SubErrorCodes abort_details() const;
  void set_abort_details(::Kinova::Api::SubErrorCodes value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ActionNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::TrajectoryInfo > trajectory_info_;
  ::Kinova::Api::Base::ActionHandle* handle_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  int action_event_;
  int abort_details_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsActionNotificationImpl();
};
// -------------------------------------------------------------------

class TrajectoryInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.TrajectoryInfo) */ {
 public:
  TrajectoryInfo();
  virtual ~TrajectoryInfo();

  TrajectoryInfo(const TrajectoryInfo& from);

  inline TrajectoryInfo& operator=(const TrajectoryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrajectoryInfo(TrajectoryInfo&& from) noexcept
    : TrajectoryInfo() {
    *this = ::std::move(from);
  }

  inline TrajectoryInfo& operator=(TrajectoryInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryInfo* internal_default_instance() {
    return reinterpret_cast<const TrajectoryInfo*>(
               &_TrajectoryInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    78;

  void Swap(TrajectoryInfo* other);
  friend void swap(TrajectoryInfo& a, TrajectoryInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  TrajectoryInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrajectoryInfo& from);
  void MergeFrom(const TrajectoryInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrajectoryInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.TrajectoryInfoType trajectory_info_type = 1;
  void clear_trajectory_info_type();
  static const int kTrajectoryInfoTypeFieldNumber = 1;
  ::Kinova::Api::Base::TrajectoryInfoType trajectory_info_type() const;
  void set_trajectory_info_type(::Kinova::Api::Base::TrajectoryInfoType value);

  // uint32 waypoint_index = 2;
  void clear_waypoint_index();
  static const int kWaypointIndexFieldNumber = 2;
  ::google::protobuf::uint32 waypoint_index() const;
  void set_waypoint_index(::google::protobuf::uint32 value);

  // uint32 joint_index = 3;
  void clear_joint_index();
  static const int kJointIndexFieldNumber = 3;
  ::google::protobuf::uint32 joint_index() const;
  void set_joint_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.TrajectoryInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int trajectory_info_type_;
  ::google::protobuf::uint32 waypoint_index_;
  ::google::protobuf::uint32 joint_index_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsTrajectoryInfoImpl();
};
// -------------------------------------------------------------------

class ActionExecutionState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ActionExecutionState) */ {
 public:
  ActionExecutionState();
  virtual ~ActionExecutionState();

  ActionExecutionState(const ActionExecutionState& from);

  inline ActionExecutionState& operator=(const ActionExecutionState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionExecutionState(ActionExecutionState&& from) noexcept
    : ActionExecutionState() {
    *this = ::std::move(from);
  }

  inline ActionExecutionState& operator=(ActionExecutionState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionExecutionState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionExecutionState* internal_default_instance() {
    return reinterpret_cast<const ActionExecutionState*>(
               &_ActionExecutionState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    79;

  void Swap(ActionExecutionState* other);
  friend void swap(ActionExecutionState& a, ActionExecutionState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionExecutionState* New() const PROTOBUF_FINAL { return New(NULL); }

  ActionExecutionState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ActionExecutionState& from);
  void MergeFrom(const ActionExecutionState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ActionExecutionState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.ActionHandle handle = 2;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 2;
  const ::Kinova::Api::Base::ActionHandle& handle() const;
  ::Kinova::Api::Base::ActionHandle* release_handle();
  ::Kinova::Api::Base::ActionHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Base::ActionHandle* handle);

  // .Kinova.Api.Base.ActionEvent action_event = 1;
  void clear_action_event();
  static const int kActionEventFieldNumber = 1;
  ::Kinova::Api::Base::ActionEvent action_event() const;
  void set_action_event(::Kinova::Api::Base::ActionEvent value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ActionExecutionState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::ActionHandle* handle_;
  int action_event_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsActionExecutionStateImpl();
};
// -------------------------------------------------------------------

class RobotEventNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.RobotEventNotification) */ {
 public:
  RobotEventNotification();
  virtual ~RobotEventNotification();

  RobotEventNotification(const RobotEventNotification& from);

  inline RobotEventNotification& operator=(const RobotEventNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotEventNotification(RobotEventNotification&& from) noexcept
    : RobotEventNotification() {
    *this = ::std::move(from);
  }

  inline RobotEventNotification& operator=(RobotEventNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotEventNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotEventNotification* internal_default_instance() {
    return reinterpret_cast<const RobotEventNotification*>(
               &_RobotEventNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    80;

  void Swap(RobotEventNotification* other);
  friend void swap(RobotEventNotification& a, RobotEventNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotEventNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  RobotEventNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RobotEventNotification& from);
  void MergeFrom(const RobotEventNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RobotEventNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.DeviceHandle handle = 2;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 2;
  const ::Kinova::Api::Common::DeviceHandle& handle() const;
  ::Kinova::Api::Common::DeviceHandle* release_handle();
  ::Kinova::Api::Common::DeviceHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Common::DeviceHandle* handle);

  // .Kinova.Api.Common.Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 4;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 4;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 6;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 6;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Base.RobotEvent event = 1;
  void clear_event();
  static const int kEventFieldNumber = 1;
  ::Kinova::Api::Base::RobotEvent event() const;
  void set_event(::Kinova::Api::Base::RobotEvent value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.RobotEventNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::DeviceHandle* handle_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  int event_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsRobotEventNotificationImpl();
};
// -------------------------------------------------------------------

class FactoryNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.FactoryNotification) */ {
 public:
  FactoryNotification();
  virtual ~FactoryNotification();

  FactoryNotification(const FactoryNotification& from);

  inline FactoryNotification& operator=(const FactoryNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FactoryNotification(FactoryNotification&& from) noexcept
    : FactoryNotification() {
    *this = ::std::move(from);
  }

  inline FactoryNotification& operator=(FactoryNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FactoryNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FactoryNotification* internal_default_instance() {
    return reinterpret_cast<const FactoryNotification*>(
               &_FactoryNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    81;

  void Swap(FactoryNotification* other);
  friend void swap(FactoryNotification& a, FactoryNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FactoryNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  FactoryNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FactoryNotification& from);
  void MergeFrom(const FactoryNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FactoryNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.Timestamp timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 3;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 3;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 4;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 4;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Base.FactoryEvent event = 1;
  void clear_event();
  static const int kEventFieldNumber = 1;
  ::Kinova::Api::Base::FactoryEvent event() const;
  void set_event(::Kinova::Api::Base::FactoryEvent value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.FactoryNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  int event_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsFactoryNotificationImpl();
};
// -------------------------------------------------------------------

class NetworkNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.NetworkNotification) */ {
 public:
  NetworkNotification();
  virtual ~NetworkNotification();

  NetworkNotification(const NetworkNotification& from);

  inline NetworkNotification& operator=(const NetworkNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkNotification(NetworkNotification&& from) noexcept
    : NetworkNotification() {
    *this = ::std::move(from);
  }

  inline NetworkNotification& operator=(NetworkNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkNotification* internal_default_instance() {
    return reinterpret_cast<const NetworkNotification*>(
               &_NetworkNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    82;

  void Swap(NetworkNotification* other);
  friend void swap(NetworkNotification& a, NetworkNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetworkNotification& from);
  void MergeFrom(const NetworkNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetworkNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.Timestamp timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 3;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 3;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 4;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 4;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Base.NetworkEvent event = 1;
  void clear_event();
  static const int kEventFieldNumber = 1;
  ::Kinova::Api::Base::NetworkEvent event() const;
  void set_event(::Kinova::Api::Base::NetworkEvent value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.NetworkNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  int event_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsNetworkNotificationImpl();
};
// -------------------------------------------------------------------

class ConfigurationChangeNotificationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ConfigurationChangeNotificationList) */ {
 public:
  ConfigurationChangeNotificationList();
  virtual ~ConfigurationChangeNotificationList();

  ConfigurationChangeNotificationList(const ConfigurationChangeNotificationList& from);

  inline ConfigurationChangeNotificationList& operator=(const ConfigurationChangeNotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConfigurationChangeNotificationList(ConfigurationChangeNotificationList&& from) noexcept
    : ConfigurationChangeNotificationList() {
    *this = ::std::move(from);
  }

  inline ConfigurationChangeNotificationList& operator=(ConfigurationChangeNotificationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigurationChangeNotificationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigurationChangeNotificationList* internal_default_instance() {
    return reinterpret_cast<const ConfigurationChangeNotificationList*>(
               &_ConfigurationChangeNotificationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    83;

  void Swap(ConfigurationChangeNotificationList* other);
  friend void swap(ConfigurationChangeNotificationList& a, ConfigurationChangeNotificationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConfigurationChangeNotificationList* New() const PROTOBUF_FINAL { return New(NULL); }

  ConfigurationChangeNotificationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConfigurationChangeNotificationList& from);
  void MergeFrom(const ConfigurationChangeNotificationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConfigurationChangeNotificationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.ConfigurationChangeNotification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  const ::Kinova::Api::Base::ConfigurationChangeNotification& notifications(int index) const;
  ::Kinova::Api::Base::ConfigurationChangeNotification* mutable_notifications(int index);
  ::Kinova::Api::Base::ConfigurationChangeNotification* add_notifications();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ConfigurationChangeNotification >*
      mutable_notifications();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ConfigurationChangeNotification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ConfigurationChangeNotificationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ConfigurationChangeNotification > notifications_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsConfigurationChangeNotificationListImpl();
};
// -------------------------------------------------------------------

class MappingInfoNotificationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.MappingInfoNotificationList) */ {
 public:
  MappingInfoNotificationList();
  virtual ~MappingInfoNotificationList();

  MappingInfoNotificationList(const MappingInfoNotificationList& from);

  inline MappingInfoNotificationList& operator=(const MappingInfoNotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MappingInfoNotificationList(MappingInfoNotificationList&& from) noexcept
    : MappingInfoNotificationList() {
    *this = ::std::move(from);
  }

  inline MappingInfoNotificationList& operator=(MappingInfoNotificationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MappingInfoNotificationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MappingInfoNotificationList* internal_default_instance() {
    return reinterpret_cast<const MappingInfoNotificationList*>(
               &_MappingInfoNotificationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    84;

  void Swap(MappingInfoNotificationList* other);
  friend void swap(MappingInfoNotificationList& a, MappingInfoNotificationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MappingInfoNotificationList* New() const PROTOBUF_FINAL { return New(NULL); }

  MappingInfoNotificationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MappingInfoNotificationList& from);
  void MergeFrom(const MappingInfoNotificationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MappingInfoNotificationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.MappingInfoNotification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  const ::Kinova::Api::Base::MappingInfoNotification& notifications(int index) const;
  ::Kinova::Api::Base::MappingInfoNotification* mutable_notifications(int index);
  ::Kinova::Api::Base::MappingInfoNotification* add_notifications();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MappingInfoNotification >*
      mutable_notifications();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MappingInfoNotification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.MappingInfoNotificationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MappingInfoNotification > notifications_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsMappingInfoNotificationListImpl();
};
// -------------------------------------------------------------------

class ControlModeNotificationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ControlModeNotificationList) */ {
 public:
  ControlModeNotificationList();
  virtual ~ControlModeNotificationList();

  ControlModeNotificationList(const ControlModeNotificationList& from);

  inline ControlModeNotificationList& operator=(const ControlModeNotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlModeNotificationList(ControlModeNotificationList&& from) noexcept
    : ControlModeNotificationList() {
    *this = ::std::move(from);
  }

  inline ControlModeNotificationList& operator=(ControlModeNotificationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlModeNotificationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlModeNotificationList* internal_default_instance() {
    return reinterpret_cast<const ControlModeNotificationList*>(
               &_ControlModeNotificationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    85;

  void Swap(ControlModeNotificationList* other);
  friend void swap(ControlModeNotificationList& a, ControlModeNotificationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlModeNotificationList* New() const PROTOBUF_FINAL { return New(NULL); }

  ControlModeNotificationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControlModeNotificationList& from);
  void MergeFrom(const ControlModeNotificationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControlModeNotificationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.ControlModeNotification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  const ::Kinova::Api::Base::ControlModeNotification& notifications(int index) const;
  ::Kinova::Api::Base::ControlModeNotification* mutable_notifications(int index);
  ::Kinova::Api::Base::ControlModeNotification* add_notifications();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControlModeNotification >*
      mutable_notifications();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControlModeNotification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ControlModeNotificationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControlModeNotification > notifications_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsControlModeNotificationListImpl();
};
// -------------------------------------------------------------------

class OperatingModeNotificationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.OperatingModeNotificationList) */ {
 public:
  OperatingModeNotificationList();
  virtual ~OperatingModeNotificationList();

  OperatingModeNotificationList(const OperatingModeNotificationList& from);

  inline OperatingModeNotificationList& operator=(const OperatingModeNotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperatingModeNotificationList(OperatingModeNotificationList&& from) noexcept
    : OperatingModeNotificationList() {
    *this = ::std::move(from);
  }

  inline OperatingModeNotificationList& operator=(OperatingModeNotificationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperatingModeNotificationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperatingModeNotificationList* internal_default_instance() {
    return reinterpret_cast<const OperatingModeNotificationList*>(
               &_OperatingModeNotificationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    86;

  void Swap(OperatingModeNotificationList* other);
  friend void swap(OperatingModeNotificationList& a, OperatingModeNotificationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperatingModeNotificationList* New() const PROTOBUF_FINAL { return New(NULL); }

  OperatingModeNotificationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperatingModeNotificationList& from);
  void MergeFrom(const OperatingModeNotificationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperatingModeNotificationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.OperatingModeNotification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  const ::Kinova::Api::Base::OperatingModeNotification& notifications(int index) const;
  ::Kinova::Api::Base::OperatingModeNotification* mutable_notifications(int index);
  ::Kinova::Api::Base::OperatingModeNotification* add_notifications();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::OperatingModeNotification >*
      mutable_notifications();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::OperatingModeNotification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.OperatingModeNotificationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::OperatingModeNotification > notifications_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsOperatingModeNotificationListImpl();
};
// -------------------------------------------------------------------

class ServoingModeNotificationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ServoingModeNotificationList) */ {
 public:
  ServoingModeNotificationList();
  virtual ~ServoingModeNotificationList();

  ServoingModeNotificationList(const ServoingModeNotificationList& from);

  inline ServoingModeNotificationList& operator=(const ServoingModeNotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServoingModeNotificationList(ServoingModeNotificationList&& from) noexcept
    : ServoingModeNotificationList() {
    *this = ::std::move(from);
  }

  inline ServoingModeNotificationList& operator=(ServoingModeNotificationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServoingModeNotificationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServoingModeNotificationList* internal_default_instance() {
    return reinterpret_cast<const ServoingModeNotificationList*>(
               &_ServoingModeNotificationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    87;

  void Swap(ServoingModeNotificationList* other);
  friend void swap(ServoingModeNotificationList& a, ServoingModeNotificationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServoingModeNotificationList* New() const PROTOBUF_FINAL { return New(NULL); }

  ServoingModeNotificationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServoingModeNotificationList& from);
  void MergeFrom(const ServoingModeNotificationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServoingModeNotificationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.ServoingModeNotification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  const ::Kinova::Api::Base::ServoingModeNotification& notifications(int index) const;
  ::Kinova::Api::Base::ServoingModeNotification* mutable_notifications(int index);
  ::Kinova::Api::Base::ServoingModeNotification* add_notifications();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ServoingModeNotification >*
      mutable_notifications();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ServoingModeNotification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ServoingModeNotificationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ServoingModeNotification > notifications_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsServoingModeNotificationListImpl();
};
// -------------------------------------------------------------------

class SequenceInfoNotificationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SequenceInfoNotificationList) */ {
 public:
  SequenceInfoNotificationList();
  virtual ~SequenceInfoNotificationList();

  SequenceInfoNotificationList(const SequenceInfoNotificationList& from);

  inline SequenceInfoNotificationList& operator=(const SequenceInfoNotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SequenceInfoNotificationList(SequenceInfoNotificationList&& from) noexcept
    : SequenceInfoNotificationList() {
    *this = ::std::move(from);
  }

  inline SequenceInfoNotificationList& operator=(SequenceInfoNotificationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceInfoNotificationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SequenceInfoNotificationList* internal_default_instance() {
    return reinterpret_cast<const SequenceInfoNotificationList*>(
               &_SequenceInfoNotificationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    88;

  void Swap(SequenceInfoNotificationList* other);
  friend void swap(SequenceInfoNotificationList& a, SequenceInfoNotificationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SequenceInfoNotificationList* New() const PROTOBUF_FINAL { return New(NULL); }

  SequenceInfoNotificationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SequenceInfoNotificationList& from);
  void MergeFrom(const SequenceInfoNotificationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SequenceInfoNotificationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.SequenceInfoNotification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  const ::Kinova::Api::Base::SequenceInfoNotification& notifications(int index) const;
  ::Kinova::Api::Base::SequenceInfoNotification* mutable_notifications(int index);
  ::Kinova::Api::Base::SequenceInfoNotification* add_notifications();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceInfoNotification >*
      mutable_notifications();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceInfoNotification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SequenceInfoNotificationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceInfoNotification > notifications_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSequenceInfoNotificationListImpl();
};
// -------------------------------------------------------------------

class ProtectionZoneNotificationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ProtectionZoneNotificationList) */ {
 public:
  ProtectionZoneNotificationList();
  virtual ~ProtectionZoneNotificationList();

  ProtectionZoneNotificationList(const ProtectionZoneNotificationList& from);

  inline ProtectionZoneNotificationList& operator=(const ProtectionZoneNotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtectionZoneNotificationList(ProtectionZoneNotificationList&& from) noexcept
    : ProtectionZoneNotificationList() {
    *this = ::std::move(from);
  }

  inline ProtectionZoneNotificationList& operator=(ProtectionZoneNotificationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtectionZoneNotificationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtectionZoneNotificationList* internal_default_instance() {
    return reinterpret_cast<const ProtectionZoneNotificationList*>(
               &_ProtectionZoneNotificationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    89;

  void Swap(ProtectionZoneNotificationList* other);
  friend void swap(ProtectionZoneNotificationList& a, ProtectionZoneNotificationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtectionZoneNotificationList* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtectionZoneNotificationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtectionZoneNotificationList& from);
  void MergeFrom(const ProtectionZoneNotificationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtectionZoneNotificationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.ProtectionZoneNotification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  const ::Kinova::Api::Base::ProtectionZoneNotification& notifications(int index) const;
  ::Kinova::Api::Base::ProtectionZoneNotification* mutable_notifications(int index);
  ::Kinova::Api::Base::ProtectionZoneNotification* add_notifications();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ProtectionZoneNotification >*
      mutable_notifications();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ProtectionZoneNotification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ProtectionZoneNotificationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ProtectionZoneNotification > notifications_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsProtectionZoneNotificationListImpl();
};
// -------------------------------------------------------------------

class UserNotificationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.UserNotificationList) */ {
 public:
  UserNotificationList();
  virtual ~UserNotificationList();

  UserNotificationList(const UserNotificationList& from);

  inline UserNotificationList& operator=(const UserNotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserNotificationList(UserNotificationList&& from) noexcept
    : UserNotificationList() {
    *this = ::std::move(from);
  }

  inline UserNotificationList& operator=(UserNotificationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserNotificationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserNotificationList* internal_default_instance() {
    return reinterpret_cast<const UserNotificationList*>(
               &_UserNotificationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    90;

  void Swap(UserNotificationList* other);
  friend void swap(UserNotificationList& a, UserNotificationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserNotificationList* New() const PROTOBUF_FINAL { return New(NULL); }

  UserNotificationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserNotificationList& from);
  void MergeFrom(const UserNotificationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserNotificationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.UserNotification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  const ::Kinova::Api::Base::UserNotification& notifications(int index) const;
  ::Kinova::Api::Base::UserNotification* mutable_notifications(int index);
  ::Kinova::Api::Base::UserNotification* add_notifications();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::UserNotification >*
      mutable_notifications();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::UserNotification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.UserNotificationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::UserNotification > notifications_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsUserNotificationListImpl();
};
// -------------------------------------------------------------------

class SafetyNotificationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SafetyNotificationList) */ {
 public:
  SafetyNotificationList();
  virtual ~SafetyNotificationList();

  SafetyNotificationList(const SafetyNotificationList& from);

  inline SafetyNotificationList& operator=(const SafetyNotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SafetyNotificationList(SafetyNotificationList&& from) noexcept
    : SafetyNotificationList() {
    *this = ::std::move(from);
  }

  inline SafetyNotificationList& operator=(SafetyNotificationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyNotificationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SafetyNotificationList* internal_default_instance() {
    return reinterpret_cast<const SafetyNotificationList*>(
               &_SafetyNotificationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    91;

  void Swap(SafetyNotificationList* other);
  friend void swap(SafetyNotificationList& a, SafetyNotificationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SafetyNotificationList* New() const PROTOBUF_FINAL { return New(NULL); }

  SafetyNotificationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SafetyNotificationList& from);
  void MergeFrom(const SafetyNotificationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SafetyNotificationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Common.SafetyNotification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  const ::Kinova::Api::Common::SafetyNotification& notifications(int index) const;
  ::Kinova::Api::Common::SafetyNotification* mutable_notifications(int index);
  ::Kinova::Api::Common::SafetyNotification* add_notifications();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Common::SafetyNotification >*
      mutable_notifications();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Common::SafetyNotification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SafetyNotificationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Common::SafetyNotification > notifications_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSafetyNotificationListImpl();
};
// -------------------------------------------------------------------

class ControllerNotificationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ControllerNotificationList) */ {
 public:
  ControllerNotificationList();
  virtual ~ControllerNotificationList();

  ControllerNotificationList(const ControllerNotificationList& from);

  inline ControllerNotificationList& operator=(const ControllerNotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerNotificationList(ControllerNotificationList&& from) noexcept
    : ControllerNotificationList() {
    *this = ::std::move(from);
  }

  inline ControllerNotificationList& operator=(ControllerNotificationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerNotificationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerNotificationList* internal_default_instance() {
    return reinterpret_cast<const ControllerNotificationList*>(
               &_ControllerNotificationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    92;

  void Swap(ControllerNotificationList* other);
  friend void swap(ControllerNotificationList& a, ControllerNotificationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerNotificationList* New() const PROTOBUF_FINAL { return New(NULL); }

  ControllerNotificationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControllerNotificationList& from);
  void MergeFrom(const ControllerNotificationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControllerNotificationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.ControllerNotification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  const ::Kinova::Api::Base::ControllerNotification& notifications(int index) const;
  ::Kinova::Api::Base::ControllerNotification* mutable_notifications(int index);
  ::Kinova::Api::Base::ControllerNotification* add_notifications();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerNotification >*
      mutable_notifications();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerNotification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ControllerNotificationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerNotification > notifications_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsControllerNotificationListImpl();
};
// -------------------------------------------------------------------

class ActionNotificationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ActionNotificationList) */ {
 public:
  ActionNotificationList();
  virtual ~ActionNotificationList();

  ActionNotificationList(const ActionNotificationList& from);

  inline ActionNotificationList& operator=(const ActionNotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionNotificationList(ActionNotificationList&& from) noexcept
    : ActionNotificationList() {
    *this = ::std::move(from);
  }

  inline ActionNotificationList& operator=(ActionNotificationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionNotificationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionNotificationList* internal_default_instance() {
    return reinterpret_cast<const ActionNotificationList*>(
               &_ActionNotificationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    93;

  void Swap(ActionNotificationList* other);
  friend void swap(ActionNotificationList& a, ActionNotificationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionNotificationList* New() const PROTOBUF_FINAL { return New(NULL); }

  ActionNotificationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ActionNotificationList& from);
  void MergeFrom(const ActionNotificationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ActionNotificationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.ActionNotification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  const ::Kinova::Api::Base::ActionNotification& notifications(int index) const;
  ::Kinova::Api::Base::ActionNotification* mutable_notifications(int index);
  ::Kinova::Api::Base::ActionNotification* add_notifications();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ActionNotification >*
      mutable_notifications();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ActionNotification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ActionNotificationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ActionNotification > notifications_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsActionNotificationListImpl();
};
// -------------------------------------------------------------------

class RobotEventNotificationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.RobotEventNotificationList) */ {
 public:
  RobotEventNotificationList();
  virtual ~RobotEventNotificationList();

  RobotEventNotificationList(const RobotEventNotificationList& from);

  inline RobotEventNotificationList& operator=(const RobotEventNotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotEventNotificationList(RobotEventNotificationList&& from) noexcept
    : RobotEventNotificationList() {
    *this = ::std::move(from);
  }

  inline RobotEventNotificationList& operator=(RobotEventNotificationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotEventNotificationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotEventNotificationList* internal_default_instance() {
    return reinterpret_cast<const RobotEventNotificationList*>(
               &_RobotEventNotificationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    94;

  void Swap(RobotEventNotificationList* other);
  friend void swap(RobotEventNotificationList& a, RobotEventNotificationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotEventNotificationList* New() const PROTOBUF_FINAL { return New(NULL); }

  RobotEventNotificationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RobotEventNotificationList& from);
  void MergeFrom(const RobotEventNotificationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RobotEventNotificationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.RobotEventNotification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  const ::Kinova::Api::Base::RobotEventNotification& notifications(int index) const;
  ::Kinova::Api::Base::RobotEventNotification* mutable_notifications(int index);
  ::Kinova::Api::Base::RobotEventNotification* add_notifications();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::RobotEventNotification >*
      mutable_notifications();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::RobotEventNotification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.RobotEventNotificationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::RobotEventNotification > notifications_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsRobotEventNotificationListImpl();
};
// -------------------------------------------------------------------

class NetworkNotificationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.NetworkNotificationList) */ {
 public:
  NetworkNotificationList();
  virtual ~NetworkNotificationList();

  NetworkNotificationList(const NetworkNotificationList& from);

  inline NetworkNotificationList& operator=(const NetworkNotificationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkNotificationList(NetworkNotificationList&& from) noexcept
    : NetworkNotificationList() {
    *this = ::std::move(from);
  }

  inline NetworkNotificationList& operator=(NetworkNotificationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkNotificationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkNotificationList* internal_default_instance() {
    return reinterpret_cast<const NetworkNotificationList*>(
               &_NetworkNotificationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    95;

  void Swap(NetworkNotificationList* other);
  friend void swap(NetworkNotificationList& a, NetworkNotificationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkNotificationList* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkNotificationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetworkNotificationList& from);
  void MergeFrom(const NetworkNotificationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetworkNotificationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.NetworkNotification notifications = 1;
  int notifications_size() const;
  void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  const ::Kinova::Api::Base::NetworkNotification& notifications(int index) const;
  ::Kinova::Api::Base::NetworkNotification* mutable_notifications(int index);
  ::Kinova::Api::Base::NetworkNotification* add_notifications();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::NetworkNotification >*
      mutable_notifications();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::NetworkNotification >&
      notifications() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.NetworkNotificationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::NetworkNotification > notifications_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsNetworkNotificationListImpl();
};
// -------------------------------------------------------------------

class MappingHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.MappingHandle) */ {
 public:
  MappingHandle();
  virtual ~MappingHandle();

  MappingHandle(const MappingHandle& from);

  inline MappingHandle& operator=(const MappingHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MappingHandle(MappingHandle&& from) noexcept
    : MappingHandle() {
    *this = ::std::move(from);
  }

  inline MappingHandle& operator=(MappingHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MappingHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MappingHandle* internal_default_instance() {
    return reinterpret_cast<const MappingHandle*>(
               &_MappingHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    96;

  void Swap(MappingHandle* other);
  friend void swap(MappingHandle& a, MappingHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MappingHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  MappingHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MappingHandle& from);
  void MergeFrom(const MappingHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MappingHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 identifier() const;
  void set_identifier(::google::protobuf::uint32 value);

  // fixed32 permission = 2;
  void clear_permission();
  static const int kPermissionFieldNumber = 2;
  ::google::protobuf::uint32 permission() const;
  void set_permission(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.MappingHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 identifier_;
  ::google::protobuf::uint32 permission_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsMappingHandleImpl();
};
// -------------------------------------------------------------------

class SafetyEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SafetyEvent) */ {
 public:
  SafetyEvent();
  virtual ~SafetyEvent();

  SafetyEvent(const SafetyEvent& from);

  inline SafetyEvent& operator=(const SafetyEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SafetyEvent(SafetyEvent&& from) noexcept
    : SafetyEvent() {
    *this = ::std::move(from);
  }

  inline SafetyEvent& operator=(SafetyEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SafetyEvent* internal_default_instance() {
    return reinterpret_cast<const SafetyEvent*>(
               &_SafetyEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    97;

  void Swap(SafetyEvent* other);
  friend void swap(SafetyEvent& a, SafetyEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SafetyEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  SafetyEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SafetyEvent& from);
  void MergeFrom(const SafetyEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SafetyEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.SafetyHandle safety_handle = 1;
  bool has_safety_handle() const;
  void clear_safety_handle();
  static const int kSafetyHandleFieldNumber = 1;
  const ::Kinova::Api::Common::SafetyHandle& safety_handle() const;
  ::Kinova::Api::Common::SafetyHandle* release_safety_handle();
  ::Kinova::Api::Common::SafetyHandle* mutable_safety_handle();
  void set_allocated_safety_handle(::Kinova::Api::Common::SafetyHandle* safety_handle);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SafetyEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::SafetyHandle* safety_handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSafetyEventImpl();
};
// -------------------------------------------------------------------

class ControllerEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ControllerEvent) */ {
 public:
  ControllerEvent();
  virtual ~ControllerEvent();

  ControllerEvent(const ControllerEvent& from);

  inline ControllerEvent& operator=(const ControllerEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerEvent(ControllerEvent&& from) noexcept
    : ControllerEvent() {
    *this = ::std::move(from);
  }

  inline ControllerEvent& operator=(ControllerEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerEvent* internal_default_instance() {
    return reinterpret_cast<const ControllerEvent*>(
               &_ControllerEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    98;

  void Swap(ControllerEvent* other);
  friend void swap(ControllerEvent& a, ControllerEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  ControllerEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControllerEvent& from);
  void MergeFrom(const ControllerEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControllerEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.ControllerInputType input_type = 1;
  void clear_input_type();
  static const int kInputTypeFieldNumber = 1;
  ::Kinova::Api::Base::ControllerInputType input_type() const;
  void set_input_type(::Kinova::Api::Base::ControllerInputType value);

  // .Kinova.Api.Base.ControllerBehavior behavior = 2;
  void clear_behavior();
  static const int kBehaviorFieldNumber = 2;
  ::Kinova::Api::Base::ControllerBehavior behavior() const;
  void set_behavior(::Kinova::Api::Base::ControllerBehavior value);

  // uint32 input_identifier = 3;
  void clear_input_identifier();
  static const int kInputIdentifierFieldNumber = 3;
  ::google::protobuf::uint32 input_identifier() const;
  void set_input_identifier(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ControllerEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int input_type_;
  int behavior_;
  ::google::protobuf::uint32 input_identifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsControllerEventImpl();
};
// -------------------------------------------------------------------

class GpioEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.GpioEvent) */ {
 public:
  GpioEvent();
  virtual ~GpioEvent();

  GpioEvent(const GpioEvent& from);

  inline GpioEvent& operator=(const GpioEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GpioEvent(GpioEvent&& from) noexcept
    : GpioEvent() {
    *this = ::std::move(from);
  }

  inline GpioEvent& operator=(GpioEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpioEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GpioEvent* internal_default_instance() {
    return reinterpret_cast<const GpioEvent*>(
               &_GpioEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    99;

  void Swap(GpioEvent* other);
  friend void swap(GpioEvent& a, GpioEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GpioEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  GpioEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GpioEvent& from);
  void MergeFrom(const GpioEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GpioEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.ControllerInputType input_type = 1;
  void clear_input_type();
  static const int kInputTypeFieldNumber = 1;
  ::Kinova::Api::Base::ControllerInputType input_type() const;
  void set_input_type(::Kinova::Api::Base::ControllerInputType value);

  // .Kinova.Api.Base.GpioBehavior behavior = 2;
  void clear_behavior();
  static const int kBehaviorFieldNumber = 2;
  ::Kinova::Api::Base::GpioBehavior behavior() const;
  void set_behavior(::Kinova::Api::Base::GpioBehavior value);

  // uint32 input_identifier = 3;
  void clear_input_identifier();
  static const int kInputIdentifierFieldNumber = 3;
  ::google::protobuf::uint32 input_identifier() const;
  void set_input_identifier(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.GpioEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int input_type_;
  int behavior_;
  ::google::protobuf::uint32 input_identifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsGpioEventImpl();
};
// -------------------------------------------------------------------

class MapEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.MapEvent) */ {
 public:
  MapEvent();
  virtual ~MapEvent();

  MapEvent(const MapEvent& from);

  inline MapEvent& operator=(const MapEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapEvent(MapEvent&& from) noexcept
    : MapEvent() {
    *this = ::std::move(from);
  }

  inline MapEvent& operator=(MapEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapEvent& default_instance();

  enum EventsCase {
    kSafetyEvent = 1,
    kGpioEvent = 2,
    kControllerEvent = 3,
    EVENTS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapEvent* internal_default_instance() {
    return reinterpret_cast<const MapEvent*>(
               &_MapEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    100;

  void Swap(MapEvent* other);
  friend void swap(MapEvent& a, MapEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  MapEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapEvent& from);
  void MergeFrom(const MapEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 4;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Kinova.Api.Base.SafetyEvent safety_event = 1;
  bool has_safety_event() const;
  void clear_safety_event();
  static const int kSafetyEventFieldNumber = 1;
  const ::Kinova::Api::Base::SafetyEvent& safety_event() const;
  ::Kinova::Api::Base::SafetyEvent* release_safety_event();
  ::Kinova::Api::Base::SafetyEvent* mutable_safety_event();
  void set_allocated_safety_event(::Kinova::Api::Base::SafetyEvent* safety_event);

  // .Kinova.Api.Base.GpioEvent gpio_event = 2;
  bool has_gpio_event() const;
  void clear_gpio_event();
  static const int kGpioEventFieldNumber = 2;
  const ::Kinova::Api::Base::GpioEvent& gpio_event() const;
  ::Kinova::Api::Base::GpioEvent* release_gpio_event();
  ::Kinova::Api::Base::GpioEvent* mutable_gpio_event();
  void set_allocated_gpio_event(::Kinova::Api::Base::GpioEvent* gpio_event);

  // .Kinova.Api.Base.ControllerEvent controller_event = 3;
  bool has_controller_event() const;
  void clear_controller_event();
  static const int kControllerEventFieldNumber = 3;
  const ::Kinova::Api::Base::ControllerEvent& controller_event() const;
  ::Kinova::Api::Base::ControllerEvent* release_controller_event();
  ::Kinova::Api::Base::ControllerEvent* mutable_controller_event();
  void set_allocated_controller_event(::Kinova::Api::Base::ControllerEvent* controller_event);

  EventsCase events_case() const;
  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.MapEvent)
 private:
  void set_has_safety_event();
  void set_has_gpio_event();
  void set_has_controller_event();

  inline bool has_events() const;
  void clear_events();
  inline void clear_has_events();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  union EventsUnion {
    EventsUnion() {}
    ::Kinova::Api::Base::SafetyEvent* safety_event_;
    ::Kinova::Api::Base::GpioEvent* gpio_event_;
    ::Kinova::Api::Base::ControllerEvent* controller_event_;
  } events_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsMapEventImpl();
};
// -------------------------------------------------------------------

class MapElement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.MapElement) */ {
 public:
  MapElement();
  virtual ~MapElement();

  MapElement(const MapElement& from);

  inline MapElement& operator=(const MapElement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapElement(MapElement&& from) noexcept
    : MapElement() {
    *this = ::std::move(from);
  }

  inline MapElement& operator=(MapElement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapElement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapElement* internal_default_instance() {
    return reinterpret_cast<const MapElement*>(
               &_MapElement_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    101;

  void Swap(MapElement* other);
  friend void swap(MapElement& a, MapElement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapElement* New() const PROTOBUF_FINAL { return New(NULL); }

  MapElement* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapElement& from);
  void MergeFrom(const MapElement& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Kinova.Api.Base.MapEvent event = 1;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 1;
  const ::Kinova::Api::Base::MapEvent& event() const;
  ::Kinova::Api::Base::MapEvent* release_event();
  ::Kinova::Api::Base::MapEvent* mutable_event();
  void set_allocated_event(::Kinova::Api::Base::MapEvent* event);

  // .Kinova.Api.Base.Action action = 2;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 2;
  const ::Kinova::Api::Base::Action& action() const;
  ::Kinova::Api::Base::Action* release_action();
  ::Kinova::Api::Base::Action* mutable_action();
  void set_allocated_action(::Kinova::Api::Base::Action* action);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.MapElement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Kinova::Api::Base::MapEvent* event_;
  ::Kinova::Api::Base::Action* action_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsMapElementImpl();
};
// -------------------------------------------------------------------

class ActivateMapHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ActivateMapHandle) */ {
 public:
  ActivateMapHandle();
  virtual ~ActivateMapHandle();

  ActivateMapHandle(const ActivateMapHandle& from);

  inline ActivateMapHandle& operator=(const ActivateMapHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActivateMapHandle(ActivateMapHandle&& from) noexcept
    : ActivateMapHandle() {
    *this = ::std::move(from);
  }

  inline ActivateMapHandle& operator=(ActivateMapHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActivateMapHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActivateMapHandle* internal_default_instance() {
    return reinterpret_cast<const ActivateMapHandle*>(
               &_ActivateMapHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    102;

  void Swap(ActivateMapHandle* other);
  friend void swap(ActivateMapHandle& a, ActivateMapHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActivateMapHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivateMapHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ActivateMapHandle& from);
  void MergeFrom(const ActivateMapHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ActivateMapHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.MappingHandle mapping_handle = 1;
  bool has_mapping_handle() const;
  void clear_mapping_handle();
  static const int kMappingHandleFieldNumber = 1;
  const ::Kinova::Api::Base::MappingHandle& mapping_handle() const;
  ::Kinova::Api::Base::MappingHandle* release_mapping_handle();
  ::Kinova::Api::Base::MappingHandle* mutable_mapping_handle();
  void set_allocated_mapping_handle(::Kinova::Api::Base::MappingHandle* mapping_handle);

  // .Kinova.Api.Base.MapGroupHandle map_group_handle = 2;
  bool has_map_group_handle() const;
  void clear_map_group_handle();
  static const int kMapGroupHandleFieldNumber = 2;
  const ::Kinova::Api::Base::MapGroupHandle& map_group_handle() const;
  ::Kinova::Api::Base::MapGroupHandle* release_map_group_handle();
  ::Kinova::Api::Base::MapGroupHandle* mutable_map_group_handle();
  void set_allocated_map_group_handle(::Kinova::Api::Base::MapGroupHandle* map_group_handle);

  // .Kinova.Api.Base.MapHandle map_handle = 3;
  bool has_map_handle() const;
  void clear_map_handle();
  static const int kMapHandleFieldNumber = 3;
  const ::Kinova::Api::Base::MapHandle& map_handle() const;
  ::Kinova::Api::Base::MapHandle* release_map_handle();
  ::Kinova::Api::Base::MapHandle* mutable_map_handle();
  void set_allocated_map_handle(::Kinova::Api::Base::MapHandle* map_handle);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ActivateMapHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::MappingHandle* mapping_handle_;
  ::Kinova::Api::Base::MapGroupHandle* map_group_handle_;
  ::Kinova::Api::Base::MapHandle* map_handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsActivateMapHandleImpl();
};
// -------------------------------------------------------------------

class Map : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Map) */ {
 public:
  Map();
  virtual ~Map();

  Map(const Map& from);

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Map(Map&& from) noexcept
    : Map() {
    *this = ::std::move(from);
  }

  inline Map& operator=(Map&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Map& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Map* internal_default_instance() {
    return reinterpret_cast<const Map*>(
               &_Map_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    103;

  void Swap(Map* other);
  friend void swap(Map& a, Map& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Map* New() const PROTOBUF_FINAL { return New(NULL); }

  Map* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Map& from);
  void MergeFrom(const Map& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Map* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.MapElement elements = 3;
  int elements_size() const;
  void clear_elements();
  static const int kElementsFieldNumber = 3;
  const ::Kinova::Api::Base::MapElement& elements(int index) const;
  ::Kinova::Api::Base::MapElement* mutable_elements(int index);
  ::Kinova::Api::Base::MapElement* add_elements();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapElement >*
      mutable_elements();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapElement >&
      elements() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Kinova.Api.Base.MapHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Base::MapHandle& handle() const;
  ::Kinova::Api::Base::MapHandle* release_handle();
  ::Kinova::Api::Base::MapHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Base::MapHandle* handle);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Map)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapElement > elements_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Kinova::Api::Base::MapHandle* handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsMapImpl();
};
// -------------------------------------------------------------------

class MapHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.MapHandle) */ {
 public:
  MapHandle();
  virtual ~MapHandle();

  MapHandle(const MapHandle& from);

  inline MapHandle& operator=(const MapHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapHandle(MapHandle&& from) noexcept
    : MapHandle() {
    *this = ::std::move(from);
  }

  inline MapHandle& operator=(MapHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapHandle* internal_default_instance() {
    return reinterpret_cast<const MapHandle*>(
               &_MapHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    104;

  void Swap(MapHandle* other);
  friend void swap(MapHandle& a, MapHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  MapHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapHandle& from);
  void MergeFrom(const MapHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 identifier() const;
  void set_identifier(::google::protobuf::uint32 value);

  // fixed32 permission = 2;
  void clear_permission();
  static const int kPermissionFieldNumber = 2;
  ::google::protobuf::uint32 permission() const;
  void set_permission(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.MapHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 identifier_;
  ::google::protobuf::uint32 permission_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsMapHandleImpl();
};
// -------------------------------------------------------------------

class MapList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.MapList) */ {
 public:
  MapList();
  virtual ~MapList();

  MapList(const MapList& from);

  inline MapList& operator=(const MapList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapList(MapList&& from) noexcept
    : MapList() {
    *this = ::std::move(from);
  }

  inline MapList& operator=(MapList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapList* internal_default_instance() {
    return reinterpret_cast<const MapList*>(
               &_MapList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    105;

  void Swap(MapList* other);
  friend void swap(MapList& a, MapList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapList* New() const PROTOBUF_FINAL { return New(NULL); }

  MapList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapList& from);
  void MergeFrom(const MapList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.Map map_list = 1;
  int map_list_size() const;
  void clear_map_list();
  static const int kMapListFieldNumber = 1;
  const ::Kinova::Api::Base::Map& map_list(int index) const;
  ::Kinova::Api::Base::Map* mutable_map_list(int index);
  ::Kinova::Api::Base::Map* add_map_list();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Map >*
      mutable_map_list();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Map >&
      map_list() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.MapList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Map > map_list_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsMapListImpl();
};
// -------------------------------------------------------------------

class MapGroupHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.MapGroupHandle) */ {
 public:
  MapGroupHandle();
  virtual ~MapGroupHandle();

  MapGroupHandle(const MapGroupHandle& from);

  inline MapGroupHandle& operator=(const MapGroupHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapGroupHandle(MapGroupHandle&& from) noexcept
    : MapGroupHandle() {
    *this = ::std::move(from);
  }

  inline MapGroupHandle& operator=(MapGroupHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapGroupHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapGroupHandle* internal_default_instance() {
    return reinterpret_cast<const MapGroupHandle*>(
               &_MapGroupHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    106;

  void Swap(MapGroupHandle* other);
  friend void swap(MapGroupHandle& a, MapGroupHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapGroupHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  MapGroupHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapGroupHandle& from);
  void MergeFrom(const MapGroupHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapGroupHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 identifier() const;
  void set_identifier(::google::protobuf::uint32 value);

  // fixed32 permission = 2;
  void clear_permission();
  static const int kPermissionFieldNumber = 2;
  ::google::protobuf::uint32 permission() const;
  void set_permission(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.MapGroupHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 identifier_;
  ::google::protobuf::uint32 permission_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsMapGroupHandleImpl();
};
// -------------------------------------------------------------------

class MapGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.MapGroup) */ {
 public:
  MapGroup();
  virtual ~MapGroup();

  MapGroup(const MapGroup& from);

  inline MapGroup& operator=(const MapGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapGroup(MapGroup&& from) noexcept
    : MapGroup() {
    *this = ::std::move(from);
  }

  inline MapGroup& operator=(MapGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapGroup* internal_default_instance() {
    return reinterpret_cast<const MapGroup*>(
               &_MapGroup_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    107;

  void Swap(MapGroup* other);
  friend void swap(MapGroup& a, MapGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapGroup* New() const PROTOBUF_FINAL { return New(NULL); }

  MapGroup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapGroup& from);
  void MergeFrom(const MapGroup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.MapGroupHandle children_map_group_handles = 5;
  int children_map_group_handles_size() const;
  void clear_children_map_group_handles();
  static const int kChildrenMapGroupHandlesFieldNumber = 5;
  const ::Kinova::Api::Base::MapGroupHandle& children_map_group_handles(int index) const;
  ::Kinova::Api::Base::MapGroupHandle* mutable_children_map_group_handles(int index);
  ::Kinova::Api::Base::MapGroupHandle* add_children_map_group_handles();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroupHandle >*
      mutable_children_map_group_handles();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroupHandle >&
      children_map_group_handles() const;

  // repeated .Kinova.Api.Base.MapHandle map_handles = 6;
  int map_handles_size() const;
  void clear_map_handles();
  static const int kMapHandlesFieldNumber = 6;
  const ::Kinova::Api::Base::MapHandle& map_handles(int index) const;
  ::Kinova::Api::Base::MapHandle* mutable_map_handles(int index);
  ::Kinova::Api::Base::MapHandle* add_map_handles();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapHandle >*
      mutable_map_handles();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapHandle >&
      map_handles() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string application_data = 7;
  void clear_application_data();
  static const int kApplicationDataFieldNumber = 7;
  const ::std::string& application_data() const;
  void set_application_data(const ::std::string& value);
  #if LANG_CXX11
  void set_application_data(::std::string&& value);
  #endif
  void set_application_data(const char* value);
  void set_application_data(const char* value, size_t size);
  ::std::string* mutable_application_data();
  ::std::string* release_application_data();
  void set_allocated_application_data(::std::string* application_data);

  // .Kinova.Api.Base.MapGroupHandle group_handle = 1;
  bool has_group_handle() const;
  void clear_group_handle();
  static const int kGroupHandleFieldNumber = 1;
  const ::Kinova::Api::Base::MapGroupHandle& group_handle() const;
  ::Kinova::Api::Base::MapGroupHandle* release_group_handle();
  ::Kinova::Api::Base::MapGroupHandle* mutable_group_handle();
  void set_allocated_group_handle(::Kinova::Api::Base::MapGroupHandle* group_handle);

  // .Kinova.Api.Base.MappingHandle related_mapping_handle = 3;
  bool has_related_mapping_handle() const;
  void clear_related_mapping_handle();
  static const int kRelatedMappingHandleFieldNumber = 3;
  const ::Kinova::Api::Base::MappingHandle& related_mapping_handle() const;
  ::Kinova::Api::Base::MappingHandle* release_related_mapping_handle();
  ::Kinova::Api::Base::MappingHandle* mutable_related_mapping_handle();
  void set_allocated_related_mapping_handle(::Kinova::Api::Base::MappingHandle* related_mapping_handle);

  // .Kinova.Api.Base.MapGroupHandle parent_group_handle = 4;
  bool has_parent_group_handle() const;
  void clear_parent_group_handle();
  static const int kParentGroupHandleFieldNumber = 4;
  const ::Kinova::Api::Base::MapGroupHandle& parent_group_handle() const;
  ::Kinova::Api::Base::MapGroupHandle* release_parent_group_handle();
  ::Kinova::Api::Base::MapGroupHandle* mutable_parent_group_handle();
  void set_allocated_parent_group_handle(::Kinova::Api::Base::MapGroupHandle* parent_group_handle);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.MapGroup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroupHandle > children_map_group_handles_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapHandle > map_handles_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr application_data_;
  ::Kinova::Api::Base::MapGroupHandle* group_handle_;
  ::Kinova::Api::Base::MappingHandle* related_mapping_handle_;
  ::Kinova::Api::Base::MapGroupHandle* parent_group_handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsMapGroupImpl();
};
// -------------------------------------------------------------------

class MapGroupList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.MapGroupList) */ {
 public:
  MapGroupList();
  virtual ~MapGroupList();

  MapGroupList(const MapGroupList& from);

  inline MapGroupList& operator=(const MapGroupList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapGroupList(MapGroupList&& from) noexcept
    : MapGroupList() {
    *this = ::std::move(from);
  }

  inline MapGroupList& operator=(MapGroupList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapGroupList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapGroupList* internal_default_instance() {
    return reinterpret_cast<const MapGroupList*>(
               &_MapGroupList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    108;

  void Swap(MapGroupList* other);
  friend void swap(MapGroupList& a, MapGroupList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapGroupList* New() const PROTOBUF_FINAL { return New(NULL); }

  MapGroupList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapGroupList& from);
  void MergeFrom(const MapGroupList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapGroupList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.MapGroup map_groups = 1;
  int map_groups_size() const;
  void clear_map_groups();
  static const int kMapGroupsFieldNumber = 1;
  const ::Kinova::Api::Base::MapGroup& map_groups(int index) const;
  ::Kinova::Api::Base::MapGroup* mutable_map_groups(int index);
  ::Kinova::Api::Base::MapGroup* add_map_groups();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroup >*
      mutable_map_groups();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroup >&
      map_groups() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.MapGroupList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroup > map_groups_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsMapGroupListImpl();
};
// -------------------------------------------------------------------

class Mapping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Mapping) */ {
 public:
  Mapping();
  virtual ~Mapping();

  Mapping(const Mapping& from);

  inline Mapping& operator=(const Mapping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mapping(Mapping&& from) noexcept
    : Mapping() {
    *this = ::std::move(from);
  }

  inline Mapping& operator=(Mapping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mapping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mapping* internal_default_instance() {
    return reinterpret_cast<const Mapping*>(
               &_Mapping_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    109;

  void Swap(Mapping* other);
  friend void swap(Mapping& a, Mapping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mapping* New() const PROTOBUF_FINAL { return New(NULL); }

  Mapping* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Mapping& from);
  void MergeFrom(const Mapping& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Mapping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.MapGroupHandle map_group_handles = 5;
  int map_group_handles_size() const;
  void clear_map_group_handles();
  static const int kMapGroupHandlesFieldNumber = 5;
  const ::Kinova::Api::Base::MapGroupHandle& map_group_handles(int index) const;
  ::Kinova::Api::Base::MapGroupHandle* mutable_map_group_handles(int index);
  ::Kinova::Api::Base::MapGroupHandle* add_map_group_handles();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroupHandle >*
      mutable_map_group_handles();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroupHandle >&
      map_group_handles() const;

  // repeated .Kinova.Api.Base.MapHandle map_handles = 7;
  int map_handles_size() const;
  void clear_map_handles();
  static const int kMapHandlesFieldNumber = 7;
  const ::Kinova::Api::Base::MapHandle& map_handles(int index) const;
  ::Kinova::Api::Base::MapHandle* mutable_map_handles(int index);
  ::Kinova::Api::Base::MapHandle* add_map_handles();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapHandle >*
      mutable_map_handles();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapHandle >&
      map_handles() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string application_data = 8;
  void clear_application_data();
  static const int kApplicationDataFieldNumber = 8;
  const ::std::string& application_data() const;
  void set_application_data(const ::std::string& value);
  #if LANG_CXX11
  void set_application_data(::std::string&& value);
  #endif
  void set_application_data(const char* value);
  void set_application_data(const char* value, size_t size);
  ::std::string* mutable_application_data();
  ::std::string* release_application_data();
  void set_allocated_application_data(::std::string* application_data);

  // .Kinova.Api.Base.MappingHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Base::MappingHandle& handle() const;
  ::Kinova::Api::Base::MappingHandle* release_handle();
  ::Kinova::Api::Base::MappingHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Base::MappingHandle* handle);

  // .Kinova.Api.Base.MapGroupHandle active_map_group_handle = 4;
  bool has_active_map_group_handle() const;
  void clear_active_map_group_handle();
  static const int kActiveMapGroupHandleFieldNumber = 4;
  const ::Kinova::Api::Base::MapGroupHandle& active_map_group_handle() const;
  ::Kinova::Api::Base::MapGroupHandle* release_active_map_group_handle();
  ::Kinova::Api::Base::MapGroupHandle* mutable_active_map_group_handle();
  void set_allocated_active_map_group_handle(::Kinova::Api::Base::MapGroupHandle* active_map_group_handle);

  // .Kinova.Api.Base.MapHandle active_map_handle = 6;
  bool has_active_map_handle() const;
  void clear_active_map_handle();
  static const int kActiveMapHandleFieldNumber = 6;
  const ::Kinova::Api::Base::MapHandle& active_map_handle() const;
  ::Kinova::Api::Base::MapHandle* release_active_map_handle();
  ::Kinova::Api::Base::MapHandle* mutable_active_map_handle();
  void set_allocated_active_map_handle(::Kinova::Api::Base::MapHandle* active_map_handle);

  // uint32 controller_identifier = 3;
  void clear_controller_identifier();
  static const int kControllerIdentifierFieldNumber = 3;
  ::google::protobuf::uint32 controller_identifier() const;
  void set_controller_identifier(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Mapping)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroupHandle > map_group_handles_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapHandle > map_handles_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr application_data_;
  ::Kinova::Api::Base::MappingHandle* handle_;
  ::Kinova::Api::Base::MapGroupHandle* active_map_group_handle_;
  ::Kinova::Api::Base::MapHandle* active_map_handle_;
  ::google::protobuf::uint32 controller_identifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsMappingImpl();
};
// -------------------------------------------------------------------

class MappingList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.MappingList) */ {
 public:
  MappingList();
  virtual ~MappingList();

  MappingList(const MappingList& from);

  inline MappingList& operator=(const MappingList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MappingList(MappingList&& from) noexcept
    : MappingList() {
    *this = ::std::move(from);
  }

  inline MappingList& operator=(MappingList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MappingList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MappingList* internal_default_instance() {
    return reinterpret_cast<const MappingList*>(
               &_MappingList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    110;

  void Swap(MappingList* other);
  friend void swap(MappingList& a, MappingList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MappingList* New() const PROTOBUF_FINAL { return New(NULL); }

  MappingList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MappingList& from);
  void MergeFrom(const MappingList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MappingList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.Mapping mappings = 1;
  int mappings_size() const;
  void clear_mappings();
  static const int kMappingsFieldNumber = 1;
  const ::Kinova::Api::Base::Mapping& mappings(int index) const;
  ::Kinova::Api::Base::Mapping* mutable_mappings(int index);
  ::Kinova::Api::Base::Mapping* add_mappings();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Mapping >*
      mutable_mappings();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Mapping >&
      mappings() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.MappingList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Mapping > mappings_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsMappingListImpl();
};
// -------------------------------------------------------------------

class TransformationMatrix : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.TransformationMatrix) */ {
 public:
  TransformationMatrix();
  virtual ~TransformationMatrix();

  TransformationMatrix(const TransformationMatrix& from);

  inline TransformationMatrix& operator=(const TransformationMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransformationMatrix(TransformationMatrix&& from) noexcept
    : TransformationMatrix() {
    *this = ::std::move(from);
  }

  inline TransformationMatrix& operator=(TransformationMatrix&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransformationMatrix& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransformationMatrix* internal_default_instance() {
    return reinterpret_cast<const TransformationMatrix*>(
               &_TransformationMatrix_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    111;

  void Swap(TransformationMatrix* other);
  friend void swap(TransformationMatrix& a, TransformationMatrix& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransformationMatrix* New() const PROTOBUF_FINAL { return New(NULL); }

  TransformationMatrix* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransformationMatrix& from);
  void MergeFrom(const TransformationMatrix& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransformationMatrix* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.TransformationRow r0 = 1;
  bool has_r0() const;
  void clear_r0();
  static const int kR0FieldNumber = 1;
  const ::Kinova::Api::Base::TransformationRow& r0() const;
  ::Kinova::Api::Base::TransformationRow* release_r0();
  ::Kinova::Api::Base::TransformationRow* mutable_r0();
  void set_allocated_r0(::Kinova::Api::Base::TransformationRow* r0);

  // .Kinova.Api.Base.TransformationRow r1 = 2;
  bool has_r1() const;
  void clear_r1();
  static const int kR1FieldNumber = 2;
  const ::Kinova::Api::Base::TransformationRow& r1() const;
  ::Kinova::Api::Base::TransformationRow* release_r1();
  ::Kinova::Api::Base::TransformationRow* mutable_r1();
  void set_allocated_r1(::Kinova::Api::Base::TransformationRow* r1);

  // .Kinova.Api.Base.TransformationRow r2 = 3;
  bool has_r2() const;
  void clear_r2();
  static const int kR2FieldNumber = 3;
  const ::Kinova::Api::Base::TransformationRow& r2() const;
  ::Kinova::Api::Base::TransformationRow* release_r2();
  ::Kinova::Api::Base::TransformationRow* mutable_r2();
  void set_allocated_r2(::Kinova::Api::Base::TransformationRow* r2);

  // .Kinova.Api.Base.TransformationRow r3 = 4;
  bool has_r3() const;
  void clear_r3();
  static const int kR3FieldNumber = 4;
  const ::Kinova::Api::Base::TransformationRow& r3() const;
  ::Kinova::Api::Base::TransformationRow* release_r3();
  ::Kinova::Api::Base::TransformationRow* mutable_r3();
  void set_allocated_r3(::Kinova::Api::Base::TransformationRow* r3);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.TransformationMatrix)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::TransformationRow* r0_;
  ::Kinova::Api::Base::TransformationRow* r1_;
  ::Kinova::Api::Base::TransformationRow* r2_;
  ::Kinova::Api::Base::TransformationRow* r3_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsTransformationMatrixImpl();
};
// -------------------------------------------------------------------

class TransformationRow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.TransformationRow) */ {
 public:
  TransformationRow();
  virtual ~TransformationRow();

  TransformationRow(const TransformationRow& from);

  inline TransformationRow& operator=(const TransformationRow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransformationRow(TransformationRow&& from) noexcept
    : TransformationRow() {
    *this = ::std::move(from);
  }

  inline TransformationRow& operator=(TransformationRow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransformationRow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransformationRow* internal_default_instance() {
    return reinterpret_cast<const TransformationRow*>(
               &_TransformationRow_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    112;

  void Swap(TransformationRow* other);
  friend void swap(TransformationRow& a, TransformationRow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransformationRow* New() const PROTOBUF_FINAL { return New(NULL); }

  TransformationRow* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransformationRow& from);
  void MergeFrom(const TransformationRow& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransformationRow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float c0 = 1;
  void clear_c0();
  static const int kC0FieldNumber = 1;
  float c0() const;
  void set_c0(float value);

  // float c1 = 2;
  void clear_c1();
  static const int kC1FieldNumber = 2;
  float c1() const;
  void set_c1(float value);

  // float c2 = 3;
  void clear_c2();
  static const int kC2FieldNumber = 3;
  float c2() const;
  void set_c2(float value);

  // float c3 = 4;
  void clear_c3();
  static const int kC3FieldNumber = 4;
  float c3() const;
  void set_c3(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.TransformationRow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float c0_;
  float c1_;
  float c2_;
  float c3_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsTransformationRowImpl();
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(Pose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    113;

  void Swap(Pose* other);
  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const PROTOBUF_FINAL { return New(NULL); }

  Pose* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // float theta_x = 4;
  void clear_theta_x();
  static const int kThetaXFieldNumber = 4;
  float theta_x() const;
  void set_theta_x(float value);

  // float theta_y = 5;
  void clear_theta_y();
  static const int kThetaYFieldNumber = 5;
  float theta_y() const;
  void set_theta_y(float value);

  // float theta_z = 6;
  void clear_theta_z();
  static const int kThetaZFieldNumber = 6;
  float theta_z() const;
  void set_theta_z(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Pose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  float theta_x_;
  float theta_y_;
  float theta_z_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsPoseImpl();
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    114;

  void Swap(Position* other);
  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const PROTOBUF_FINAL { return New(NULL); }

  Position* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsPositionImpl();
};
// -------------------------------------------------------------------

class Orientation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Orientation) */ {
 public:
  Orientation();
  virtual ~Orientation();

  Orientation(const Orientation& from);

  inline Orientation& operator=(const Orientation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Orientation(Orientation&& from) noexcept
    : Orientation() {
    *this = ::std::move(from);
  }

  inline Orientation& operator=(Orientation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Orientation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Orientation* internal_default_instance() {
    return reinterpret_cast<const Orientation*>(
               &_Orientation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    115;

  void Swap(Orientation* other);
  friend void swap(Orientation& a, Orientation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Orientation* New() const PROTOBUF_FINAL { return New(NULL); }

  Orientation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Orientation& from);
  void MergeFrom(const Orientation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Orientation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float theta_x = 1;
  void clear_theta_x();
  static const int kThetaXFieldNumber = 1;
  float theta_x() const;
  void set_theta_x(float value);

  // float theta_y = 2;
  void clear_theta_y();
  static const int kThetaYFieldNumber = 2;
  float theta_y() const;
  void set_theta_y(float value);

  // float theta_z = 3;
  void clear_theta_z();
  static const int kThetaZFieldNumber = 3;
  float theta_z() const;
  void set_theta_z(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Orientation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float theta_x_;
  float theta_y_;
  float theta_z_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsOrientationImpl();
};
// -------------------------------------------------------------------

class CartesianSpeed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.CartesianSpeed) */ {
 public:
  CartesianSpeed();
  virtual ~CartesianSpeed();

  CartesianSpeed(const CartesianSpeed& from);

  inline CartesianSpeed& operator=(const CartesianSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianSpeed(CartesianSpeed&& from) noexcept
    : CartesianSpeed() {
    *this = ::std::move(from);
  }

  inline CartesianSpeed& operator=(CartesianSpeed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianSpeed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianSpeed* internal_default_instance() {
    return reinterpret_cast<const CartesianSpeed*>(
               &_CartesianSpeed_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    116;

  void Swap(CartesianSpeed* other);
  friend void swap(CartesianSpeed& a, CartesianSpeed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianSpeed* New() const PROTOBUF_FINAL { return New(NULL); }

  CartesianSpeed* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CartesianSpeed& from);
  void MergeFrom(const CartesianSpeed& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CartesianSpeed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float translation = 1;
  void clear_translation();
  static const int kTranslationFieldNumber = 1;
  float translation() const;
  void set_translation(float value);

  // float orientation = 2;
  void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  float orientation() const;
  void set_orientation(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.CartesianSpeed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float translation_;
  float orientation_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsCartesianSpeedImpl();
};
// -------------------------------------------------------------------

class CartesianTrajectoryConstraint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.CartesianTrajectoryConstraint) */ {
 public:
  CartesianTrajectoryConstraint();
  virtual ~CartesianTrajectoryConstraint();

  CartesianTrajectoryConstraint(const CartesianTrajectoryConstraint& from);

  inline CartesianTrajectoryConstraint& operator=(const CartesianTrajectoryConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianTrajectoryConstraint(CartesianTrajectoryConstraint&& from) noexcept
    : CartesianTrajectoryConstraint() {
    *this = ::std::move(from);
  }

  inline CartesianTrajectoryConstraint& operator=(CartesianTrajectoryConstraint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianTrajectoryConstraint& default_instance();

  enum TypeCase {
    kSpeed = 1,
    kDuration = 2,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianTrajectoryConstraint* internal_default_instance() {
    return reinterpret_cast<const CartesianTrajectoryConstraint*>(
               &_CartesianTrajectoryConstraint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    117;

  void Swap(CartesianTrajectoryConstraint* other);
  friend void swap(CartesianTrajectoryConstraint& a, CartesianTrajectoryConstraint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianTrajectoryConstraint* New() const PROTOBUF_FINAL { return New(NULL); }

  CartesianTrajectoryConstraint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CartesianTrajectoryConstraint& from);
  void MergeFrom(const CartesianTrajectoryConstraint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CartesianTrajectoryConstraint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.CartesianSpeed speed = 1;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 1;
  const ::Kinova::Api::Base::CartesianSpeed& speed() const;
  ::Kinova::Api::Base::CartesianSpeed* release_speed();
  ::Kinova::Api::Base::CartesianSpeed* mutable_speed();
  void set_allocated_speed(::Kinova::Api::Base::CartesianSpeed* speed);

  // float duration = 2;
  private:
  bool has_duration() const;
  public:
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  float duration() const;
  void set_duration(float value);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.CartesianTrajectoryConstraint)
 private:
  void set_has_speed();
  void set_has_duration();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::Kinova::Api::Base::CartesianSpeed* speed_;
    float duration_;
  } type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsCartesianTrajectoryConstraintImpl();
};
// -------------------------------------------------------------------

class JointTrajectoryConstraint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.JointTrajectoryConstraint) */ {
 public:
  JointTrajectoryConstraint();
  virtual ~JointTrajectoryConstraint();

  JointTrajectoryConstraint(const JointTrajectoryConstraint& from);

  inline JointTrajectoryConstraint& operator=(const JointTrajectoryConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointTrajectoryConstraint(JointTrajectoryConstraint&& from) noexcept
    : JointTrajectoryConstraint() {
    *this = ::std::move(from);
  }

  inline JointTrajectoryConstraint& operator=(JointTrajectoryConstraint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JointTrajectoryConstraint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointTrajectoryConstraint* internal_default_instance() {
    return reinterpret_cast<const JointTrajectoryConstraint*>(
               &_JointTrajectoryConstraint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    118;

  void Swap(JointTrajectoryConstraint* other);
  friend void swap(JointTrajectoryConstraint& a, JointTrajectoryConstraint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointTrajectoryConstraint* New() const PROTOBUF_FINAL { return New(NULL); }

  JointTrajectoryConstraint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JointTrajectoryConstraint& from);
  void MergeFrom(const JointTrajectoryConstraint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JointTrajectoryConstraint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.JointTrajectoryConstraintType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Kinova::Api::Base::JointTrajectoryConstraintType type() const;
  void set_type(::Kinova::Api::Base::JointTrajectoryConstraintType value);

  // float value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.JointTrajectoryConstraint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int type_;
  float value_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsJointTrajectoryConstraintImpl();
};
// -------------------------------------------------------------------

class Wrench : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Wrench) */ {
 public:
  Wrench();
  virtual ~Wrench();

  Wrench(const Wrench& from);

  inline Wrench& operator=(const Wrench& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Wrench(Wrench&& from) noexcept
    : Wrench() {
    *this = ::std::move(from);
  }

  inline Wrench& operator=(Wrench&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Wrench& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Wrench* internal_default_instance() {
    return reinterpret_cast<const Wrench*>(
               &_Wrench_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    119;

  void Swap(Wrench* other);
  friend void swap(Wrench& a, Wrench& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Wrench* New() const PROTOBUF_FINAL { return New(NULL); }

  Wrench* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Wrench& from);
  void MergeFrom(const Wrench& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Wrench* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float force_x = 1;
  void clear_force_x();
  static const int kForceXFieldNumber = 1;
  float force_x() const;
  void set_force_x(float value);

  // float force_y = 2;
  void clear_force_y();
  static const int kForceYFieldNumber = 2;
  float force_y() const;
  void set_force_y(float value);

  // float force_z = 3;
  void clear_force_z();
  static const int kForceZFieldNumber = 3;
  float force_z() const;
  void set_force_z(float value);

  // float torque_x = 4;
  void clear_torque_x();
  static const int kTorqueXFieldNumber = 4;
  float torque_x() const;
  void set_torque_x(float value);

  // float torque_y = 5;
  void clear_torque_y();
  static const int kTorqueYFieldNumber = 5;
  float torque_y() const;
  void set_torque_y(float value);

  // float torque_z = 6;
  void clear_torque_z();
  static const int kTorqueZFieldNumber = 6;
  float torque_z() const;
  void set_torque_z(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Wrench)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float force_x_;
  float force_y_;
  float force_z_;
  float torque_x_;
  float torque_y_;
  float torque_z_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsWrenchImpl();
};
// -------------------------------------------------------------------

class Twist : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Twist) */ {
 public:
  Twist();
  virtual ~Twist();

  Twist(const Twist& from);

  inline Twist& operator=(const Twist& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Twist(Twist&& from) noexcept
    : Twist() {
    *this = ::std::move(from);
  }

  inline Twist& operator=(Twist&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Twist& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Twist* internal_default_instance() {
    return reinterpret_cast<const Twist*>(
               &_Twist_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    120;

  void Swap(Twist* other);
  friend void swap(Twist& a, Twist& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Twist* New() const PROTOBUF_FINAL { return New(NULL); }

  Twist* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Twist& from);
  void MergeFrom(const Twist& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Twist* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float linear_x = 1;
  void clear_linear_x();
  static const int kLinearXFieldNumber = 1;
  float linear_x() const;
  void set_linear_x(float value);

  // float linear_y = 2;
  void clear_linear_y();
  static const int kLinearYFieldNumber = 2;
  float linear_y() const;
  void set_linear_y(float value);

  // float linear_z = 3;
  void clear_linear_z();
  static const int kLinearZFieldNumber = 3;
  float linear_z() const;
  void set_linear_z(float value);

  // float angular_x = 4;
  void clear_angular_x();
  static const int kAngularXFieldNumber = 4;
  float angular_x() const;
  void set_angular_x(float value);

  // float angular_y = 5;
  void clear_angular_y();
  static const int kAngularYFieldNumber = 5;
  float angular_y() const;
  void set_angular_y(float value);

  // float angular_z = 6;
  void clear_angular_z();
  static const int kAngularZFieldNumber = 6;
  float angular_z() const;
  void set_angular_z(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Twist)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float linear_x_;
  float linear_y_;
  float linear_z_;
  float angular_x_;
  float angular_y_;
  float angular_z_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsTwistImpl();
};
// -------------------------------------------------------------------

class Admittance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Admittance) */ {
 public:
  Admittance();
  virtual ~Admittance();

  Admittance(const Admittance& from);

  inline Admittance& operator=(const Admittance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Admittance(Admittance&& from) noexcept
    : Admittance() {
    *this = ::std::move(from);
  }

  inline Admittance& operator=(Admittance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Admittance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Admittance* internal_default_instance() {
    return reinterpret_cast<const Admittance*>(
               &_Admittance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    121;

  void Swap(Admittance* other);
  friend void swap(Admittance& a, Admittance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Admittance* New() const PROTOBUF_FINAL { return New(NULL); }

  Admittance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Admittance& from);
  void MergeFrom(const Admittance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Admittance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.AdmittanceMode admittance_mode = 1;
  void clear_admittance_mode();
  static const int kAdmittanceModeFieldNumber = 1;
  ::Kinova::Api::Base::AdmittanceMode admittance_mode() const;
  void set_admittance_mode(::Kinova::Api::Base::AdmittanceMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Admittance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int admittance_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsAdmittanceImpl();
};
// -------------------------------------------------------------------

class ConstrainedPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ConstrainedPose) */ {
 public:
  ConstrainedPose();
  virtual ~ConstrainedPose();

  ConstrainedPose(const ConstrainedPose& from);

  inline ConstrainedPose& operator=(const ConstrainedPose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConstrainedPose(ConstrainedPose&& from) noexcept
    : ConstrainedPose() {
    *this = ::std::move(from);
  }

  inline ConstrainedPose& operator=(ConstrainedPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstrainedPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConstrainedPose* internal_default_instance() {
    return reinterpret_cast<const ConstrainedPose*>(
               &_ConstrainedPose_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    122;

  void Swap(ConstrainedPose* other);
  friend void swap(ConstrainedPose& a, ConstrainedPose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConstrainedPose* New() const PROTOBUF_FINAL { return New(NULL); }

  ConstrainedPose* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConstrainedPose& from);
  void MergeFrom(const ConstrainedPose& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConstrainedPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.Pose target_pose = 1;
  bool has_target_pose() const;
  void clear_target_pose();
  static const int kTargetPoseFieldNumber = 1;
  const ::Kinova::Api::Base::Pose& target_pose() const;
  ::Kinova::Api::Base::Pose* release_target_pose();
  ::Kinova::Api::Base::Pose* mutable_target_pose();
  void set_allocated_target_pose(::Kinova::Api::Base::Pose* target_pose);

  // .Kinova.Api.Base.CartesianTrajectoryConstraint constraint = 2;
  bool has_constraint() const;
  void clear_constraint();
  static const int kConstraintFieldNumber = 2;
  const ::Kinova::Api::Base::CartesianTrajectoryConstraint& constraint() const;
  ::Kinova::Api::Base::CartesianTrajectoryConstraint* release_constraint();
  ::Kinova::Api::Base::CartesianTrajectoryConstraint* mutable_constraint();
  void set_allocated_constraint(::Kinova::Api::Base::CartesianTrajectoryConstraint* constraint);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ConstrainedPose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::Pose* target_pose_;
  ::Kinova::Api::Base::CartesianTrajectoryConstraint* constraint_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsConstrainedPoseImpl();
};
// -------------------------------------------------------------------

class ConstrainedPosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ConstrainedPosition) */ {
 public:
  ConstrainedPosition();
  virtual ~ConstrainedPosition();

  ConstrainedPosition(const ConstrainedPosition& from);

  inline ConstrainedPosition& operator=(const ConstrainedPosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConstrainedPosition(ConstrainedPosition&& from) noexcept
    : ConstrainedPosition() {
    *this = ::std::move(from);
  }

  inline ConstrainedPosition& operator=(ConstrainedPosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstrainedPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConstrainedPosition* internal_default_instance() {
    return reinterpret_cast<const ConstrainedPosition*>(
               &_ConstrainedPosition_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    123;

  void Swap(ConstrainedPosition* other);
  friend void swap(ConstrainedPosition& a, ConstrainedPosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConstrainedPosition* New() const PROTOBUF_FINAL { return New(NULL); }

  ConstrainedPosition* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConstrainedPosition& from);
  void MergeFrom(const ConstrainedPosition& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConstrainedPosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.Position target_position = 1;
  bool has_target_position() const;
  void clear_target_position();
  static const int kTargetPositionFieldNumber = 1;
  const ::Kinova::Api::Base::Position& target_position() const;
  ::Kinova::Api::Base::Position* release_target_position();
  ::Kinova::Api::Base::Position* mutable_target_position();
  void set_allocated_target_position(::Kinova::Api::Base::Position* target_position);

  // .Kinova.Api.Base.CartesianTrajectoryConstraint constraint = 2;
  bool has_constraint() const;
  void clear_constraint();
  static const int kConstraintFieldNumber = 2;
  const ::Kinova::Api::Base::CartesianTrajectoryConstraint& constraint() const;
  ::Kinova::Api::Base::CartesianTrajectoryConstraint* release_constraint();
  ::Kinova::Api::Base::CartesianTrajectoryConstraint* mutable_constraint();
  void set_allocated_constraint(::Kinova::Api::Base::CartesianTrajectoryConstraint* constraint);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ConstrainedPosition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::Position* target_position_;
  ::Kinova::Api::Base::CartesianTrajectoryConstraint* constraint_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsConstrainedPositionImpl();
};
// -------------------------------------------------------------------

class ConstrainedOrientation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ConstrainedOrientation) */ {
 public:
  ConstrainedOrientation();
  virtual ~ConstrainedOrientation();

  ConstrainedOrientation(const ConstrainedOrientation& from);

  inline ConstrainedOrientation& operator=(const ConstrainedOrientation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConstrainedOrientation(ConstrainedOrientation&& from) noexcept
    : ConstrainedOrientation() {
    *this = ::std::move(from);
  }

  inline ConstrainedOrientation& operator=(ConstrainedOrientation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstrainedOrientation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConstrainedOrientation* internal_default_instance() {
    return reinterpret_cast<const ConstrainedOrientation*>(
               &_ConstrainedOrientation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    124;

  void Swap(ConstrainedOrientation* other);
  friend void swap(ConstrainedOrientation& a, ConstrainedOrientation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConstrainedOrientation* New() const PROTOBUF_FINAL { return New(NULL); }

  ConstrainedOrientation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConstrainedOrientation& from);
  void MergeFrom(const ConstrainedOrientation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConstrainedOrientation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.Orientation target_orientation = 1;
  bool has_target_orientation() const;
  void clear_target_orientation();
  static const int kTargetOrientationFieldNumber = 1;
  const ::Kinova::Api::Base::Orientation& target_orientation() const;
  ::Kinova::Api::Base::Orientation* release_target_orientation();
  ::Kinova::Api::Base::Orientation* mutable_target_orientation();
  void set_allocated_target_orientation(::Kinova::Api::Base::Orientation* target_orientation);

  // .Kinova.Api.Base.CartesianTrajectoryConstraint constraint = 2;
  bool has_constraint() const;
  void clear_constraint();
  static const int kConstraintFieldNumber = 2;
  const ::Kinova::Api::Base::CartesianTrajectoryConstraint& constraint() const;
  ::Kinova::Api::Base::CartesianTrajectoryConstraint* release_constraint();
  ::Kinova::Api::Base::CartesianTrajectoryConstraint* mutable_constraint();
  void set_allocated_constraint(::Kinova::Api::Base::CartesianTrajectoryConstraint* constraint);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ConstrainedOrientation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::Orientation* target_orientation_;
  ::Kinova::Api::Base::CartesianTrajectoryConstraint* constraint_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsConstrainedOrientationImpl();
};
// -------------------------------------------------------------------

class WrenchCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.WrenchCommand) */ {
 public:
  WrenchCommand();
  virtual ~WrenchCommand();

  WrenchCommand(const WrenchCommand& from);

  inline WrenchCommand& operator=(const WrenchCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WrenchCommand(WrenchCommand&& from) noexcept
    : WrenchCommand() {
    *this = ::std::move(from);
  }

  inline WrenchCommand& operator=(WrenchCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WrenchCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WrenchCommand* internal_default_instance() {
    return reinterpret_cast<const WrenchCommand*>(
               &_WrenchCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    125;

  void Swap(WrenchCommand* other);
  friend void swap(WrenchCommand& a, WrenchCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WrenchCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  WrenchCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WrenchCommand& from);
  void MergeFrom(const WrenchCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WrenchCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.Wrench wrench = 3;
  bool has_wrench() const;
  void clear_wrench();
  static const int kWrenchFieldNumber = 3;
  const ::Kinova::Api::Base::Wrench& wrench() const;
  ::Kinova::Api::Base::Wrench* release_wrench();
  ::Kinova::Api::Base::Wrench* mutable_wrench();
  void set_allocated_wrench(::Kinova::Api::Base::Wrench* wrench);

  // .Kinova.Api.Common.CartesianReferenceFrame reference_frame = 1;
  void clear_reference_frame();
  static const int kReferenceFrameFieldNumber = 1;
  ::Kinova::Api::Common::CartesianReferenceFrame reference_frame() const;
  void set_reference_frame(::Kinova::Api::Common::CartesianReferenceFrame value);

  // .Kinova.Api.Base.WrenchMode mode = 2;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  ::Kinova::Api::Base::WrenchMode mode() const;
  void set_mode(::Kinova::Api::Base::WrenchMode value);

  // uint32 duration = 4;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.WrenchCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::Wrench* wrench_;
  int reference_frame_;
  int mode_;
  ::google::protobuf::uint32 duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsWrenchCommandImpl();
};
// -------------------------------------------------------------------

class TwistCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.TwistCommand) */ {
 public:
  TwistCommand();
  virtual ~TwistCommand();

  TwistCommand(const TwistCommand& from);

  inline TwistCommand& operator=(const TwistCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TwistCommand(TwistCommand&& from) noexcept
    : TwistCommand() {
    *this = ::std::move(from);
  }

  inline TwistCommand& operator=(TwistCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TwistCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TwistCommand* internal_default_instance() {
    return reinterpret_cast<const TwistCommand*>(
               &_TwistCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    126;

  void Swap(TwistCommand* other);
  friend void swap(TwistCommand& a, TwistCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TwistCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  TwistCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TwistCommand& from);
  void MergeFrom(const TwistCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TwistCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.Twist twist = 2;
  bool has_twist() const;
  void clear_twist();
  static const int kTwistFieldNumber = 2;
  const ::Kinova::Api::Base::Twist& twist() const;
  ::Kinova::Api::Base::Twist* release_twist();
  ::Kinova::Api::Base::Twist* mutable_twist();
  void set_allocated_twist(::Kinova::Api::Base::Twist* twist);

  // .Kinova.Api.Common.CartesianReferenceFrame reference_frame = 1;
  void clear_reference_frame();
  static const int kReferenceFrameFieldNumber = 1;
  ::Kinova::Api::Common::CartesianReferenceFrame reference_frame() const;
  void set_reference_frame(::Kinova::Api::Common::CartesianReferenceFrame value);

  // uint32 duration = 3;
  void clear_duration();
  static const int kDurationFieldNumber = 3;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.TwistCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::Twist* twist_;
  int reference_frame_;
  ::google::protobuf::uint32 duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsTwistCommandImpl();
};
// -------------------------------------------------------------------

class ConstrainedJointAngles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ConstrainedJointAngles) */ {
 public:
  ConstrainedJointAngles();
  virtual ~ConstrainedJointAngles();

  ConstrainedJointAngles(const ConstrainedJointAngles& from);

  inline ConstrainedJointAngles& operator=(const ConstrainedJointAngles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConstrainedJointAngles(ConstrainedJointAngles&& from) noexcept
    : ConstrainedJointAngles() {
    *this = ::std::move(from);
  }

  inline ConstrainedJointAngles& operator=(ConstrainedJointAngles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstrainedJointAngles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConstrainedJointAngles* internal_default_instance() {
    return reinterpret_cast<const ConstrainedJointAngles*>(
               &_ConstrainedJointAngles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    127;

  void Swap(ConstrainedJointAngles* other);
  friend void swap(ConstrainedJointAngles& a, ConstrainedJointAngles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConstrainedJointAngles* New() const PROTOBUF_FINAL { return New(NULL); }

  ConstrainedJointAngles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConstrainedJointAngles& from);
  void MergeFrom(const ConstrainedJointAngles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConstrainedJointAngles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.JointAngles joint_angles = 1;
  bool has_joint_angles() const;
  void clear_joint_angles();
  static const int kJointAnglesFieldNumber = 1;
  const ::Kinova::Api::Base::JointAngles& joint_angles() const;
  ::Kinova::Api::Base::JointAngles* release_joint_angles();
  ::Kinova::Api::Base::JointAngles* mutable_joint_angles();
  void set_allocated_joint_angles(::Kinova::Api::Base::JointAngles* joint_angles);

  // .Kinova.Api.Base.JointTrajectoryConstraint constraint = 2;
  bool has_constraint() const;
  void clear_constraint();
  static const int kConstraintFieldNumber = 2;
  const ::Kinova::Api::Base::JointTrajectoryConstraint& constraint() const;
  ::Kinova::Api::Base::JointTrajectoryConstraint* release_constraint();
  ::Kinova::Api::Base::JointTrajectoryConstraint* mutable_constraint();
  void set_allocated_constraint(::Kinova::Api::Base::JointTrajectoryConstraint* constraint);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ConstrainedJointAngles)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::JointAngles* joint_angles_;
  ::Kinova::Api::Base::JointTrajectoryConstraint* constraint_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsConstrainedJointAnglesImpl();
};
// -------------------------------------------------------------------

class ConstrainedJointAngle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ConstrainedJointAngle) */ {
 public:
  ConstrainedJointAngle();
  virtual ~ConstrainedJointAngle();

  ConstrainedJointAngle(const ConstrainedJointAngle& from);

  inline ConstrainedJointAngle& operator=(const ConstrainedJointAngle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConstrainedJointAngle(ConstrainedJointAngle&& from) noexcept
    : ConstrainedJointAngle() {
    *this = ::std::move(from);
  }

  inline ConstrainedJointAngle& operator=(ConstrainedJointAngle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstrainedJointAngle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConstrainedJointAngle* internal_default_instance() {
    return reinterpret_cast<const ConstrainedJointAngle*>(
               &_ConstrainedJointAngle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    128;

  void Swap(ConstrainedJointAngle* other);
  friend void swap(ConstrainedJointAngle& a, ConstrainedJointAngle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConstrainedJointAngle* New() const PROTOBUF_FINAL { return New(NULL); }

  ConstrainedJointAngle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConstrainedJointAngle& from);
  void MergeFrom(const ConstrainedJointAngle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConstrainedJointAngle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.JointTrajectoryConstraint constraint = 3;
  bool has_constraint() const;
  void clear_constraint();
  static const int kConstraintFieldNumber = 3;
  const ::Kinova::Api::Base::JointTrajectoryConstraint& constraint() const;
  ::Kinova::Api::Base::JointTrajectoryConstraint* release_constraint();
  ::Kinova::Api::Base::JointTrajectoryConstraint* mutable_constraint();
  void set_allocated_constraint(::Kinova::Api::Base::JointTrajectoryConstraint* constraint);

  // uint32 joint_identifier = 1;
  void clear_joint_identifier();
  static const int kJointIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 joint_identifier() const;
  void set_joint_identifier(::google::protobuf::uint32 value);

  // float value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ConstrainedJointAngle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::JointTrajectoryConstraint* constraint_;
  ::google::protobuf::uint32 joint_identifier_;
  float value_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsConstrainedJointAngleImpl();
};
// -------------------------------------------------------------------

class JointAngles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.JointAngles) */ {
 public:
  JointAngles();
  virtual ~JointAngles();

  JointAngles(const JointAngles& from);

  inline JointAngles& operator=(const JointAngles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointAngles(JointAngles&& from) noexcept
    : JointAngles() {
    *this = ::std::move(from);
  }

  inline JointAngles& operator=(JointAngles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JointAngles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointAngles* internal_default_instance() {
    return reinterpret_cast<const JointAngles*>(
               &_JointAngles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    129;

  void Swap(JointAngles* other);
  friend void swap(JointAngles& a, JointAngles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointAngles* New() const PROTOBUF_FINAL { return New(NULL); }

  JointAngles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JointAngles& from);
  void MergeFrom(const JointAngles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JointAngles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.JointAngle joint_angles = 1;
  int joint_angles_size() const;
  void clear_joint_angles();
  static const int kJointAnglesFieldNumber = 1;
  const ::Kinova::Api::Base::JointAngle& joint_angles(int index) const;
  ::Kinova::Api::Base::JointAngle* mutable_joint_angles(int index);
  ::Kinova::Api::Base::JointAngle* add_joint_angles();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointAngle >*
      mutable_joint_angles();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointAngle >&
      joint_angles() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.JointAngles)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointAngle > joint_angles_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsJointAnglesImpl();
};
// -------------------------------------------------------------------

class JointAngle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.JointAngle) */ {
 public:
  JointAngle();
  virtual ~JointAngle();

  JointAngle(const JointAngle& from);

  inline JointAngle& operator=(const JointAngle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointAngle(JointAngle&& from) noexcept
    : JointAngle() {
    *this = ::std::move(from);
  }

  inline JointAngle& operator=(JointAngle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JointAngle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointAngle* internal_default_instance() {
    return reinterpret_cast<const JointAngle*>(
               &_JointAngle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    130;

  void Swap(JointAngle* other);
  friend void swap(JointAngle& a, JointAngle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointAngle* New() const PROTOBUF_FINAL { return New(NULL); }

  JointAngle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JointAngle& from);
  void MergeFrom(const JointAngle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JointAngle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 joint_identifier = 1;
  void clear_joint_identifier();
  static const int kJointIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 joint_identifier() const;
  void set_joint_identifier(::google::protobuf::uint32 value);

  // float value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.JointAngle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 joint_identifier_;
  float value_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsJointAngleImpl();
};
// -------------------------------------------------------------------

class JointSpeeds : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.JointSpeeds) */ {
 public:
  JointSpeeds();
  virtual ~JointSpeeds();

  JointSpeeds(const JointSpeeds& from);

  inline JointSpeeds& operator=(const JointSpeeds& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointSpeeds(JointSpeeds&& from) noexcept
    : JointSpeeds() {
    *this = ::std::move(from);
  }

  inline JointSpeeds& operator=(JointSpeeds&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JointSpeeds& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointSpeeds* internal_default_instance() {
    return reinterpret_cast<const JointSpeeds*>(
               &_JointSpeeds_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    131;

  void Swap(JointSpeeds* other);
  friend void swap(JointSpeeds& a, JointSpeeds& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointSpeeds* New() const PROTOBUF_FINAL { return New(NULL); }

  JointSpeeds* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JointSpeeds& from);
  void MergeFrom(const JointSpeeds& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JointSpeeds* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.JointSpeed joint_speeds = 1;
  int joint_speeds_size() const;
  void clear_joint_speeds();
  static const int kJointSpeedsFieldNumber = 1;
  const ::Kinova::Api::Base::JointSpeed& joint_speeds(int index) const;
  ::Kinova::Api::Base::JointSpeed* mutable_joint_speeds(int index);
  ::Kinova::Api::Base::JointSpeed* add_joint_speeds();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointSpeed >*
      mutable_joint_speeds();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointSpeed >&
      joint_speeds() const;

  // uint32 duration = 2;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.JointSpeeds)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointSpeed > joint_speeds_;
  ::google::protobuf::uint32 duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsJointSpeedsImpl();
};
// -------------------------------------------------------------------

class JointSpeed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.JointSpeed) */ {
 public:
  JointSpeed();
  virtual ~JointSpeed();

  JointSpeed(const JointSpeed& from);

  inline JointSpeed& operator=(const JointSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointSpeed(JointSpeed&& from) noexcept
    : JointSpeed() {
    *this = ::std::move(from);
  }

  inline JointSpeed& operator=(JointSpeed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JointSpeed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointSpeed* internal_default_instance() {
    return reinterpret_cast<const JointSpeed*>(
               &_JointSpeed_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    132;

  void Swap(JointSpeed* other);
  friend void swap(JointSpeed& a, JointSpeed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointSpeed* New() const PROTOBUF_FINAL { return New(NULL); }

  JointSpeed* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JointSpeed& from);
  void MergeFrom(const JointSpeed& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JointSpeed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 joint_identifier = 1;
  void clear_joint_identifier();
  static const int kJointIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 joint_identifier() const;
  void set_joint_identifier(::google::protobuf::uint32 value);

  // float value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // uint32 duration = 3;
  void clear_duration();
  static const int kDurationFieldNumber = 3;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.JointSpeed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 joint_identifier_;
  float value_;
  ::google::protobuf::uint32 duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsJointSpeedImpl();
};
// -------------------------------------------------------------------

class JointTorques : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.JointTorques) */ {
 public:
  JointTorques();
  virtual ~JointTorques();

  JointTorques(const JointTorques& from);

  inline JointTorques& operator=(const JointTorques& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointTorques(JointTorques&& from) noexcept
    : JointTorques() {
    *this = ::std::move(from);
  }

  inline JointTorques& operator=(JointTorques&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JointTorques& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointTorques* internal_default_instance() {
    return reinterpret_cast<const JointTorques*>(
               &_JointTorques_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    133;

  void Swap(JointTorques* other);
  friend void swap(JointTorques& a, JointTorques& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointTorques* New() const PROTOBUF_FINAL { return New(NULL); }

  JointTorques* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JointTorques& from);
  void MergeFrom(const JointTorques& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JointTorques* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.JointTorque joint_torques = 1;
  int joint_torques_size() const;
  void clear_joint_torques();
  static const int kJointTorquesFieldNumber = 1;
  const ::Kinova::Api::Base::JointTorque& joint_torques(int index) const;
  ::Kinova::Api::Base::JointTorque* mutable_joint_torques(int index);
  ::Kinova::Api::Base::JointTorque* add_joint_torques();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointTorque >*
      mutable_joint_torques();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointTorque >&
      joint_torques() const;

  // uint32 duration = 2;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.JointTorques)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointTorque > joint_torques_;
  ::google::protobuf::uint32 duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsJointTorquesImpl();
};
// -------------------------------------------------------------------

class JointTorque : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.JointTorque) */ {
 public:
  JointTorque();
  virtual ~JointTorque();

  JointTorque(const JointTorque& from);

  inline JointTorque& operator=(const JointTorque& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointTorque(JointTorque&& from) noexcept
    : JointTorque() {
    *this = ::std::move(from);
  }

  inline JointTorque& operator=(JointTorque&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JointTorque& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointTorque* internal_default_instance() {
    return reinterpret_cast<const JointTorque*>(
               &_JointTorque_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    134;

  void Swap(JointTorque* other);
  friend void swap(JointTorque& a, JointTorque& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointTorque* New() const PROTOBUF_FINAL { return New(NULL); }

  JointTorque* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JointTorque& from);
  void MergeFrom(const JointTorque& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JointTorque* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 joint_identifier = 1;
  void clear_joint_identifier();
  static const int kJointIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 joint_identifier() const;
  void set_joint_identifier(::google::protobuf::uint32 value);

  // float value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // uint32 duration = 3;
  void clear_duration();
  static const int kDurationFieldNumber = 3;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.JointTorque)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 joint_identifier_;
  float value_;
  ::google::protobuf::uint32 duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsJointTorqueImpl();
};
// -------------------------------------------------------------------

class GripperCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.GripperCommand) */ {
 public:
  GripperCommand();
  virtual ~GripperCommand();

  GripperCommand(const GripperCommand& from);

  inline GripperCommand& operator=(const GripperCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GripperCommand(GripperCommand&& from) noexcept
    : GripperCommand() {
    *this = ::std::move(from);
  }

  inline GripperCommand& operator=(GripperCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GripperCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GripperCommand* internal_default_instance() {
    return reinterpret_cast<const GripperCommand*>(
               &_GripperCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    135;

  void Swap(GripperCommand* other);
  friend void swap(GripperCommand& a, GripperCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GripperCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  GripperCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GripperCommand& from);
  void MergeFrom(const GripperCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GripperCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.Gripper gripper = 2;
  bool has_gripper() const;
  void clear_gripper();
  static const int kGripperFieldNumber = 2;
  const ::Kinova::Api::Base::Gripper& gripper() const;
  ::Kinova::Api::Base::Gripper* release_gripper();
  ::Kinova::Api::Base::Gripper* mutable_gripper();
  void set_allocated_gripper(::Kinova::Api::Base::Gripper* gripper);

  // .Kinova.Api.Base.GripperMode mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::Kinova::Api::Base::GripperMode mode() const;
  void set_mode(::Kinova::Api::Base::GripperMode value);

  // uint32 duration = 3;
  void clear_duration();
  static const int kDurationFieldNumber = 3;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.GripperCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::Gripper* gripper_;
  int mode_;
  ::google::protobuf::uint32 duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsGripperCommandImpl();
};
// -------------------------------------------------------------------

class GripperRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.GripperRequest) */ {
 public:
  GripperRequest();
  virtual ~GripperRequest();

  GripperRequest(const GripperRequest& from);

  inline GripperRequest& operator=(const GripperRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GripperRequest(GripperRequest&& from) noexcept
    : GripperRequest() {
    *this = ::std::move(from);
  }

  inline GripperRequest& operator=(GripperRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GripperRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GripperRequest* internal_default_instance() {
    return reinterpret_cast<const GripperRequest*>(
               &_GripperRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    136;

  void Swap(GripperRequest* other);
  friend void swap(GripperRequest& a, GripperRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GripperRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GripperRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GripperRequest& from);
  void MergeFrom(const GripperRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GripperRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.GripperMode mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::Kinova::Api::Base::GripperMode mode() const;
  void set_mode(::Kinova::Api::Base::GripperMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.GripperRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsGripperRequestImpl();
};
// -------------------------------------------------------------------

class Gripper : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Gripper) */ {
 public:
  Gripper();
  virtual ~Gripper();

  Gripper(const Gripper& from);

  inline Gripper& operator=(const Gripper& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Gripper(Gripper&& from) noexcept
    : Gripper() {
    *this = ::std::move(from);
  }

  inline Gripper& operator=(Gripper&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Gripper& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Gripper* internal_default_instance() {
    return reinterpret_cast<const Gripper*>(
               &_Gripper_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    137;

  void Swap(Gripper* other);
  friend void swap(Gripper& a, Gripper& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Gripper* New() const PROTOBUF_FINAL { return New(NULL); }

  Gripper* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Gripper& from);
  void MergeFrom(const Gripper& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Gripper* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.Finger finger = 1;
  int finger_size() const;
  void clear_finger();
  static const int kFingerFieldNumber = 1;
  const ::Kinova::Api::Base::Finger& finger(int index) const;
  ::Kinova::Api::Base::Finger* mutable_finger(int index);
  ::Kinova::Api::Base::Finger* add_finger();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Finger >*
      mutable_finger();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Finger >&
      finger() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Gripper)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Finger > finger_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsGripperImpl();
};
// -------------------------------------------------------------------

class Finger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Finger) */ {
 public:
  Finger();
  virtual ~Finger();

  Finger(const Finger& from);

  inline Finger& operator=(const Finger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Finger(Finger&& from) noexcept
    : Finger() {
    *this = ::std::move(from);
  }

  inline Finger& operator=(Finger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Finger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Finger* internal_default_instance() {
    return reinterpret_cast<const Finger*>(
               &_Finger_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    138;

  void Swap(Finger* other);
  friend void swap(Finger& a, Finger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Finger* New() const PROTOBUF_FINAL { return New(NULL); }

  Finger* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Finger& from);
  void MergeFrom(const Finger& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Finger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 finger_identifier = 1;
  void clear_finger_identifier();
  static const int kFingerIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 finger_identifier() const;
  void set_finger_identifier(::google::protobuf::uint32 value);

  // float value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Finger)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 finger_identifier_;
  float value_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsFingerImpl();
};
// -------------------------------------------------------------------

class GpioCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.GpioCommand) */ {
 public:
  GpioCommand();
  virtual ~GpioCommand();

  GpioCommand(const GpioCommand& from);

  inline GpioCommand& operator=(const GpioCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GpioCommand(GpioCommand&& from) noexcept
    : GpioCommand() {
    *this = ::std::move(from);
  }

  inline GpioCommand& operator=(GpioCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpioCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GpioCommand* internal_default_instance() {
    return reinterpret_cast<const GpioCommand*>(
               &_GpioCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    139;

  void Swap(GpioCommand* other);
  friend void swap(GpioCommand& a, GpioCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GpioCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  GpioCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GpioCommand& from);
  void MergeFrom(const GpioCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GpioCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 port_identifier = 1;
  void clear_port_identifier();
  static const int kPortIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 port_identifier() const;
  void set_port_identifier(::google::protobuf::uint32 value);

  // uint32 pin_identifier = 2;
  void clear_pin_identifier();
  static const int kPinIdentifierFieldNumber = 2;
  ::google::protobuf::uint32 pin_identifier() const;
  void set_pin_identifier(::google::protobuf::uint32 value);

  // .Kinova.Api.Base.GpioAction action = 3;
  void clear_action();
  static const int kActionFieldNumber = 3;
  ::Kinova::Api::Base::GpioAction action() const;
  void set_action(::Kinova::Api::Base::GpioAction value);

  // uint32 period = 4;
  void clear_period();
  static const int kPeriodFieldNumber = 4;
  ::google::protobuf::uint32 period() const;
  void set_period(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.GpioCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 port_identifier_;
  ::google::protobuf::uint32 pin_identifier_;
  int action_;
  ::google::protobuf::uint32 period_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsGpioCommandImpl();
};
// -------------------------------------------------------------------

class SystemTime : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.SystemTime) */ {
 public:
  SystemTime();
  virtual ~SystemTime();

  SystemTime(const SystemTime& from);

  inline SystemTime& operator=(const SystemTime& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SystemTime(SystemTime&& from) noexcept
    : SystemTime() {
    *this = ::std::move(from);
  }

  inline SystemTime& operator=(SystemTime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemTime& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SystemTime* internal_default_instance() {
    return reinterpret_cast<const SystemTime*>(
               &_SystemTime_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    140;

  void Swap(SystemTime* other);
  friend void swap(SystemTime& a, SystemTime& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SystemTime* New() const PROTOBUF_FINAL { return New(NULL); }

  SystemTime* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SystemTime& from);
  void MergeFrom(const SystemTime& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SystemTime* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 sec = 1;
  void clear_sec();
  static const int kSecFieldNumber = 1;
  ::google::protobuf::uint32 sec() const;
  void set_sec(::google::protobuf::uint32 value);

  // uint32 min = 2;
  void clear_min();
  static const int kMinFieldNumber = 2;
  ::google::protobuf::uint32 min() const;
  void set_min(::google::protobuf::uint32 value);

  // uint32 hour = 3;
  void clear_hour();
  static const int kHourFieldNumber = 3;
  ::google::protobuf::uint32 hour() const;
  void set_hour(::google::protobuf::uint32 value);

  // uint32 mday = 4;
  void clear_mday();
  static const int kMdayFieldNumber = 4;
  ::google::protobuf::uint32 mday() const;
  void set_mday(::google::protobuf::uint32 value);

  // uint32 mon = 5;
  void clear_mon();
  static const int kMonFieldNumber = 5;
  ::google::protobuf::uint32 mon() const;
  void set_mon(::google::protobuf::uint32 value);

  // uint32 year = 6;
  void clear_year();
  static const int kYearFieldNumber = 6;
  ::google::protobuf::uint32 year() const;
  void set_year(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.SystemTime)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 sec_;
  ::google::protobuf::uint32 min_;
  ::google::protobuf::uint32 hour_;
  ::google::protobuf::uint32 mday_;
  ::google::protobuf::uint32 mon_;
  ::google::protobuf::uint32 year_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsSystemTimeImpl();
};
// -------------------------------------------------------------------

class ControllerConfigurationMode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ControllerConfigurationMode) */ {
 public:
  ControllerConfigurationMode();
  virtual ~ControllerConfigurationMode();

  ControllerConfigurationMode(const ControllerConfigurationMode& from);

  inline ControllerConfigurationMode& operator=(const ControllerConfigurationMode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerConfigurationMode(ControllerConfigurationMode&& from) noexcept
    : ControllerConfigurationMode() {
    *this = ::std::move(from);
  }

  inline ControllerConfigurationMode& operator=(ControllerConfigurationMode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerConfigurationMode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerConfigurationMode* internal_default_instance() {
    return reinterpret_cast<const ControllerConfigurationMode*>(
               &_ControllerConfigurationMode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    141;

  void Swap(ControllerConfigurationMode* other);
  friend void swap(ControllerConfigurationMode& a, ControllerConfigurationMode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerConfigurationMode* New() const PROTOBUF_FINAL { return New(NULL); }

  ControllerConfigurationMode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControllerConfigurationMode& from);
  void MergeFrom(const ControllerConfigurationMode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControllerConfigurationMode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool enable = 1;
  void clear_enable();
  static const int kEnableFieldNumber = 1;
  bool enable() const;
  void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ControllerConfigurationMode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool enable_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsControllerConfigurationModeImpl();
};
// -------------------------------------------------------------------

class ControllerConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ControllerConfiguration) */ {
 public:
  ControllerConfiguration();
  virtual ~ControllerConfiguration();

  ControllerConfiguration(const ControllerConfiguration& from);

  inline ControllerConfiguration& operator=(const ControllerConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerConfiguration(ControllerConfiguration&& from) noexcept
    : ControllerConfiguration() {
    *this = ::std::move(from);
  }

  inline ControllerConfiguration& operator=(ControllerConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerConfiguration* internal_default_instance() {
    return reinterpret_cast<const ControllerConfiguration*>(
               &_ControllerConfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    142;

  void Swap(ControllerConfiguration* other);
  friend void swap(ControllerConfiguration& a, ControllerConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerConfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  ControllerConfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControllerConfiguration& from);
  void MergeFrom(const ControllerConfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControllerConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string analog_input_identifier_enum = 4;
  void clear_analog_input_identifier_enum();
  static const int kAnalogInputIdentifierEnumFieldNumber = 4;
  const ::std::string& analog_input_identifier_enum() const;
  void set_analog_input_identifier_enum(const ::std::string& value);
  #if LANG_CXX11
  void set_analog_input_identifier_enum(::std::string&& value);
  #endif
  void set_analog_input_identifier_enum(const char* value);
  void set_analog_input_identifier_enum(const char* value, size_t size);
  ::std::string* mutable_analog_input_identifier_enum();
  ::std::string* release_analog_input_identifier_enum();
  void set_allocated_analog_input_identifier_enum(::std::string* analog_input_identifier_enum);

  // string digital_input_identifier_enum = 5;
  void clear_digital_input_identifier_enum();
  static const int kDigitalInputIdentifierEnumFieldNumber = 5;
  const ::std::string& digital_input_identifier_enum() const;
  void set_digital_input_identifier_enum(const ::std::string& value);
  #if LANG_CXX11
  void set_digital_input_identifier_enum(::std::string&& value);
  #endif
  void set_digital_input_identifier_enum(const char* value);
  void set_digital_input_identifier_enum(const char* value, size_t size);
  ::std::string* mutable_digital_input_identifier_enum();
  ::std::string* release_digital_input_identifier_enum();
  void set_allocated_digital_input_identifier_enum(::std::string* digital_input_identifier_enum);

  // .Kinova.Api.Base.ControllerHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Base::ControllerHandle& handle() const;
  ::Kinova::Api::Base::ControllerHandle* release_handle();
  ::Kinova::Api::Base::ControllerHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Base::ControllerHandle* handle);

  // .Kinova.Api.Base.MappingHandle active_mapping_handle = 3;
  bool has_active_mapping_handle() const;
  void clear_active_mapping_handle();
  static const int kActiveMappingHandleFieldNumber = 3;
  const ::Kinova::Api::Base::MappingHandle& active_mapping_handle() const;
  ::Kinova::Api::Base::MappingHandle* release_active_mapping_handle();
  ::Kinova::Api::Base::MappingHandle* mutable_active_mapping_handle();
  void set_allocated_active_mapping_handle(::Kinova::Api::Base::MappingHandle* active_mapping_handle);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ControllerConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr analog_input_identifier_enum_;
  ::google::protobuf::internal::ArenaStringPtr digital_input_identifier_enum_;
  ::Kinova::Api::Base::ControllerHandle* handle_;
  ::Kinova::Api::Base::MappingHandle* active_mapping_handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsControllerConfigurationImpl();
};
// -------------------------------------------------------------------

class ControllerConfigurationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ControllerConfigurationList) */ {
 public:
  ControllerConfigurationList();
  virtual ~ControllerConfigurationList();

  ControllerConfigurationList(const ControllerConfigurationList& from);

  inline ControllerConfigurationList& operator=(const ControllerConfigurationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerConfigurationList(ControllerConfigurationList&& from) noexcept
    : ControllerConfigurationList() {
    *this = ::std::move(from);
  }

  inline ControllerConfigurationList& operator=(ControllerConfigurationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerConfigurationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerConfigurationList* internal_default_instance() {
    return reinterpret_cast<const ControllerConfigurationList*>(
               &_ControllerConfigurationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    143;

  void Swap(ControllerConfigurationList* other);
  friend void swap(ControllerConfigurationList& a, ControllerConfigurationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerConfigurationList* New() const PROTOBUF_FINAL { return New(NULL); }

  ControllerConfigurationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControllerConfigurationList& from);
  void MergeFrom(const ControllerConfigurationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControllerConfigurationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.ControllerConfiguration controller_configurations = 1;
  int controller_configurations_size() const;
  void clear_controller_configurations();
  static const int kControllerConfigurationsFieldNumber = 1;
  const ::Kinova::Api::Base::ControllerConfiguration& controller_configurations(int index) const;
  ::Kinova::Api::Base::ControllerConfiguration* mutable_controller_configurations(int index);
  ::Kinova::Api::Base::ControllerConfiguration* add_controller_configurations();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerConfiguration >*
      mutable_controller_configurations();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerConfiguration >&
      controller_configurations() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ControllerConfigurationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerConfiguration > controller_configurations_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsControllerConfigurationListImpl();
};
// -------------------------------------------------------------------

class ActuatorInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ActuatorInformation) */ {
 public:
  ActuatorInformation();
  virtual ~ActuatorInformation();

  ActuatorInformation(const ActuatorInformation& from);

  inline ActuatorInformation& operator=(const ActuatorInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActuatorInformation(ActuatorInformation&& from) noexcept
    : ActuatorInformation() {
    *this = ::std::move(from);
  }

  inline ActuatorInformation& operator=(ActuatorInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActuatorInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActuatorInformation* internal_default_instance() {
    return reinterpret_cast<const ActuatorInformation*>(
               &_ActuatorInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    144;

  void Swap(ActuatorInformation* other);
  friend void swap(ActuatorInformation& a, ActuatorInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActuatorInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  ActuatorInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ActuatorInformation& from);
  void MergeFrom(const ActuatorInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ActuatorInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 count = 1;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ActuatorInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 count_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsActuatorInformationImpl();
};
// -------------------------------------------------------------------

class ArmStateInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ArmStateInformation) */ {
 public:
  ArmStateInformation();
  virtual ~ArmStateInformation();

  ArmStateInformation(const ArmStateInformation& from);

  inline ArmStateInformation& operator=(const ArmStateInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArmStateInformation(ArmStateInformation&& from) noexcept
    : ArmStateInformation() {
    *this = ::std::move(from);
  }

  inline ArmStateInformation& operator=(ArmStateInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ArmStateInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArmStateInformation* internal_default_instance() {
    return reinterpret_cast<const ArmStateInformation*>(
               &_ArmStateInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    145;

  void Swap(ArmStateInformation* other);
  friend void swap(ArmStateInformation& a, ArmStateInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArmStateInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  ArmStateInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ArmStateInformation& from);
  void MergeFrom(const ArmStateInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ArmStateInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.Connection connection = 2;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 2;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Common.ArmState active_state = 1;
  void clear_active_state();
  static const int kActiveStateFieldNumber = 1;
  ::Kinova::Api::Common::ArmState active_state() const;
  void set_active_state(::Kinova::Api::Common::ArmState value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ArmStateInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::Connection* connection_;
  int active_state_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsArmStateInformationImpl();
};
// -------------------------------------------------------------------

class ArmStateNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.ArmStateNotification) */ {
 public:
  ArmStateNotification();
  virtual ~ArmStateNotification();

  ArmStateNotification(const ArmStateNotification& from);

  inline ArmStateNotification& operator=(const ArmStateNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArmStateNotification(ArmStateNotification&& from) noexcept
    : ArmStateNotification() {
    *this = ::std::move(from);
  }

  inline ArmStateNotification& operator=(ArmStateNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ArmStateNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArmStateNotification* internal_default_instance() {
    return reinterpret_cast<const ArmStateNotification*>(
               &_ArmStateNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    146;

  void Swap(ArmStateNotification* other);
  friend void swap(ArmStateNotification& a, ArmStateNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArmStateNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  ArmStateNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ArmStateNotification& from);
  void MergeFrom(const ArmStateNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ArmStateNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.Timestamp timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.Connection connection = 3;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 3;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Common.ArmState active_state = 1;
  void clear_active_state();
  static const int kActiveStateFieldNumber = 1;
  ::Kinova::Api::Common::ArmState active_state() const;
  void set_active_state(::Kinova::Api::Common::ArmState value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.ArmStateNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::Connection* connection_;
  int active_state_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsArmStateNotificationImpl();
};
// -------------------------------------------------------------------

class CapSenseConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.CapSenseConfig) */ {
 public:
  CapSenseConfig();
  virtual ~CapSenseConfig();

  CapSenseConfig(const CapSenseConfig& from);

  inline CapSenseConfig& operator=(const CapSenseConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CapSenseConfig(CapSenseConfig&& from) noexcept
    : CapSenseConfig() {
    *this = ::std::move(from);
  }

  inline CapSenseConfig& operator=(CapSenseConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CapSenseConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CapSenseConfig* internal_default_instance() {
    return reinterpret_cast<const CapSenseConfig*>(
               &_CapSenseConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    147;

  void Swap(CapSenseConfig* other);
  friend void swap(CapSenseConfig& a, CapSenseConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CapSenseConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  CapSenseConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CapSenseConfig& from);
  void MergeFrom(const CapSenseConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CapSenseConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 identifier() const;
  void set_identifier(::google::protobuf::uint32 value);

  // .Kinova.Api.Base.CapSenseMode mode = 2;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  ::Kinova::Api::Base::CapSenseMode mode() const;
  void set_mode(::Kinova::Api::Base::CapSenseMode value);

  // float threshold_a = 3;
  void clear_threshold_a();
  static const int kThresholdAFieldNumber = 3;
  float threshold_a() const;
  void set_threshold_a(float value);

  // float threshold_b = 4;
  void clear_threshold_b();
  static const int kThresholdBFieldNumber = 4;
  float threshold_b() const;
  void set_threshold_b(float value);

  // float sensitivity_a = 5;
  void clear_sensitivity_a();
  static const int kSensitivityAFieldNumber = 5;
  float sensitivity_a() const;
  void set_sensitivity_a(float value);

  // float sensitivity_b = 6;
  void clear_sensitivity_b();
  static const int kSensitivityBFieldNumber = 6;
  float sensitivity_b() const;
  void set_sensitivity_b(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.CapSenseConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 identifier_;
  int mode_;
  float threshold_a_;
  float threshold_b_;
  float sensitivity_a_;
  float sensitivity_b_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsCapSenseConfigImpl();
};
// -------------------------------------------------------------------

class BridgeList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.BridgeList) */ {
 public:
  BridgeList();
  virtual ~BridgeList();

  BridgeList(const BridgeList& from);

  inline BridgeList& operator=(const BridgeList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BridgeList(BridgeList&& from) noexcept
    : BridgeList() {
    *this = ::std::move(from);
  }

  inline BridgeList& operator=(BridgeList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BridgeList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BridgeList* internal_default_instance() {
    return reinterpret_cast<const BridgeList*>(
               &_BridgeList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    148;

  void Swap(BridgeList* other);
  friend void swap(BridgeList& a, BridgeList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BridgeList* New() const PROTOBUF_FINAL { return New(NULL); }

  BridgeList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BridgeList& from);
  void MergeFrom(const BridgeList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BridgeList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.BridgeConfig bridgeConfig = 1;
  int bridgeconfig_size() const;
  void clear_bridgeconfig();
  static const int kBridgeConfigFieldNumber = 1;
  const ::Kinova::Api::Base::BridgeConfig& bridgeconfig(int index) const;
  ::Kinova::Api::Base::BridgeConfig* mutable_bridgeconfig(int index);
  ::Kinova::Api::Base::BridgeConfig* add_bridgeconfig();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::BridgeConfig >*
      mutable_bridgeconfig();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::BridgeConfig >&
      bridgeconfig() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.BridgeList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::BridgeConfig > bridgeconfig_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsBridgeListImpl();
};
// -------------------------------------------------------------------

class BridgeResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.BridgeResult) */ {
 public:
  BridgeResult();
  virtual ~BridgeResult();

  BridgeResult(const BridgeResult& from);

  inline BridgeResult& operator=(const BridgeResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BridgeResult(BridgeResult&& from) noexcept
    : BridgeResult() {
    *this = ::std::move(from);
  }

  inline BridgeResult& operator=(BridgeResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BridgeResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BridgeResult* internal_default_instance() {
    return reinterpret_cast<const BridgeResult*>(
               &_BridgeResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    149;

  void Swap(BridgeResult* other);
  friend void swap(BridgeResult& a, BridgeResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BridgeResult* New() const PROTOBUF_FINAL { return New(NULL); }

  BridgeResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BridgeResult& from);
  void MergeFrom(const BridgeResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BridgeResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.BridgeIdentifier bridge_id = 1;
  bool has_bridge_id() const;
  void clear_bridge_id();
  static const int kBridgeIdFieldNumber = 1;
  const ::Kinova::Api::Base::BridgeIdentifier& bridge_id() const;
  ::Kinova::Api::Base::BridgeIdentifier* release_bridge_id();
  ::Kinova::Api::Base::BridgeIdentifier* mutable_bridge_id();
  void set_allocated_bridge_id(::Kinova::Api::Base::BridgeIdentifier* bridge_id);

  // .Kinova.Api.Base.BridgeStatus status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::Kinova::Api::Base::BridgeStatus status() const;
  void set_status(::Kinova::Api::Base::BridgeStatus value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.BridgeResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::BridgeIdentifier* bridge_id_;
  int status_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsBridgeResultImpl();
};
// -------------------------------------------------------------------

class BridgeIdentifier : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.BridgeIdentifier) */ {
 public:
  BridgeIdentifier();
  virtual ~BridgeIdentifier();

  BridgeIdentifier(const BridgeIdentifier& from);

  inline BridgeIdentifier& operator=(const BridgeIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BridgeIdentifier(BridgeIdentifier&& from) noexcept
    : BridgeIdentifier() {
    *this = ::std::move(from);
  }

  inline BridgeIdentifier& operator=(BridgeIdentifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BridgeIdentifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BridgeIdentifier* internal_default_instance() {
    return reinterpret_cast<const BridgeIdentifier*>(
               &_BridgeIdentifier_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    150;

  void Swap(BridgeIdentifier* other);
  friend void swap(BridgeIdentifier& a, BridgeIdentifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BridgeIdentifier* New() const PROTOBUF_FINAL { return New(NULL); }

  BridgeIdentifier* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BridgeIdentifier& from);
  void MergeFrom(const BridgeIdentifier& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BridgeIdentifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 bridge_id = 1;
  void clear_bridge_id();
  static const int kBridgeIdFieldNumber = 1;
  ::google::protobuf::uint32 bridge_id() const;
  void set_bridge_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.BridgeIdentifier)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 bridge_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsBridgeIdentifierImpl();
};
// -------------------------------------------------------------------

class BridgeConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.BridgeConfig) */ {
 public:
  BridgeConfig();
  virtual ~BridgeConfig();

  BridgeConfig(const BridgeConfig& from);

  inline BridgeConfig& operator=(const BridgeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BridgeConfig(BridgeConfig&& from) noexcept
    : BridgeConfig() {
    *this = ::std::move(from);
  }

  inline BridgeConfig& operator=(BridgeConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BridgeConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BridgeConfig* internal_default_instance() {
    return reinterpret_cast<const BridgeConfig*>(
               &_BridgeConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    151;

  void Swap(BridgeConfig* other);
  friend void swap(BridgeConfig& a, BridgeConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BridgeConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  BridgeConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BridgeConfig& from);
  void MergeFrom(const BridgeConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BridgeConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.BridgePortConfig port_config = 3;
  bool has_port_config() const;
  void clear_port_config();
  static const int kPortConfigFieldNumber = 3;
  const ::Kinova::Api::Base::BridgePortConfig& port_config() const;
  ::Kinova::Api::Base::BridgePortConfig* release_port_config();
  ::Kinova::Api::Base::BridgePortConfig* mutable_port_config();
  void set_allocated_port_config(::Kinova::Api::Base::BridgePortConfig* port_config);

  // .Kinova.Api.Base.BridgeIdentifier bridge_id = 4;
  bool has_bridge_id() const;
  void clear_bridge_id();
  static const int kBridgeIdFieldNumber = 4;
  const ::Kinova::Api::Base::BridgeIdentifier& bridge_id() const;
  ::Kinova::Api::Base::BridgeIdentifier* release_bridge_id();
  ::Kinova::Api::Base::BridgeIdentifier* mutable_bridge_id();
  void set_allocated_bridge_id(::Kinova::Api::Base::BridgeIdentifier* bridge_id);

  // uint32 device_identifier = 1;
  void clear_device_identifier();
  static const int kDeviceIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 device_identifier() const;
  void set_device_identifier(::google::protobuf::uint32 value);

  // .Kinova.Api.Base.BridgeType bridgetype = 2;
  void clear_bridgetype();
  static const int kBridgetypeFieldNumber = 2;
  ::Kinova::Api::Base::BridgeType bridgetype() const;
  void set_bridgetype(::Kinova::Api::Base::BridgeType value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.BridgeConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::BridgePortConfig* port_config_;
  ::Kinova::Api::Base::BridgeIdentifier* bridge_id_;
  ::google::protobuf::uint32 device_identifier_;
  int bridgetype_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsBridgeConfigImpl();
};
// -------------------------------------------------------------------

class BridgePortConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.BridgePortConfig) */ {
 public:
  BridgePortConfig();
  virtual ~BridgePortConfig();

  BridgePortConfig(const BridgePortConfig& from);

  inline BridgePortConfig& operator=(const BridgePortConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BridgePortConfig(BridgePortConfig&& from) noexcept
    : BridgePortConfig() {
    *this = ::std::move(from);
  }

  inline BridgePortConfig& operator=(BridgePortConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BridgePortConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BridgePortConfig* internal_default_instance() {
    return reinterpret_cast<const BridgePortConfig*>(
               &_BridgePortConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    152;

  void Swap(BridgePortConfig* other);
  friend void swap(BridgePortConfig& a, BridgePortConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BridgePortConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  BridgePortConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BridgePortConfig& from);
  void MergeFrom(const BridgePortConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BridgePortConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target_port = 1;
  void clear_target_port();
  static const int kTargetPortFieldNumber = 1;
  ::google::protobuf::uint32 target_port() const;
  void set_target_port(::google::protobuf::uint32 value);

  // uint32 out_port = 2;
  void clear_out_port();
  static const int kOutPortFieldNumber = 2;
  ::google::protobuf::uint32 out_port() const;
  void set_out_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.BridgePortConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_port_;
  ::google::protobuf::uint32 out_port_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsBridgePortConfigImpl();
};
// -------------------------------------------------------------------

class PreComputedJointTrajectory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.PreComputedJointTrajectory) */ {
 public:
  PreComputedJointTrajectory();
  virtual ~PreComputedJointTrajectory();

  PreComputedJointTrajectory(const PreComputedJointTrajectory& from);

  inline PreComputedJointTrajectory& operator=(const PreComputedJointTrajectory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PreComputedJointTrajectory(PreComputedJointTrajectory&& from) noexcept
    : PreComputedJointTrajectory() {
    *this = ::std::move(from);
  }

  inline PreComputedJointTrajectory& operator=(PreComputedJointTrajectory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PreComputedJointTrajectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PreComputedJointTrajectory* internal_default_instance() {
    return reinterpret_cast<const PreComputedJointTrajectory*>(
               &_PreComputedJointTrajectory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    153;

  void Swap(PreComputedJointTrajectory* other);
  friend void swap(PreComputedJointTrajectory& a, PreComputedJointTrajectory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PreComputedJointTrajectory* New() const PROTOBUF_FINAL { return New(NULL); }

  PreComputedJointTrajectory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PreComputedJointTrajectory& from);
  void MergeFrom(const PreComputedJointTrajectory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PreComputedJointTrajectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.PreComputedJointTrajectoryElement trajectory_elements = 2;
  int trajectory_elements_size() const;
  void clear_trajectory_elements();
  static const int kTrajectoryElementsFieldNumber = 2;
  const ::Kinova::Api::Base::PreComputedJointTrajectoryElement& trajectory_elements(int index) const;
  ::Kinova::Api::Base::PreComputedJointTrajectoryElement* mutable_trajectory_elements(int index);
  ::Kinova::Api::Base::PreComputedJointTrajectoryElement* add_trajectory_elements();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::PreComputedJointTrajectoryElement >*
      mutable_trajectory_elements();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::PreComputedJointTrajectoryElement >&
      trajectory_elements() const;

  // .Kinova.Api.Base.TrajectoryContinuityMode mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::Kinova::Api::Base::TrajectoryContinuityMode mode() const;
  void set_mode(::Kinova::Api::Base::TrajectoryContinuityMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.PreComputedJointTrajectory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::PreComputedJointTrajectoryElement > trajectory_elements_;
  int mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsPreComputedJointTrajectoryImpl();
};
// -------------------------------------------------------------------

class PreComputedJointTrajectoryElement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.PreComputedJointTrajectoryElement) */ {
 public:
  PreComputedJointTrajectoryElement();
  virtual ~PreComputedJointTrajectoryElement();

  PreComputedJointTrajectoryElement(const PreComputedJointTrajectoryElement& from);

  inline PreComputedJointTrajectoryElement& operator=(const PreComputedJointTrajectoryElement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PreComputedJointTrajectoryElement(PreComputedJointTrajectoryElement&& from) noexcept
    : PreComputedJointTrajectoryElement() {
    *this = ::std::move(from);
  }

  inline PreComputedJointTrajectoryElement& operator=(PreComputedJointTrajectoryElement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PreComputedJointTrajectoryElement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PreComputedJointTrajectoryElement* internal_default_instance() {
    return reinterpret_cast<const PreComputedJointTrajectoryElement*>(
               &_PreComputedJointTrajectoryElement_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    154;

  void Swap(PreComputedJointTrajectoryElement* other);
  friend void swap(PreComputedJointTrajectoryElement& a, PreComputedJointTrajectoryElement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PreComputedJointTrajectoryElement* New() const PROTOBUF_FINAL { return New(NULL); }

  PreComputedJointTrajectoryElement* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PreComputedJointTrajectoryElement& from);
  void MergeFrom(const PreComputedJointTrajectoryElement& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PreComputedJointTrajectoryElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float joint_angles = 1;
  int joint_angles_size() const;
  void clear_joint_angles();
  static const int kJointAnglesFieldNumber = 1;
  float joint_angles(int index) const;
  void set_joint_angles(int index, float value);
  void add_joint_angles(float value);
  const ::google::protobuf::RepeatedField< float >&
      joint_angles() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_joint_angles();

  // repeated float joint_speeds = 2;
  int joint_speeds_size() const;
  void clear_joint_speeds();
  static const int kJointSpeedsFieldNumber = 2;
  float joint_speeds(int index) const;
  void set_joint_speeds(int index, float value);
  void add_joint_speeds(float value);
  const ::google::protobuf::RepeatedField< float >&
      joint_speeds() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_joint_speeds();

  // repeated float joint_accelerations = 3;
  int joint_accelerations_size() const;
  void clear_joint_accelerations();
  static const int kJointAccelerationsFieldNumber = 3;
  float joint_accelerations(int index) const;
  void set_joint_accelerations(int index, float value);
  void add_joint_accelerations(float value);
  const ::google::protobuf::RepeatedField< float >&
      joint_accelerations() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_joint_accelerations();

  // float time_from_start = 4;
  void clear_time_from_start();
  static const int kTimeFromStartFieldNumber = 4;
  float time_from_start() const;
  void set_time_from_start(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.PreComputedJointTrajectoryElement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > joint_angles_;
  mutable int _joint_angles_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > joint_speeds_;
  mutable int _joint_speeds_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > joint_accelerations_;
  mutable int _joint_accelerations_cached_byte_size_;
  float time_from_start_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsPreComputedJointTrajectoryElementImpl();
};
// -------------------------------------------------------------------

class TrajectoryErrorElement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.TrajectoryErrorElement) */ {
 public:
  TrajectoryErrorElement();
  virtual ~TrajectoryErrorElement();

  TrajectoryErrorElement(const TrajectoryErrorElement& from);

  inline TrajectoryErrorElement& operator=(const TrajectoryErrorElement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrajectoryErrorElement(TrajectoryErrorElement&& from) noexcept
    : TrajectoryErrorElement() {
    *this = ::std::move(from);
  }

  inline TrajectoryErrorElement& operator=(TrajectoryErrorElement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryErrorElement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryErrorElement* internal_default_instance() {
    return reinterpret_cast<const TrajectoryErrorElement*>(
               &_TrajectoryErrorElement_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    155;

  void Swap(TrajectoryErrorElement* other);
  friend void swap(TrajectoryErrorElement& a, TrajectoryErrorElement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryErrorElement* New() const PROTOBUF_FINAL { return New(NULL); }

  TrajectoryErrorElement* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrajectoryErrorElement& from);
  void MergeFrom(const TrajectoryErrorElement& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrajectoryErrorElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 7;
  void clear_message();
  static const int kMessageFieldNumber = 7;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // .Kinova.Api.Base.TrajectoryErrorType error_type = 1;
  void clear_error_type();
  static const int kErrorTypeFieldNumber = 1;
  ::Kinova::Api::Base::TrajectoryErrorType error_type() const;
  void set_error_type(::Kinova::Api::Base::TrajectoryErrorType value);

  // .Kinova.Api.Base.TrajectoryErrorIdentifier error_identifier = 2 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_error_identifier();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kErrorIdentifierFieldNumber = 2;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::Kinova::Api::Base::TrajectoryErrorIdentifier error_identifier() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_error_identifier(::Kinova::Api::Base::TrajectoryErrorIdentifier value);

  // float error_value = 3;
  void clear_error_value();
  static const int kErrorValueFieldNumber = 3;
  float error_value() const;
  void set_error_value(float value);

  // float min_value = 4;
  void clear_min_value();
  static const int kMinValueFieldNumber = 4;
  float min_value() const;
  void set_min_value(float value);

  // float max_value = 5;
  void clear_max_value();
  static const int kMaxValueFieldNumber = 5;
  float max_value() const;
  void set_max_value(float value);

  // uint32 index = 6;
  void clear_index();
  static const int kIndexFieldNumber = 6;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // uint32 waypoint_index = 8;
  void clear_waypoint_index();
  static const int kWaypointIndexFieldNumber = 8;
  ::google::protobuf::uint32 waypoint_index() const;
  void set_waypoint_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.TrajectoryErrorElement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int error_type_;
  int error_identifier_;
  float error_value_;
  float min_value_;
  float max_value_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 waypoint_index_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsTrajectoryErrorElementImpl();
};
// -------------------------------------------------------------------

class TrajectoryErrorReport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.TrajectoryErrorReport) */ {
 public:
  TrajectoryErrorReport();
  virtual ~TrajectoryErrorReport();

  TrajectoryErrorReport(const TrajectoryErrorReport& from);

  inline TrajectoryErrorReport& operator=(const TrajectoryErrorReport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrajectoryErrorReport(TrajectoryErrorReport&& from) noexcept
    : TrajectoryErrorReport() {
    *this = ::std::move(from);
  }

  inline TrajectoryErrorReport& operator=(TrajectoryErrorReport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryErrorReport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryErrorReport* internal_default_instance() {
    return reinterpret_cast<const TrajectoryErrorReport*>(
               &_TrajectoryErrorReport_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    156;

  void Swap(TrajectoryErrorReport* other);
  friend void swap(TrajectoryErrorReport& a, TrajectoryErrorReport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryErrorReport* New() const PROTOBUF_FINAL { return New(NULL); }

  TrajectoryErrorReport* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrajectoryErrorReport& from);
  void MergeFrom(const TrajectoryErrorReport& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrajectoryErrorReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.TrajectoryErrorElement trajectory_error_elements = 1;
  int trajectory_error_elements_size() const;
  void clear_trajectory_error_elements();
  static const int kTrajectoryErrorElementsFieldNumber = 1;
  const ::Kinova::Api::Base::TrajectoryErrorElement& trajectory_error_elements(int index) const;
  ::Kinova::Api::Base::TrajectoryErrorElement* mutable_trajectory_error_elements(int index);
  ::Kinova::Api::Base::TrajectoryErrorElement* add_trajectory_error_elements();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::TrajectoryErrorElement >*
      mutable_trajectory_error_elements();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::TrajectoryErrorElement >&
      trajectory_error_elements() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.TrajectoryErrorReport)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::TrajectoryErrorElement > trajectory_error_elements_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsTrajectoryErrorReportImpl();
};
// -------------------------------------------------------------------

class WaypointValidationReport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.WaypointValidationReport) */ {
 public:
  WaypointValidationReport();
  virtual ~WaypointValidationReport();

  WaypointValidationReport(const WaypointValidationReport& from);

  inline WaypointValidationReport& operator=(const WaypointValidationReport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaypointValidationReport(WaypointValidationReport&& from) noexcept
    : WaypointValidationReport() {
    *this = ::std::move(from);
  }

  inline WaypointValidationReport& operator=(WaypointValidationReport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaypointValidationReport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaypointValidationReport* internal_default_instance() {
    return reinterpret_cast<const WaypointValidationReport*>(
               &_WaypointValidationReport_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    157;

  void Swap(WaypointValidationReport* other);
  friend void swap(WaypointValidationReport& a, WaypointValidationReport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaypointValidationReport* New() const PROTOBUF_FINAL { return New(NULL); }

  WaypointValidationReport* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WaypointValidationReport& from);
  void MergeFrom(const WaypointValidationReport& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WaypointValidationReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.TrajectoryErrorReport trajectory_error_report = 1;
  bool has_trajectory_error_report() const;
  void clear_trajectory_error_report();
  static const int kTrajectoryErrorReportFieldNumber = 1;
  const ::Kinova::Api::Base::TrajectoryErrorReport& trajectory_error_report() const;
  ::Kinova::Api::Base::TrajectoryErrorReport* release_trajectory_error_report();
  ::Kinova::Api::Base::TrajectoryErrorReport* mutable_trajectory_error_report();
  void set_allocated_trajectory_error_report(::Kinova::Api::Base::TrajectoryErrorReport* trajectory_error_report);

  // .Kinova.Api.Base.WaypointList optimal_waypoint_list = 2;
  bool has_optimal_waypoint_list() const;
  void clear_optimal_waypoint_list();
  static const int kOptimalWaypointListFieldNumber = 2;
  const ::Kinova::Api::Base::WaypointList& optimal_waypoint_list() const;
  ::Kinova::Api::Base::WaypointList* release_optimal_waypoint_list();
  ::Kinova::Api::Base::WaypointList* mutable_optimal_waypoint_list();
  void set_allocated_optimal_waypoint_list(::Kinova::Api::Base::WaypointList* optimal_waypoint_list);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.WaypointValidationReport)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::TrajectoryErrorReport* trajectory_error_report_;
  ::Kinova::Api::Base::WaypointList* optimal_waypoint_list_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsWaypointValidationReportImpl();
};
// -------------------------------------------------------------------

class Waypoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.Waypoint) */ {
 public:
  Waypoint();
  virtual ~Waypoint();

  Waypoint(const Waypoint& from);

  inline Waypoint& operator=(const Waypoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Waypoint(Waypoint&& from) noexcept
    : Waypoint() {
    *this = ::std::move(from);
  }

  inline Waypoint& operator=(Waypoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Waypoint& default_instance();

  enum TypeOfWaypointCase {
    kAngularWaypoint = 2,
    kCartesianWaypoint = 3,
    TYPE_OF_WAYPOINT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Waypoint* internal_default_instance() {
    return reinterpret_cast<const Waypoint*>(
               &_Waypoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    158;

  void Swap(Waypoint* other);
  friend void swap(Waypoint& a, Waypoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Waypoint* New() const PROTOBUF_FINAL { return New(NULL); }

  Waypoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Waypoint& from);
  void MergeFrom(const Waypoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Waypoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Kinova.Api.Base.AngularWaypoint angular_waypoint = 2;
  bool has_angular_waypoint() const;
  void clear_angular_waypoint();
  static const int kAngularWaypointFieldNumber = 2;
  const ::Kinova::Api::Base::AngularWaypoint& angular_waypoint() const;
  ::Kinova::Api::Base::AngularWaypoint* release_angular_waypoint();
  ::Kinova::Api::Base::AngularWaypoint* mutable_angular_waypoint();
  void set_allocated_angular_waypoint(::Kinova::Api::Base::AngularWaypoint* angular_waypoint);

  // .Kinova.Api.Base.CartesianWaypoint cartesian_waypoint = 3;
  bool has_cartesian_waypoint() const;
  void clear_cartesian_waypoint();
  static const int kCartesianWaypointFieldNumber = 3;
  const ::Kinova::Api::Base::CartesianWaypoint& cartesian_waypoint() const;
  ::Kinova::Api::Base::CartesianWaypoint* release_cartesian_waypoint();
  ::Kinova::Api::Base::CartesianWaypoint* mutable_cartesian_waypoint();
  void set_allocated_cartesian_waypoint(::Kinova::Api::Base::CartesianWaypoint* cartesian_waypoint);

  TypeOfWaypointCase type_of_waypoint_case() const;
  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.Waypoint)
 private:
  void set_has_angular_waypoint();
  void set_has_cartesian_waypoint();

  inline bool has_type_of_waypoint() const;
  void clear_type_of_waypoint();
  inline void clear_has_type_of_waypoint();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  union TypeOfWaypointUnion {
    TypeOfWaypointUnion() {}
    ::Kinova::Api::Base::AngularWaypoint* angular_waypoint_;
    ::Kinova::Api::Base::CartesianWaypoint* cartesian_waypoint_;
  } type_of_waypoint_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsWaypointImpl();
};
// -------------------------------------------------------------------

class AngularWaypoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.AngularWaypoint) */ {
 public:
  AngularWaypoint();
  virtual ~AngularWaypoint();

  AngularWaypoint(const AngularWaypoint& from);

  inline AngularWaypoint& operator=(const AngularWaypoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AngularWaypoint(AngularWaypoint&& from) noexcept
    : AngularWaypoint() {
    *this = ::std::move(from);
  }

  inline AngularWaypoint& operator=(AngularWaypoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AngularWaypoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AngularWaypoint* internal_default_instance() {
    return reinterpret_cast<const AngularWaypoint*>(
               &_AngularWaypoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    159;

  void Swap(AngularWaypoint* other);
  friend void swap(AngularWaypoint& a, AngularWaypoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AngularWaypoint* New() const PROTOBUF_FINAL { return New(NULL); }

  AngularWaypoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AngularWaypoint& from);
  void MergeFrom(const AngularWaypoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AngularWaypoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float angles = 1;
  int angles_size() const;
  void clear_angles();
  static const int kAnglesFieldNumber = 1;
  float angles(int index) const;
  void set_angles(int index, float value);
  void add_angles(float value);
  const ::google::protobuf::RepeatedField< float >&
      angles() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_angles();

  // repeated float maximum_velocities = 2;
  int maximum_velocities_size() const;
  void clear_maximum_velocities();
  static const int kMaximumVelocitiesFieldNumber = 2;
  float maximum_velocities(int index) const;
  void set_maximum_velocities(int index, float value);
  void add_maximum_velocities(float value);
  const ::google::protobuf::RepeatedField< float >&
      maximum_velocities() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_maximum_velocities();

  // float duration = 3;
  void clear_duration();
  static const int kDurationFieldNumber = 3;
  float duration() const;
  void set_duration(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.AngularWaypoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > angles_;
  mutable int _angles_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > maximum_velocities_;
  mutable int _maximum_velocities_cached_byte_size_;
  float duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsAngularWaypointImpl();
};
// -------------------------------------------------------------------

class CartesianWaypoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.CartesianWaypoint) */ {
 public:
  CartesianWaypoint();
  virtual ~CartesianWaypoint();

  CartesianWaypoint(const CartesianWaypoint& from);

  inline CartesianWaypoint& operator=(const CartesianWaypoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianWaypoint(CartesianWaypoint&& from) noexcept
    : CartesianWaypoint() {
    *this = ::std::move(from);
  }

  inline CartesianWaypoint& operator=(CartesianWaypoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianWaypoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianWaypoint* internal_default_instance() {
    return reinterpret_cast<const CartesianWaypoint*>(
               &_CartesianWaypoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    160;

  void Swap(CartesianWaypoint* other);
  friend void swap(CartesianWaypoint& a, CartesianWaypoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianWaypoint* New() const PROTOBUF_FINAL { return New(NULL); }

  CartesianWaypoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CartesianWaypoint& from);
  void MergeFrom(const CartesianWaypoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CartesianWaypoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.Pose pose = 1;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 1;
  const ::Kinova::Api::Base::Pose& pose() const;
  ::Kinova::Api::Base::Pose* release_pose();
  ::Kinova::Api::Base::Pose* mutable_pose();
  void set_allocated_pose(::Kinova::Api::Base::Pose* pose);

  // .Kinova.Api.Common.CartesianReferenceFrame reference_frame = 2;
  void clear_reference_frame();
  static const int kReferenceFrameFieldNumber = 2;
  ::Kinova::Api::Common::CartesianReferenceFrame reference_frame() const;
  void set_reference_frame(::Kinova::Api::Common::CartesianReferenceFrame value);

  // float maximum_linear_velocity = 3;
  void clear_maximum_linear_velocity();
  static const int kMaximumLinearVelocityFieldNumber = 3;
  float maximum_linear_velocity() const;
  void set_maximum_linear_velocity(float value);

  // float maximum_angular_velocity = 4;
  void clear_maximum_angular_velocity();
  static const int kMaximumAngularVelocityFieldNumber = 4;
  float maximum_angular_velocity() const;
  void set_maximum_angular_velocity(float value);

  // float blending_radius = 5;
  void clear_blending_radius();
  static const int kBlendingRadiusFieldNumber = 5;
  float blending_radius() const;
  void set_blending_radius(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.CartesianWaypoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::Pose* pose_;
  int reference_frame_;
  float maximum_linear_velocity_;
  float maximum_angular_velocity_;
  float blending_radius_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsCartesianWaypointImpl();
};
// -------------------------------------------------------------------

class WaypointList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.WaypointList) */ {
 public:
  WaypointList();
  virtual ~WaypointList();

  WaypointList(const WaypointList& from);

  inline WaypointList& operator=(const WaypointList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaypointList(WaypointList&& from) noexcept
    : WaypointList() {
    *this = ::std::move(from);
  }

  inline WaypointList& operator=(WaypointList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaypointList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaypointList* internal_default_instance() {
    return reinterpret_cast<const WaypointList*>(
               &_WaypointList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    161;

  void Swap(WaypointList* other);
  friend void swap(WaypointList& a, WaypointList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaypointList* New() const PROTOBUF_FINAL { return New(NULL); }

  WaypointList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WaypointList& from);
  void MergeFrom(const WaypointList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WaypointList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.Waypoint waypoints = 1;
  int waypoints_size() const;
  void clear_waypoints();
  static const int kWaypointsFieldNumber = 1;
  const ::Kinova::Api::Base::Waypoint& waypoints(int index) const;
  ::Kinova::Api::Base::Waypoint* mutable_waypoints(int index);
  ::Kinova::Api::Base::Waypoint* add_waypoints();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Waypoint >*
      mutable_waypoints();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Waypoint >&
      waypoints() const;

  // float duration = 2;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  float duration() const;
  void set_duration(float value);

  // bool use_optimal_blending = 3;
  void clear_use_optimal_blending();
  static const int kUseOptimalBlendingFieldNumber = 3;
  bool use_optimal_blending() const;
  void set_use_optimal_blending(bool value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.WaypointList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Waypoint > waypoints_;
  float duration_;
  bool use_optimal_blending_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsWaypointListImpl();
};
// -------------------------------------------------------------------

class KinematicTrajectoryConstraints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.KinematicTrajectoryConstraints) */ {
 public:
  KinematicTrajectoryConstraints();
  virtual ~KinematicTrajectoryConstraints();

  KinematicTrajectoryConstraints(const KinematicTrajectoryConstraints& from);

  inline KinematicTrajectoryConstraints& operator=(const KinematicTrajectoryConstraints& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KinematicTrajectoryConstraints(KinematicTrajectoryConstraints&& from) noexcept
    : KinematicTrajectoryConstraints() {
    *this = ::std::move(from);
  }

  inline KinematicTrajectoryConstraints& operator=(KinematicTrajectoryConstraints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KinematicTrajectoryConstraints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KinematicTrajectoryConstraints* internal_default_instance() {
    return reinterpret_cast<const KinematicTrajectoryConstraints*>(
               &_KinematicTrajectoryConstraints_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    162;

  void Swap(KinematicTrajectoryConstraints* other);
  friend void swap(KinematicTrajectoryConstraints& a, KinematicTrajectoryConstraints& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KinematicTrajectoryConstraints* New() const PROTOBUF_FINAL { return New(NULL); }

  KinematicTrajectoryConstraints* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KinematicTrajectoryConstraints& from);
  void MergeFrom(const KinematicTrajectoryConstraints& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KinematicTrajectoryConstraints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float angular_velocities = 1;
  int angular_velocities_size() const;
  void clear_angular_velocities();
  static const int kAngularVelocitiesFieldNumber = 1;
  float angular_velocities(int index) const;
  void set_angular_velocities(int index, float value);
  void add_angular_velocities(float value);
  const ::google::protobuf::RepeatedField< float >&
      angular_velocities() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_angular_velocities();

  // float linear_velocity = 2;
  void clear_linear_velocity();
  static const int kLinearVelocityFieldNumber = 2;
  float linear_velocity() const;
  void set_linear_velocity(float value);

  // float angular_velocity = 3;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 3;
  float angular_velocity() const;
  void set_angular_velocity(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.KinematicTrajectoryConstraints)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > angular_velocities_;
  mutable int _angular_velocities_cached_byte_size_;
  float linear_velocity_;
  float angular_velocity_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsKinematicTrajectoryConstraintsImpl();
};
// -------------------------------------------------------------------

class FirmwareBundleVersions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.FirmwareBundleVersions) */ {
 public:
  FirmwareBundleVersions();
  virtual ~FirmwareBundleVersions();

  FirmwareBundleVersions(const FirmwareBundleVersions& from);

  inline FirmwareBundleVersions& operator=(const FirmwareBundleVersions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FirmwareBundleVersions(FirmwareBundleVersions&& from) noexcept
    : FirmwareBundleVersions() {
    *this = ::std::move(from);
  }

  inline FirmwareBundleVersions& operator=(FirmwareBundleVersions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FirmwareBundleVersions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FirmwareBundleVersions* internal_default_instance() {
    return reinterpret_cast<const FirmwareBundleVersions*>(
               &_FirmwareBundleVersions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    163;

  void Swap(FirmwareBundleVersions* other);
  friend void swap(FirmwareBundleVersions& a, FirmwareBundleVersions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FirmwareBundleVersions* New() const PROTOBUF_FINAL { return New(NULL); }

  FirmwareBundleVersions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FirmwareBundleVersions& from);
  void MergeFrom(const FirmwareBundleVersions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FirmwareBundleVersions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.Base.FirmwareComponentVersion components_versions = 2;
  int components_versions_size() const;
  void clear_components_versions();
  static const int kComponentsVersionsFieldNumber = 2;
  const ::Kinova::Api::Base::FirmwareComponentVersion& components_versions(int index) const;
  ::Kinova::Api::Base::FirmwareComponentVersion* mutable_components_versions(int index);
  ::Kinova::Api::Base::FirmwareComponentVersion* add_components_versions();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::FirmwareComponentVersion >*
      mutable_components_versions();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::FirmwareComponentVersion >&
      components_versions() const;

  // string main_bundle_version = 1;
  void clear_main_bundle_version();
  static const int kMainBundleVersionFieldNumber = 1;
  const ::std::string& main_bundle_version() const;
  void set_main_bundle_version(const ::std::string& value);
  #if LANG_CXX11
  void set_main_bundle_version(::std::string&& value);
  #endif
  void set_main_bundle_version(const char* value);
  void set_main_bundle_version(const char* value, size_t size);
  ::std::string* mutable_main_bundle_version();
  ::std::string* release_main_bundle_version();
  void set_allocated_main_bundle_version(::std::string* main_bundle_version);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.FirmwareBundleVersions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::FirmwareComponentVersion > components_versions_;
  ::google::protobuf::internal::ArenaStringPtr main_bundle_version_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsFirmwareBundleVersionsImpl();
};
// -------------------------------------------------------------------

class FirmwareComponentVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.FirmwareComponentVersion) */ {
 public:
  FirmwareComponentVersion();
  virtual ~FirmwareComponentVersion();

  FirmwareComponentVersion(const FirmwareComponentVersion& from);

  inline FirmwareComponentVersion& operator=(const FirmwareComponentVersion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FirmwareComponentVersion(FirmwareComponentVersion&& from) noexcept
    : FirmwareComponentVersion() {
    *this = ::std::move(from);
  }

  inline FirmwareComponentVersion& operator=(FirmwareComponentVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FirmwareComponentVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FirmwareComponentVersion* internal_default_instance() {
    return reinterpret_cast<const FirmwareComponentVersion*>(
               &_FirmwareComponentVersion_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    164;

  void Swap(FirmwareComponentVersion* other);
  friend void swap(FirmwareComponentVersion& a, FirmwareComponentVersion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FirmwareComponentVersion* New() const PROTOBUF_FINAL { return New(NULL); }

  FirmwareComponentVersion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FirmwareComponentVersion& from);
  void MergeFrom(const FirmwareComponentVersion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FirmwareComponentVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // uint32 device_id = 3;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 3;
  ::google::protobuf::uint32 device_id() const;
  void set_device_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.FirmwareComponentVersion)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::uint32 device_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsFirmwareComponentVersionImpl();
};
// -------------------------------------------------------------------

class IKData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Base.IKData) */ {
 public:
  IKData();
  virtual ~IKData();

  IKData(const IKData& from);

  inline IKData& operator=(const IKData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IKData(IKData&& from) noexcept
    : IKData() {
    *this = ::std::move(from);
  }

  inline IKData& operator=(IKData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IKData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IKData* internal_default_instance() {
    return reinterpret_cast<const IKData*>(
               &_IKData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    165;

  void Swap(IKData* other);
  friend void swap(IKData& a, IKData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IKData* New() const PROTOBUF_FINAL { return New(NULL); }

  IKData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IKData& from);
  void MergeFrom(const IKData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IKData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Base.Pose cartesian_pose = 1;
  bool has_cartesian_pose() const;
  void clear_cartesian_pose();
  static const int kCartesianPoseFieldNumber = 1;
  const ::Kinova::Api::Base::Pose& cartesian_pose() const;
  ::Kinova::Api::Base::Pose* release_cartesian_pose();
  ::Kinova::Api::Base::Pose* mutable_cartesian_pose();
  void set_allocated_cartesian_pose(::Kinova::Api::Base::Pose* cartesian_pose);

  // .Kinova.Api.Base.JointAngles guess = 2;
  bool has_guess() const;
  void clear_guess();
  static const int kGuessFieldNumber = 2;
  const ::Kinova::Api::Base::JointAngles& guess() const;
  ::Kinova::Api::Base::JointAngles* release_guess();
  ::Kinova::Api::Base::JointAngles* mutable_guess();
  void set_allocated_guess(::Kinova::Api::Base::JointAngles* guess);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Base.IKData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Base::Pose* cartesian_pose_;
  ::Kinova::Api::Base::JointAngles* guess_;
  mutable int _cached_size_;
  friend struct ::protobuf_Base_2eproto::TableStruct;
  friend void ::protobuf_Base_2eproto::InitDefaultsIKDataImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GpioConfigurationList

// repeated .Kinova.Api.Base.GpioConfiguration port_configurations = 1;
inline int GpioConfigurationList::port_configurations_size() const {
  return port_configurations_.size();
}
inline void GpioConfigurationList::clear_port_configurations() {
  port_configurations_.Clear();
}
inline const ::Kinova::Api::Base::GpioConfiguration& GpioConfigurationList::port_configurations(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GpioConfigurationList.port_configurations)
  return port_configurations_.Get(index);
}
inline ::Kinova::Api::Base::GpioConfiguration* GpioConfigurationList::mutable_port_configurations(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.GpioConfigurationList.port_configurations)
  return port_configurations_.Mutable(index);
}
inline ::Kinova::Api::Base::GpioConfiguration* GpioConfigurationList::add_port_configurations() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.GpioConfigurationList.port_configurations)
  return port_configurations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::GpioConfiguration >*
GpioConfigurationList::mutable_port_configurations() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.GpioConfigurationList.port_configurations)
  return &port_configurations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::GpioConfiguration >&
GpioConfigurationList::port_configurations() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.GpioConfigurationList.port_configurations)
  return port_configurations_;
}

// -------------------------------------------------------------------

// GpioConfiguration

// uint32 port_number = 1;
inline void GpioConfiguration::clear_port_number() {
  port_number_ = 0u;
}
inline ::google::protobuf::uint32 GpioConfiguration::port_number() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GpioConfiguration.port_number)
  return port_number_;
}
inline void GpioConfiguration::set_port_number(::google::protobuf::uint32 value) {
  
  port_number_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GpioConfiguration.port_number)
}

// repeated .Kinova.Api.Base.GpioPinConfiguration pin_configurations = 2;
inline int GpioConfiguration::pin_configurations_size() const {
  return pin_configurations_.size();
}
inline void GpioConfiguration::clear_pin_configurations() {
  pin_configurations_.Clear();
}
inline const ::Kinova::Api::Base::GpioPinConfiguration& GpioConfiguration::pin_configurations(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GpioConfiguration.pin_configurations)
  return pin_configurations_.Get(index);
}
inline ::Kinova::Api::Base::GpioPinConfiguration* GpioConfiguration::mutable_pin_configurations(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.GpioConfiguration.pin_configurations)
  return pin_configurations_.Mutable(index);
}
inline ::Kinova::Api::Base::GpioPinConfiguration* GpioConfiguration::add_pin_configurations() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.GpioConfiguration.pin_configurations)
  return pin_configurations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::GpioPinConfiguration >*
GpioConfiguration::mutable_pin_configurations() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.GpioConfiguration.pin_configurations)
  return &pin_configurations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::GpioPinConfiguration >&
GpioConfiguration::pin_configurations() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.GpioConfiguration.pin_configurations)
  return pin_configurations_;
}

// -------------------------------------------------------------------

// GpioPinConfiguration

// uint32 pin_id = 1;
inline void GpioPinConfiguration::clear_pin_id() {
  pin_id_ = 0u;
}
inline ::google::protobuf::uint32 GpioPinConfiguration::pin_id() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GpioPinConfiguration.pin_id)
  return pin_id_;
}
inline void GpioPinConfiguration::set_pin_id(::google::protobuf::uint32 value) {
  
  pin_id_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GpioPinConfiguration.pin_id)
}

// .Kinova.Api.Base.GpioPinPropertyFlags pin_property = 2;
inline void GpioPinConfiguration::clear_pin_property() {
  pin_property_ = 0;
}
inline ::Kinova::Api::Base::GpioPinPropertyFlags GpioPinConfiguration::pin_property() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GpioPinConfiguration.pin_property)
  return static_cast< ::Kinova::Api::Base::GpioPinPropertyFlags >(pin_property_);
}
inline void GpioPinConfiguration::set_pin_property(::Kinova::Api::Base::GpioPinPropertyFlags value) {
  
  pin_property_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GpioPinConfiguration.pin_property)
}

// bool output_enable = 3;
inline void GpioPinConfiguration::clear_output_enable() {
  output_enable_ = false;
}
inline bool GpioPinConfiguration::output_enable() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GpioPinConfiguration.output_enable)
  return output_enable_;
}
inline void GpioPinConfiguration::set_output_enable(bool value) {
  
  output_enable_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GpioPinConfiguration.output_enable)
}

// bool default_output_value = 4;
inline void GpioPinConfiguration::clear_default_output_value() {
  default_output_value_ = false;
}
inline bool GpioPinConfiguration::default_output_value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GpioPinConfiguration.default_output_value)
  return default_output_value_;
}
inline void GpioPinConfiguration::set_default_output_value(bool value) {
  
  default_output_value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GpioPinConfiguration.default_output_value)
}

// -------------------------------------------------------------------

// FullUserProfile

// .Kinova.Api.Base.UserProfile user_profile = 1;
inline bool FullUserProfile::has_user_profile() const {
  return this != internal_default_instance() && user_profile_ != NULL;
}
inline void FullUserProfile::clear_user_profile() {
  if (GetArenaNoVirtual() == NULL && user_profile_ != NULL) {
    delete user_profile_;
  }
  user_profile_ = NULL;
}
inline const ::Kinova::Api::Base::UserProfile& FullUserProfile::user_profile() const {
  const ::Kinova::Api::Base::UserProfile* p = user_profile_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.FullUserProfile.user_profile)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::UserProfile*>(
      &::Kinova::Api::Base::_UserProfile_default_instance_);
}
inline ::Kinova::Api::Base::UserProfile* FullUserProfile::release_user_profile() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.FullUserProfile.user_profile)
  
  ::Kinova::Api::Base::UserProfile* temp = user_profile_;
  user_profile_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::UserProfile* FullUserProfile::mutable_user_profile() {
  
  if (user_profile_ == NULL) {
    user_profile_ = new ::Kinova::Api::Base::UserProfile;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.FullUserProfile.user_profile)
  return user_profile_;
}
inline void FullUserProfile::set_allocated_user_profile(::Kinova::Api::Base::UserProfile* user_profile) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_profile_;
  }
  if (user_profile) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_profile = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_profile, submessage_arena);
    }
    
  } else {
    
  }
  user_profile_ = user_profile;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.FullUserProfile.user_profile)
}

// string password = 2;
inline void FullUserProfile::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FullUserProfile::password() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.FullUserProfile.password)
  return password_.GetNoArena();
}
inline void FullUserProfile::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.FullUserProfile.password)
}
#if LANG_CXX11
inline void FullUserProfile::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.FullUserProfile.password)
}
#endif
inline void FullUserProfile::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.FullUserProfile.password)
}
inline void FullUserProfile::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.FullUserProfile.password)
}
inline ::std::string* FullUserProfile::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.FullUserProfile.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FullUserProfile::release_password() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.FullUserProfile.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FullUserProfile::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.FullUserProfile.password)
}

// -------------------------------------------------------------------

// UserProfile

// .Kinova.Api.Common.UserProfileHandle handle = 1;
inline bool UserProfile::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& UserProfile::handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.UserProfile.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* UserProfile::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.UserProfile.handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* UserProfile::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.UserProfile.handle)
  return handle_;
}
inline void UserProfile::set_allocated_handle(::Kinova::Api::Common::UserProfileHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(handle_);
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.UserProfile.handle)
}

// string username = 2;
inline void UserProfile::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserProfile::username() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.UserProfile.username)
  return username_.GetNoArena();
}
inline void UserProfile::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.UserProfile.username)
}
#if LANG_CXX11
inline void UserProfile::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.UserProfile.username)
}
#endif
inline void UserProfile::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.UserProfile.username)
}
inline void UserProfile::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.UserProfile.username)
}
inline ::std::string* UserProfile::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.UserProfile.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserProfile::release_username() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.UserProfile.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserProfile::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.UserProfile.username)
}

// string firstname = 3;
inline void UserProfile::clear_firstname() {
  firstname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserProfile::firstname() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.UserProfile.firstname)
  return firstname_.GetNoArena();
}
inline void UserProfile::set_firstname(const ::std::string& value) {
  
  firstname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.UserProfile.firstname)
}
#if LANG_CXX11
inline void UserProfile::set_firstname(::std::string&& value) {
  
  firstname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.UserProfile.firstname)
}
#endif
inline void UserProfile::set_firstname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  firstname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.UserProfile.firstname)
}
inline void UserProfile::set_firstname(const char* value, size_t size) {
  
  firstname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.UserProfile.firstname)
}
inline ::std::string* UserProfile::mutable_firstname() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.UserProfile.firstname)
  return firstname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserProfile::release_firstname() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.UserProfile.firstname)
  
  return firstname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserProfile::set_allocated_firstname(::std::string* firstname) {
  if (firstname != NULL) {
    
  } else {
    
  }
  firstname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firstname);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.UserProfile.firstname)
}

// string lastname = 4;
inline void UserProfile::clear_lastname() {
  lastname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserProfile::lastname() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.UserProfile.lastname)
  return lastname_.GetNoArena();
}
inline void UserProfile::set_lastname(const ::std::string& value) {
  
  lastname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.UserProfile.lastname)
}
#if LANG_CXX11
inline void UserProfile::set_lastname(::std::string&& value) {
  
  lastname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.UserProfile.lastname)
}
#endif
inline void UserProfile::set_lastname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  lastname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.UserProfile.lastname)
}
inline void UserProfile::set_lastname(const char* value, size_t size) {
  
  lastname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.UserProfile.lastname)
}
inline ::std::string* UserProfile::mutable_lastname() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.UserProfile.lastname)
  return lastname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserProfile::release_lastname() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.UserProfile.lastname)
  
  return lastname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserProfile::set_allocated_lastname(::std::string* lastname) {
  if (lastname != NULL) {
    
  } else {
    
  }
  lastname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lastname);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.UserProfile.lastname)
}

// string application_data = 5;
inline void UserProfile::clear_application_data() {
  application_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserProfile::application_data() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.UserProfile.application_data)
  return application_data_.GetNoArena();
}
inline void UserProfile::set_application_data(const ::std::string& value) {
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.UserProfile.application_data)
}
#if LANG_CXX11
inline void UserProfile::set_application_data(::std::string&& value) {
  
  application_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.UserProfile.application_data)
}
#endif
inline void UserProfile::set_application_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.UserProfile.application_data)
}
inline void UserProfile::set_application_data(const char* value, size_t size) {
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.UserProfile.application_data)
}
inline ::std::string* UserProfile::mutable_application_data() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.UserProfile.application_data)
  return application_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserProfile::release_application_data() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.UserProfile.application_data)
  
  return application_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserProfile::set_allocated_application_data(::std::string* application_data) {
  if (application_data != NULL) {
    
  } else {
    
  }
  application_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), application_data);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.UserProfile.application_data)
}

// -------------------------------------------------------------------

// UserProfileList

// repeated .Kinova.Api.Base.UserProfile user_profiles = 1;
inline int UserProfileList::user_profiles_size() const {
  return user_profiles_.size();
}
inline void UserProfileList::clear_user_profiles() {
  user_profiles_.Clear();
}
inline const ::Kinova::Api::Base::UserProfile& UserProfileList::user_profiles(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.UserProfileList.user_profiles)
  return user_profiles_.Get(index);
}
inline ::Kinova::Api::Base::UserProfile* UserProfileList::mutable_user_profiles(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.UserProfileList.user_profiles)
  return user_profiles_.Mutable(index);
}
inline ::Kinova::Api::Base::UserProfile* UserProfileList::add_user_profiles() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.UserProfileList.user_profiles)
  return user_profiles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::UserProfile >*
UserProfileList::mutable_user_profiles() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.UserProfileList.user_profiles)
  return &user_profiles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::UserProfile >&
UserProfileList::user_profiles() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.UserProfileList.user_profiles)
  return user_profiles_;
}

// -------------------------------------------------------------------

// UserList

// repeated .Kinova.Api.Common.UserProfileHandle user_handles = 1;
inline int UserList::user_handles_size() const {
  return user_handles_.size();
}
inline const ::Kinova::Api::Common::UserProfileHandle& UserList::user_handles(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.UserList.user_handles)
  return user_handles_.Get(index);
}
inline ::Kinova::Api::Common::UserProfileHandle* UserList::mutable_user_handles(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.UserList.user_handles)
  return user_handles_.Mutable(index);
}
inline ::Kinova::Api::Common::UserProfileHandle* UserList::add_user_handles() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.UserList.user_handles)
  return user_handles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Common::UserProfileHandle >*
UserList::mutable_user_handles() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.UserList.user_handles)
  return &user_handles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Common::UserProfileHandle >&
UserList::user_handles() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.UserList.user_handles)
  return user_handles_;
}

// -------------------------------------------------------------------

// PasswordChange

// .Kinova.Api.Common.UserProfileHandle handle = 1;
inline bool PasswordChange::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& PasswordChange::handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.PasswordChange.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* PasswordChange::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.PasswordChange.handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* PasswordChange::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.PasswordChange.handle)
  return handle_;
}
inline void PasswordChange::set_allocated_handle(::Kinova::Api::Common::UserProfileHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(handle_);
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.PasswordChange.handle)
}

// string old_password = 2;
inline void PasswordChange::clear_old_password() {
  old_password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PasswordChange::old_password() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.PasswordChange.old_password)
  return old_password_.GetNoArena();
}
inline void PasswordChange::set_old_password(const ::std::string& value) {
  
  old_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.PasswordChange.old_password)
}
#if LANG_CXX11
inline void PasswordChange::set_old_password(::std::string&& value) {
  
  old_password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.PasswordChange.old_password)
}
#endif
inline void PasswordChange::set_old_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  old_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.PasswordChange.old_password)
}
inline void PasswordChange::set_old_password(const char* value, size_t size) {
  
  old_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.PasswordChange.old_password)
}
inline ::std::string* PasswordChange::mutable_old_password() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.PasswordChange.old_password)
  return old_password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PasswordChange::release_old_password() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.PasswordChange.old_password)
  
  return old_password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PasswordChange::set_allocated_old_password(::std::string* old_password) {
  if (old_password != NULL) {
    
  } else {
    
  }
  old_password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), old_password);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.PasswordChange.old_password)
}

// string new_password = 3;
inline void PasswordChange::clear_new_password() {
  new_password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PasswordChange::new_password() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.PasswordChange.new_password)
  return new_password_.GetNoArena();
}
inline void PasswordChange::set_new_password(const ::std::string& value) {
  
  new_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.PasswordChange.new_password)
}
#if LANG_CXX11
inline void PasswordChange::set_new_password(::std::string&& value) {
  
  new_password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.PasswordChange.new_password)
}
#endif
inline void PasswordChange::set_new_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  new_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.PasswordChange.new_password)
}
inline void PasswordChange::set_new_password(const char* value, size_t size) {
  
  new_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.PasswordChange.new_password)
}
inline ::std::string* PasswordChange::mutable_new_password() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.PasswordChange.new_password)
  return new_password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PasswordChange::release_new_password() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.PasswordChange.new_password)
  
  return new_password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PasswordChange::set_allocated_new_password(::std::string* new_password) {
  if (new_password != NULL) {
    
  } else {
    
  }
  new_password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_password);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.PasswordChange.new_password)
}

// -------------------------------------------------------------------

// SequenceHandle

// uint32 identifier = 1;
inline void SequenceHandle::clear_identifier() {
  identifier_ = 0u;
}
inline ::google::protobuf::uint32 SequenceHandle::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceHandle.identifier)
  return identifier_;
}
inline void SequenceHandle::set_identifier(::google::protobuf::uint32 value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceHandle.identifier)
}

// fixed32 permission = 2;
inline void SequenceHandle::clear_permission() {
  permission_ = 0u;
}
inline ::google::protobuf::uint32 SequenceHandle::permission() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceHandle.permission)
  return permission_;
}
inline void SequenceHandle::set_permission(::google::protobuf::uint32 value) {
  
  permission_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceHandle.permission)
}

// -------------------------------------------------------------------

// AdvancedSequenceHandle

// .Kinova.Api.Base.SequenceHandle handle = 1;
inline bool AdvancedSequenceHandle::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline void AdvancedSequenceHandle::clear_handle() {
  if (GetArenaNoVirtual() == NULL && handle_ != NULL) {
    delete handle_;
  }
  handle_ = NULL;
}
inline const ::Kinova::Api::Base::SequenceHandle& AdvancedSequenceHandle::handle() const {
  const ::Kinova::Api::Base::SequenceHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.AdvancedSequenceHandle.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::SequenceHandle*>(
      &::Kinova::Api::Base::_SequenceHandle_default_instance_);
}
inline ::Kinova::Api::Base::SequenceHandle* AdvancedSequenceHandle::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.AdvancedSequenceHandle.handle)
  
  ::Kinova::Api::Base::SequenceHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::SequenceHandle* AdvancedSequenceHandle::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Base::SequenceHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.AdvancedSequenceHandle.handle)
  return handle_;
}
inline void AdvancedSequenceHandle::set_allocated_handle(::Kinova::Api::Base::SequenceHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handle_;
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.AdvancedSequenceHandle.handle)
}

// bool in_loop = 2;
inline void AdvancedSequenceHandle::clear_in_loop() {
  in_loop_ = false;
}
inline bool AdvancedSequenceHandle::in_loop() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.AdvancedSequenceHandle.in_loop)
  return in_loop_;
}
inline void AdvancedSequenceHandle::set_in_loop(bool value) {
  
  in_loop_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.AdvancedSequenceHandle.in_loop)
}

// -------------------------------------------------------------------

// SequenceTaskHandle

// .Kinova.Api.Base.SequenceHandle sequence_handle = 1;
inline bool SequenceTaskHandle::has_sequence_handle() const {
  return this != internal_default_instance() && sequence_handle_ != NULL;
}
inline void SequenceTaskHandle::clear_sequence_handle() {
  if (GetArenaNoVirtual() == NULL && sequence_handle_ != NULL) {
    delete sequence_handle_;
  }
  sequence_handle_ = NULL;
}
inline const ::Kinova::Api::Base::SequenceHandle& SequenceTaskHandle::sequence_handle() const {
  const ::Kinova::Api::Base::SequenceHandle* p = sequence_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTaskHandle.sequence_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::SequenceHandle*>(
      &::Kinova::Api::Base::_SequenceHandle_default_instance_);
}
inline ::Kinova::Api::Base::SequenceHandle* SequenceTaskHandle::release_sequence_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.SequenceTaskHandle.sequence_handle)
  
  ::Kinova::Api::Base::SequenceHandle* temp = sequence_handle_;
  sequence_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::SequenceHandle* SequenceTaskHandle::mutable_sequence_handle() {
  
  if (sequence_handle_ == NULL) {
    sequence_handle_ = new ::Kinova::Api::Base::SequenceHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceTaskHandle.sequence_handle)
  return sequence_handle_;
}
inline void SequenceTaskHandle::set_allocated_sequence_handle(::Kinova::Api::Base::SequenceHandle* sequence_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sequence_handle_;
  }
  if (sequence_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sequence_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sequence_handle, submessage_arena);
    }
    
  } else {
    
  }
  sequence_handle_ = sequence_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.SequenceTaskHandle.sequence_handle)
}

// uint32 task_index = 2;
inline void SequenceTaskHandle::clear_task_index() {
  task_index_ = 0u;
}
inline ::google::protobuf::uint32 SequenceTaskHandle::task_index() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTaskHandle.task_index)
  return task_index_;
}
inline void SequenceTaskHandle::set_task_index(::google::protobuf::uint32 value) {
  
  task_index_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceTaskHandle.task_index)
}

// -------------------------------------------------------------------

// SequenceTask

// uint32 group_identifier = 1;
inline void SequenceTask::clear_group_identifier() {
  group_identifier_ = 0u;
}
inline ::google::protobuf::uint32 SequenceTask::group_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTask.group_identifier)
  return group_identifier_;
}
inline void SequenceTask::set_group_identifier(::google::protobuf::uint32 value) {
  
  group_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceTask.group_identifier)
}

// .Kinova.Api.Base.Action action = 2;
inline bool SequenceTask::has_action() const {
  return this != internal_default_instance() && action_ != NULL;
}
inline void SequenceTask::clear_action() {
  if (GetArenaNoVirtual() == NULL && action_ != NULL) {
    delete action_;
  }
  action_ = NULL;
}
inline const ::Kinova::Api::Base::Action& SequenceTask::action() const {
  const ::Kinova::Api::Base::Action* p = action_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTask.action)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::Action*>(
      &::Kinova::Api::Base::_Action_default_instance_);
}
inline ::Kinova::Api::Base::Action* SequenceTask::release_action() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.SequenceTask.action)
  
  ::Kinova::Api::Base::Action* temp = action_;
  action_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::Action* SequenceTask::mutable_action() {
  
  if (action_ == NULL) {
    action_ = new ::Kinova::Api::Base::Action;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceTask.action)
  return action_;
}
inline void SequenceTask::set_allocated_action(::Kinova::Api::Base::Action* action) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete action_;
  }
  if (action) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      action = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.SequenceTask.action)
}

// string application_data = 3;
inline void SequenceTask::clear_application_data() {
  application_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SequenceTask::application_data() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTask.application_data)
  return application_data_.GetNoArena();
}
inline void SequenceTask::set_application_data(const ::std::string& value) {
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceTask.application_data)
}
#if LANG_CXX11
inline void SequenceTask::set_application_data(::std::string&& value) {
  
  application_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.SequenceTask.application_data)
}
#endif
inline void SequenceTask::set_application_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.SequenceTask.application_data)
}
inline void SequenceTask::set_application_data(const char* value, size_t size) {
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.SequenceTask.application_data)
}
inline ::std::string* SequenceTask::mutable_application_data() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceTask.application_data)
  return application_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SequenceTask::release_application_data() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.SequenceTask.application_data)
  
  return application_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SequenceTask::set_allocated_application_data(::std::string* application_data) {
  if (application_data != NULL) {
    
  } else {
    
  }
  application_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), application_data);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.SequenceTask.application_data)
}

// -------------------------------------------------------------------

// SequenceTasks

// repeated .Kinova.Api.Base.SequenceTask sequence_tasks = 1;
inline int SequenceTasks::sequence_tasks_size() const {
  return sequence_tasks_.size();
}
inline void SequenceTasks::clear_sequence_tasks() {
  sequence_tasks_.Clear();
}
inline const ::Kinova::Api::Base::SequenceTask& SequenceTasks::sequence_tasks(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTasks.sequence_tasks)
  return sequence_tasks_.Get(index);
}
inline ::Kinova::Api::Base::SequenceTask* SequenceTasks::mutable_sequence_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceTasks.sequence_tasks)
  return sequence_tasks_.Mutable(index);
}
inline ::Kinova::Api::Base::SequenceTask* SequenceTasks::add_sequence_tasks() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.SequenceTasks.sequence_tasks)
  return sequence_tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask >*
SequenceTasks::mutable_sequence_tasks() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.SequenceTasks.sequence_tasks)
  return &sequence_tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask >&
SequenceTasks::sequence_tasks() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.SequenceTasks.sequence_tasks)
  return sequence_tasks_;
}

// -------------------------------------------------------------------

// SequenceTasksConfiguration

// .Kinova.Api.Base.SequenceTaskHandle sequence_task_handle = 1;
inline bool SequenceTasksConfiguration::has_sequence_task_handle() const {
  return this != internal_default_instance() && sequence_task_handle_ != NULL;
}
inline void SequenceTasksConfiguration::clear_sequence_task_handle() {
  if (GetArenaNoVirtual() == NULL && sequence_task_handle_ != NULL) {
    delete sequence_task_handle_;
  }
  sequence_task_handle_ = NULL;
}
inline const ::Kinova::Api::Base::SequenceTaskHandle& SequenceTasksConfiguration::sequence_task_handle() const {
  const ::Kinova::Api::Base::SequenceTaskHandle* p = sequence_task_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTasksConfiguration.sequence_task_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::SequenceTaskHandle*>(
      &::Kinova::Api::Base::_SequenceTaskHandle_default_instance_);
}
inline ::Kinova::Api::Base::SequenceTaskHandle* SequenceTasksConfiguration::release_sequence_task_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.SequenceTasksConfiguration.sequence_task_handle)
  
  ::Kinova::Api::Base::SequenceTaskHandle* temp = sequence_task_handle_;
  sequence_task_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::SequenceTaskHandle* SequenceTasksConfiguration::mutable_sequence_task_handle() {
  
  if (sequence_task_handle_ == NULL) {
    sequence_task_handle_ = new ::Kinova::Api::Base::SequenceTaskHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceTasksConfiguration.sequence_task_handle)
  return sequence_task_handle_;
}
inline void SequenceTasksConfiguration::set_allocated_sequence_task_handle(::Kinova::Api::Base::SequenceTaskHandle* sequence_task_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sequence_task_handle_;
  }
  if (sequence_task_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sequence_task_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sequence_task_handle, submessage_arena);
    }
    
  } else {
    
  }
  sequence_task_handle_ = sequence_task_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.SequenceTasksConfiguration.sequence_task_handle)
}

// repeated .Kinova.Api.Base.SequenceTask sequence_tasks = 2;
inline int SequenceTasksConfiguration::sequence_tasks_size() const {
  return sequence_tasks_.size();
}
inline void SequenceTasksConfiguration::clear_sequence_tasks() {
  sequence_tasks_.Clear();
}
inline const ::Kinova::Api::Base::SequenceTask& SequenceTasksConfiguration::sequence_tasks(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTasksConfiguration.sequence_tasks)
  return sequence_tasks_.Get(index);
}
inline ::Kinova::Api::Base::SequenceTask* SequenceTasksConfiguration::mutable_sequence_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceTasksConfiguration.sequence_tasks)
  return sequence_tasks_.Mutable(index);
}
inline ::Kinova::Api::Base::SequenceTask* SequenceTasksConfiguration::add_sequence_tasks() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.SequenceTasksConfiguration.sequence_tasks)
  return sequence_tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask >*
SequenceTasksConfiguration::mutable_sequence_tasks() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.SequenceTasksConfiguration.sequence_tasks)
  return &sequence_tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask >&
SequenceTasksConfiguration::sequence_tasks() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.SequenceTasksConfiguration.sequence_tasks)
  return sequence_tasks_;
}

// -------------------------------------------------------------------

// SequenceTaskConfiguration

// .Kinova.Api.Base.SequenceTaskHandle sequence_task_handle = 1;
inline bool SequenceTaskConfiguration::has_sequence_task_handle() const {
  return this != internal_default_instance() && sequence_task_handle_ != NULL;
}
inline void SequenceTaskConfiguration::clear_sequence_task_handle() {
  if (GetArenaNoVirtual() == NULL && sequence_task_handle_ != NULL) {
    delete sequence_task_handle_;
  }
  sequence_task_handle_ = NULL;
}
inline const ::Kinova::Api::Base::SequenceTaskHandle& SequenceTaskConfiguration::sequence_task_handle() const {
  const ::Kinova::Api::Base::SequenceTaskHandle* p = sequence_task_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTaskConfiguration.sequence_task_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::SequenceTaskHandle*>(
      &::Kinova::Api::Base::_SequenceTaskHandle_default_instance_);
}
inline ::Kinova::Api::Base::SequenceTaskHandle* SequenceTaskConfiguration::release_sequence_task_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.SequenceTaskConfiguration.sequence_task_handle)
  
  ::Kinova::Api::Base::SequenceTaskHandle* temp = sequence_task_handle_;
  sequence_task_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::SequenceTaskHandle* SequenceTaskConfiguration::mutable_sequence_task_handle() {
  
  if (sequence_task_handle_ == NULL) {
    sequence_task_handle_ = new ::Kinova::Api::Base::SequenceTaskHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceTaskConfiguration.sequence_task_handle)
  return sequence_task_handle_;
}
inline void SequenceTaskConfiguration::set_allocated_sequence_task_handle(::Kinova::Api::Base::SequenceTaskHandle* sequence_task_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sequence_task_handle_;
  }
  if (sequence_task_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sequence_task_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sequence_task_handle, submessage_arena);
    }
    
  } else {
    
  }
  sequence_task_handle_ = sequence_task_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.SequenceTaskConfiguration.sequence_task_handle)
}

// .Kinova.Api.Base.SequenceTask sequence_task = 2;
inline bool SequenceTaskConfiguration::has_sequence_task() const {
  return this != internal_default_instance() && sequence_task_ != NULL;
}
inline void SequenceTaskConfiguration::clear_sequence_task() {
  if (GetArenaNoVirtual() == NULL && sequence_task_ != NULL) {
    delete sequence_task_;
  }
  sequence_task_ = NULL;
}
inline const ::Kinova::Api::Base::SequenceTask& SequenceTaskConfiguration::sequence_task() const {
  const ::Kinova::Api::Base::SequenceTask* p = sequence_task_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTaskConfiguration.sequence_task)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::SequenceTask*>(
      &::Kinova::Api::Base::_SequenceTask_default_instance_);
}
inline ::Kinova::Api::Base::SequenceTask* SequenceTaskConfiguration::release_sequence_task() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.SequenceTaskConfiguration.sequence_task)
  
  ::Kinova::Api::Base::SequenceTask* temp = sequence_task_;
  sequence_task_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::SequenceTask* SequenceTaskConfiguration::mutable_sequence_task() {
  
  if (sequence_task_ == NULL) {
    sequence_task_ = new ::Kinova::Api::Base::SequenceTask;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceTaskConfiguration.sequence_task)
  return sequence_task_;
}
inline void SequenceTaskConfiguration::set_allocated_sequence_task(::Kinova::Api::Base::SequenceTask* sequence_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sequence_task_;
  }
  if (sequence_task) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sequence_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sequence_task, submessage_arena);
    }
    
  } else {
    
  }
  sequence_task_ = sequence_task;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.SequenceTaskConfiguration.sequence_task)
}

// -------------------------------------------------------------------

// SequenceTasksRange

// uint32 first_task_index = 1;
inline void SequenceTasksRange::clear_first_task_index() {
  first_task_index_ = 0u;
}
inline ::google::protobuf::uint32 SequenceTasksRange::first_task_index() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTasksRange.first_task_index)
  return first_task_index_;
}
inline void SequenceTasksRange::set_first_task_index(::google::protobuf::uint32 value) {
  
  first_task_index_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceTasksRange.first_task_index)
}

// uint32 second_task_index = 2;
inline void SequenceTasksRange::clear_second_task_index() {
  second_task_index_ = 0u;
}
inline ::google::protobuf::uint32 SequenceTasksRange::second_task_index() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTasksRange.second_task_index)
  return second_task_index_;
}
inline void SequenceTasksRange::set_second_task_index(::google::protobuf::uint32 value) {
  
  second_task_index_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceTasksRange.second_task_index)
}

// -------------------------------------------------------------------

// SequenceTasksPair

// .Kinova.Api.Base.SequenceHandle sequence_handle = 1;
inline bool SequenceTasksPair::has_sequence_handle() const {
  return this != internal_default_instance() && sequence_handle_ != NULL;
}
inline void SequenceTasksPair::clear_sequence_handle() {
  if (GetArenaNoVirtual() == NULL && sequence_handle_ != NULL) {
    delete sequence_handle_;
  }
  sequence_handle_ = NULL;
}
inline const ::Kinova::Api::Base::SequenceHandle& SequenceTasksPair::sequence_handle() const {
  const ::Kinova::Api::Base::SequenceHandle* p = sequence_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTasksPair.sequence_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::SequenceHandle*>(
      &::Kinova::Api::Base::_SequenceHandle_default_instance_);
}
inline ::Kinova::Api::Base::SequenceHandle* SequenceTasksPair::release_sequence_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.SequenceTasksPair.sequence_handle)
  
  ::Kinova::Api::Base::SequenceHandle* temp = sequence_handle_;
  sequence_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::SequenceHandle* SequenceTasksPair::mutable_sequence_handle() {
  
  if (sequence_handle_ == NULL) {
    sequence_handle_ = new ::Kinova::Api::Base::SequenceHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceTasksPair.sequence_handle)
  return sequence_handle_;
}
inline void SequenceTasksPair::set_allocated_sequence_handle(::Kinova::Api::Base::SequenceHandle* sequence_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sequence_handle_;
  }
  if (sequence_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sequence_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sequence_handle, submessage_arena);
    }
    
  } else {
    
  }
  sequence_handle_ = sequence_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.SequenceTasksPair.sequence_handle)
}

// uint32 first_task_index = 2;
inline void SequenceTasksPair::clear_first_task_index() {
  first_task_index_ = 0u;
}
inline ::google::protobuf::uint32 SequenceTasksPair::first_task_index() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTasksPair.first_task_index)
  return first_task_index_;
}
inline void SequenceTasksPair::set_first_task_index(::google::protobuf::uint32 value) {
  
  first_task_index_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceTasksPair.first_task_index)
}

// uint32 second_task_index = 3;
inline void SequenceTasksPair::clear_second_task_index() {
  second_task_index_ = 0u;
}
inline ::google::protobuf::uint32 SequenceTasksPair::second_task_index() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceTasksPair.second_task_index)
  return second_task_index_;
}
inline void SequenceTasksPair::set_second_task_index(::google::protobuf::uint32 value) {
  
  second_task_index_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceTasksPair.second_task_index)
}

// -------------------------------------------------------------------

// Sequence

// .Kinova.Api.Base.SequenceHandle handle = 1;
inline bool Sequence::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline void Sequence::clear_handle() {
  if (GetArenaNoVirtual() == NULL && handle_ != NULL) {
    delete handle_;
  }
  handle_ = NULL;
}
inline const ::Kinova::Api::Base::SequenceHandle& Sequence::handle() const {
  const ::Kinova::Api::Base::SequenceHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Sequence.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::SequenceHandle*>(
      &::Kinova::Api::Base::_SequenceHandle_default_instance_);
}
inline ::Kinova::Api::Base::SequenceHandle* Sequence::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Sequence.handle)
  
  ::Kinova::Api::Base::SequenceHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::SequenceHandle* Sequence::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Base::SequenceHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Sequence.handle)
  return handle_;
}
inline void Sequence::set_allocated_handle(::Kinova::Api::Base::SequenceHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handle_;
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Sequence.handle)
}

// string name = 2;
inline void Sequence::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sequence::name() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Sequence.name)
  return name_.GetNoArena();
}
inline void Sequence::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Sequence.name)
}
#if LANG_CXX11
inline void Sequence::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.Sequence.name)
}
#endif
inline void Sequence::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.Sequence.name)
}
inline void Sequence::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.Sequence.name)
}
inline ::std::string* Sequence::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Sequence.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sequence::release_name() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Sequence.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sequence::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Sequence.name)
}

// string application_data = 3;
inline void Sequence::clear_application_data() {
  application_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sequence::application_data() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Sequence.application_data)
  return application_data_.GetNoArena();
}
inline void Sequence::set_application_data(const ::std::string& value) {
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Sequence.application_data)
}
#if LANG_CXX11
inline void Sequence::set_application_data(::std::string&& value) {
  
  application_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.Sequence.application_data)
}
#endif
inline void Sequence::set_application_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.Sequence.application_data)
}
inline void Sequence::set_application_data(const char* value, size_t size) {
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.Sequence.application_data)
}
inline ::std::string* Sequence::mutable_application_data() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Sequence.application_data)
  return application_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sequence::release_application_data() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Sequence.application_data)
  
  return application_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sequence::set_allocated_application_data(::std::string* application_data) {
  if (application_data != NULL) {
    
  } else {
    
  }
  application_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), application_data);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Sequence.application_data)
}

// repeated .Kinova.Api.Base.SequenceTask tasks = 4;
inline int Sequence::tasks_size() const {
  return tasks_.size();
}
inline void Sequence::clear_tasks() {
  tasks_.Clear();
}
inline const ::Kinova::Api::Base::SequenceTask& Sequence::tasks(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Sequence.tasks)
  return tasks_.Get(index);
}
inline ::Kinova::Api::Base::SequenceTask* Sequence::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Sequence.tasks)
  return tasks_.Mutable(index);
}
inline ::Kinova::Api::Base::SequenceTask* Sequence::add_tasks() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.Sequence.tasks)
  return tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask >*
Sequence::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.Sequence.tasks)
  return &tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceTask >&
Sequence::tasks() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.Sequence.tasks)
  return tasks_;
}

// -------------------------------------------------------------------

// SequenceList

// repeated .Kinova.Api.Base.Sequence sequence_list = 1;
inline int SequenceList::sequence_list_size() const {
  return sequence_list_.size();
}
inline void SequenceList::clear_sequence_list() {
  sequence_list_.Clear();
}
inline const ::Kinova::Api::Base::Sequence& SequenceList::sequence_list(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceList.sequence_list)
  return sequence_list_.Get(index);
}
inline ::Kinova::Api::Base::Sequence* SequenceList::mutable_sequence_list(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceList.sequence_list)
  return sequence_list_.Mutable(index);
}
inline ::Kinova::Api::Base::Sequence* SequenceList::add_sequence_list() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.SequenceList.sequence_list)
  return sequence_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Sequence >*
SequenceList::mutable_sequence_list() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.SequenceList.sequence_list)
  return &sequence_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Sequence >&
SequenceList::sequence_list() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.SequenceList.sequence_list)
  return sequence_list_;
}

// -------------------------------------------------------------------

// AppendActionInformation

// .Kinova.Api.Base.SequenceHandle sequence_handle = 1;
inline bool AppendActionInformation::has_sequence_handle() const {
  return this != internal_default_instance() && sequence_handle_ != NULL;
}
inline void AppendActionInformation::clear_sequence_handle() {
  if (GetArenaNoVirtual() == NULL && sequence_handle_ != NULL) {
    delete sequence_handle_;
  }
  sequence_handle_ = NULL;
}
inline const ::Kinova::Api::Base::SequenceHandle& AppendActionInformation::sequence_handle() const {
  const ::Kinova::Api::Base::SequenceHandle* p = sequence_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.AppendActionInformation.sequence_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::SequenceHandle*>(
      &::Kinova::Api::Base::_SequenceHandle_default_instance_);
}
inline ::Kinova::Api::Base::SequenceHandle* AppendActionInformation::release_sequence_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.AppendActionInformation.sequence_handle)
  
  ::Kinova::Api::Base::SequenceHandle* temp = sequence_handle_;
  sequence_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::SequenceHandle* AppendActionInformation::mutable_sequence_handle() {
  
  if (sequence_handle_ == NULL) {
    sequence_handle_ = new ::Kinova::Api::Base::SequenceHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.AppendActionInformation.sequence_handle)
  return sequence_handle_;
}
inline void AppendActionInformation::set_allocated_sequence_handle(::Kinova::Api::Base::SequenceHandle* sequence_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sequence_handle_;
  }
  if (sequence_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sequence_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sequence_handle, submessage_arena);
    }
    
  } else {
    
  }
  sequence_handle_ = sequence_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.AppendActionInformation.sequence_handle)
}

// .Kinova.Api.Base.Action action = 2;
inline bool AppendActionInformation::has_action() const {
  return this != internal_default_instance() && action_ != NULL;
}
inline void AppendActionInformation::clear_action() {
  if (GetArenaNoVirtual() == NULL && action_ != NULL) {
    delete action_;
  }
  action_ = NULL;
}
inline const ::Kinova::Api::Base::Action& AppendActionInformation::action() const {
  const ::Kinova::Api::Base::Action* p = action_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.AppendActionInformation.action)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::Action*>(
      &::Kinova::Api::Base::_Action_default_instance_);
}
inline ::Kinova::Api::Base::Action* AppendActionInformation::release_action() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.AppendActionInformation.action)
  
  ::Kinova::Api::Base::Action* temp = action_;
  action_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::Action* AppendActionInformation::mutable_action() {
  
  if (action_ == NULL) {
    action_ = new ::Kinova::Api::Base::Action;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.AppendActionInformation.action)
  return action_;
}
inline void AppendActionInformation::set_allocated_action(::Kinova::Api::Base::Action* action) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete action_;
  }
  if (action) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      action = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.AppendActionInformation.action)
}

// -------------------------------------------------------------------

// ActionHandle

// uint32 identifier = 1;
inline void ActionHandle::clear_identifier() {
  identifier_ = 0u;
}
inline ::google::protobuf::uint32 ActionHandle::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActionHandle.identifier)
  return identifier_;
}
inline void ActionHandle::set_identifier(::google::protobuf::uint32 value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ActionHandle.identifier)
}

// .Kinova.Api.Base.ActionType action_type = 2;
inline void ActionHandle::clear_action_type() {
  action_type_ = 0;
}
inline ::Kinova::Api::Base::ActionType ActionHandle::action_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActionHandle.action_type)
  return static_cast< ::Kinova::Api::Base::ActionType >(action_type_);
}
inline void ActionHandle::set_action_type(::Kinova::Api::Base::ActionType value) {
  
  action_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ActionHandle.action_type)
}

// fixed32 permission = 3;
inline void ActionHandle::clear_permission() {
  permission_ = 0u;
}
inline ::google::protobuf::uint32 ActionHandle::permission() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActionHandle.permission)
  return permission_;
}
inline void ActionHandle::set_permission(::google::protobuf::uint32 value) {
  
  permission_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ActionHandle.permission)
}

// -------------------------------------------------------------------

// RequestedActionType

// .Kinova.Api.Base.ActionType action_type = 1;
inline void RequestedActionType::clear_action_type() {
  action_type_ = 0;
}
inline ::Kinova::Api::Base::ActionType RequestedActionType::action_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.RequestedActionType.action_type)
  return static_cast< ::Kinova::Api::Base::ActionType >(action_type_);
}
inline void RequestedActionType::set_action_type(::Kinova::Api::Base::ActionType value) {
  
  action_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.RequestedActionType.action_type)
}

// -------------------------------------------------------------------

// Action

// .Kinova.Api.Base.ActionHandle handle = 1;
inline bool Action::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline void Action::clear_handle() {
  if (GetArenaNoVirtual() == NULL && handle_ != NULL) {
    delete handle_;
  }
  handle_ = NULL;
}
inline const ::Kinova::Api::Base::ActionHandle& Action::handle() const {
  const ::Kinova::Api::Base::ActionHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::ActionHandle*>(
      &::Kinova::Api::Base::_ActionHandle_default_instance_);
}
inline ::Kinova::Api::Base::ActionHandle* Action::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.handle)
  
  ::Kinova::Api::Base::ActionHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::ActionHandle* Action::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Base::ActionHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.handle)
  return handle_;
}
inline void Action::set_allocated_handle(::Kinova::Api::Base::ActionHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handle_;
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Action.handle)
}

// string name = 2;
inline void Action::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Action::name() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.name)
  return name_.GetNoArena();
}
inline void Action::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Action.name)
}
#if LANG_CXX11
inline void Action::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.Action.name)
}
#endif
inline void Action::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.Action.name)
}
inline void Action::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.Action.name)
}
inline ::std::string* Action::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Action::release_name() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Action::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Action.name)
}

// string application_data = 3;
inline void Action::clear_application_data() {
  application_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Action::application_data() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.application_data)
  return application_data_.GetNoArena();
}
inline void Action::set_application_data(const ::std::string& value) {
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Action.application_data)
}
#if LANG_CXX11
inline void Action::set_application_data(::std::string&& value) {
  
  application_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.Action.application_data)
}
#endif
inline void Action::set_application_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.Action.application_data)
}
inline void Action::set_application_data(const char* value, size_t size) {
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.Action.application_data)
}
inline ::std::string* Action::mutable_application_data() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.application_data)
  return application_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Action::release_application_data() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.application_data)
  
  return application_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Action::set_allocated_application_data(::std::string* application_data) {
  if (application_data != NULL) {
    
  } else {
    
  }
  application_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), application_data);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Action.application_data)
}

// .Kinova.Api.Base.TwistCommand send_twist_command = 4;
inline bool Action::has_send_twist_command() const {
  return action_parameters_case() == kSendTwistCommand;
}
inline void Action::set_has_send_twist_command() {
  _oneof_case_[0] = kSendTwistCommand;
}
inline void Action::clear_send_twist_command() {
  if (has_send_twist_command()) {
    delete action_parameters_.send_twist_command_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::TwistCommand* Action::release_send_twist_command() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.send_twist_command)
  if (has_send_twist_command()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::TwistCommand* temp = action_parameters_.send_twist_command_;
    action_parameters_.send_twist_command_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::TwistCommand& Action::send_twist_command() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.send_twist_command)
  return has_send_twist_command()
      ? *action_parameters_.send_twist_command_
      : *reinterpret_cast< ::Kinova::Api::Base::TwistCommand*>(&::Kinova::Api::Base::_TwistCommand_default_instance_);
}
inline ::Kinova::Api::Base::TwistCommand* Action::mutable_send_twist_command() {
  if (!has_send_twist_command()) {
    clear_action_parameters();
    set_has_send_twist_command();
    action_parameters_.send_twist_command_ = new ::Kinova::Api::Base::TwistCommand;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.send_twist_command)
  return action_parameters_.send_twist_command_;
}

// .Kinova.Api.Base.WrenchCommand send_wrench_command = 5;
inline bool Action::has_send_wrench_command() const {
  return action_parameters_case() == kSendWrenchCommand;
}
inline void Action::set_has_send_wrench_command() {
  _oneof_case_[0] = kSendWrenchCommand;
}
inline void Action::clear_send_wrench_command() {
  if (has_send_wrench_command()) {
    delete action_parameters_.send_wrench_command_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::WrenchCommand* Action::release_send_wrench_command() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.send_wrench_command)
  if (has_send_wrench_command()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::WrenchCommand* temp = action_parameters_.send_wrench_command_;
    action_parameters_.send_wrench_command_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::WrenchCommand& Action::send_wrench_command() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.send_wrench_command)
  return has_send_wrench_command()
      ? *action_parameters_.send_wrench_command_
      : *reinterpret_cast< ::Kinova::Api::Base::WrenchCommand*>(&::Kinova::Api::Base::_WrenchCommand_default_instance_);
}
inline ::Kinova::Api::Base::WrenchCommand* Action::mutable_send_wrench_command() {
  if (!has_send_wrench_command()) {
    clear_action_parameters();
    set_has_send_wrench_command();
    action_parameters_.send_wrench_command_ = new ::Kinova::Api::Base::WrenchCommand;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.send_wrench_command)
  return action_parameters_.send_wrench_command_;
}

// .Kinova.Api.Base.JointSpeeds send_joint_speeds = 7;
inline bool Action::has_send_joint_speeds() const {
  return action_parameters_case() == kSendJointSpeeds;
}
inline void Action::set_has_send_joint_speeds() {
  _oneof_case_[0] = kSendJointSpeeds;
}
inline void Action::clear_send_joint_speeds() {
  if (has_send_joint_speeds()) {
    delete action_parameters_.send_joint_speeds_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::JointSpeeds* Action::release_send_joint_speeds() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.send_joint_speeds)
  if (has_send_joint_speeds()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::JointSpeeds* temp = action_parameters_.send_joint_speeds_;
    action_parameters_.send_joint_speeds_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::JointSpeeds& Action::send_joint_speeds() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.send_joint_speeds)
  return has_send_joint_speeds()
      ? *action_parameters_.send_joint_speeds_
      : *reinterpret_cast< ::Kinova::Api::Base::JointSpeeds*>(&::Kinova::Api::Base::_JointSpeeds_default_instance_);
}
inline ::Kinova::Api::Base::JointSpeeds* Action::mutable_send_joint_speeds() {
  if (!has_send_joint_speeds()) {
    clear_action_parameters();
    set_has_send_joint_speeds();
    action_parameters_.send_joint_speeds_ = new ::Kinova::Api::Base::JointSpeeds;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.send_joint_speeds)
  return action_parameters_.send_joint_speeds_;
}

// .Kinova.Api.Base.ConstrainedPose reach_pose = 9;
inline bool Action::has_reach_pose() const {
  return action_parameters_case() == kReachPose;
}
inline void Action::set_has_reach_pose() {
  _oneof_case_[0] = kReachPose;
}
inline void Action::clear_reach_pose() {
  if (has_reach_pose()) {
    delete action_parameters_.reach_pose_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::ConstrainedPose* Action::release_reach_pose() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.reach_pose)
  if (has_reach_pose()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::ConstrainedPose* temp = action_parameters_.reach_pose_;
    action_parameters_.reach_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::ConstrainedPose& Action::reach_pose() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.reach_pose)
  return has_reach_pose()
      ? *action_parameters_.reach_pose_
      : *reinterpret_cast< ::Kinova::Api::Base::ConstrainedPose*>(&::Kinova::Api::Base::_ConstrainedPose_default_instance_);
}
inline ::Kinova::Api::Base::ConstrainedPose* Action::mutable_reach_pose() {
  if (!has_reach_pose()) {
    clear_action_parameters();
    set_has_reach_pose();
    action_parameters_.reach_pose_ = new ::Kinova::Api::Base::ConstrainedPose;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.reach_pose)
  return action_parameters_.reach_pose_;
}

// .Kinova.Api.Base.ConstrainedJointAngles reach_joint_angles = 10;
inline bool Action::has_reach_joint_angles() const {
  return action_parameters_case() == kReachJointAngles;
}
inline void Action::set_has_reach_joint_angles() {
  _oneof_case_[0] = kReachJointAngles;
}
inline void Action::clear_reach_joint_angles() {
  if (has_reach_joint_angles()) {
    delete action_parameters_.reach_joint_angles_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::ConstrainedJointAngles* Action::release_reach_joint_angles() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.reach_joint_angles)
  if (has_reach_joint_angles()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::ConstrainedJointAngles* temp = action_parameters_.reach_joint_angles_;
    action_parameters_.reach_joint_angles_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::ConstrainedJointAngles& Action::reach_joint_angles() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.reach_joint_angles)
  return has_reach_joint_angles()
      ? *action_parameters_.reach_joint_angles_
      : *reinterpret_cast< ::Kinova::Api::Base::ConstrainedJointAngles*>(&::Kinova::Api::Base::_ConstrainedJointAngles_default_instance_);
}
inline ::Kinova::Api::Base::ConstrainedJointAngles* Action::mutable_reach_joint_angles() {
  if (!has_reach_joint_angles()) {
    clear_action_parameters();
    set_has_reach_joint_angles();
    action_parameters_.reach_joint_angles_ = new ::Kinova::Api::Base::ConstrainedJointAngles;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.reach_joint_angles)
  return action_parameters_.reach_joint_angles_;
}

// .Kinova.Api.Base.AdmittanceMode toggle_admittance_mode = 16;
inline bool Action::has_toggle_admittance_mode() const {
  return action_parameters_case() == kToggleAdmittanceMode;
}
inline void Action::set_has_toggle_admittance_mode() {
  _oneof_case_[0] = kToggleAdmittanceMode;
}
inline void Action::clear_toggle_admittance_mode() {
  if (has_toggle_admittance_mode()) {
    action_parameters_.toggle_admittance_mode_ = 0;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::AdmittanceMode Action::toggle_admittance_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.toggle_admittance_mode)
  if (has_toggle_admittance_mode()) {
    return static_cast< ::Kinova::Api::Base::AdmittanceMode >(action_parameters_.toggle_admittance_mode_);
  }
  return static_cast< ::Kinova::Api::Base::AdmittanceMode >(0);
}
inline void Action::set_toggle_admittance_mode(::Kinova::Api::Base::AdmittanceMode value) {
  if (!has_toggle_admittance_mode()) {
    clear_action_parameters();
    set_has_toggle_admittance_mode();
  }
  action_parameters_.toggle_admittance_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Action.toggle_admittance_mode)
}

// .Kinova.Api.Base.Snapshot snapshot = 17;
inline bool Action::has_snapshot() const {
  return action_parameters_case() == kSnapshot;
}
inline void Action::set_has_snapshot() {
  _oneof_case_[0] = kSnapshot;
}
inline void Action::clear_snapshot() {
  if (has_snapshot()) {
    delete action_parameters_.snapshot_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::Snapshot* Action::release_snapshot() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.snapshot)
  if (has_snapshot()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::Snapshot* temp = action_parameters_.snapshot_;
    action_parameters_.snapshot_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::Snapshot& Action::snapshot() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.snapshot)
  return has_snapshot()
      ? *action_parameters_.snapshot_
      : *reinterpret_cast< ::Kinova::Api::Base::Snapshot*>(&::Kinova::Api::Base::_Snapshot_default_instance_);
}
inline ::Kinova::Api::Base::Snapshot* Action::mutable_snapshot() {
  if (!has_snapshot()) {
    clear_action_parameters();
    set_has_snapshot();
    action_parameters_.snapshot_ = new ::Kinova::Api::Base::Snapshot;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.snapshot)
  return action_parameters_.snapshot_;
}

// .Kinova.Api.Base.SwitchControlMapping switch_control_mapping = 19;
inline bool Action::has_switch_control_mapping() const {
  return action_parameters_case() == kSwitchControlMapping;
}
inline void Action::set_has_switch_control_mapping() {
  _oneof_case_[0] = kSwitchControlMapping;
}
inline void Action::clear_switch_control_mapping() {
  if (has_switch_control_mapping()) {
    delete action_parameters_.switch_control_mapping_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::SwitchControlMapping* Action::release_switch_control_mapping() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.switch_control_mapping)
  if (has_switch_control_mapping()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::SwitchControlMapping* temp = action_parameters_.switch_control_mapping_;
    action_parameters_.switch_control_mapping_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::SwitchControlMapping& Action::switch_control_mapping() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.switch_control_mapping)
  return has_switch_control_mapping()
      ? *action_parameters_.switch_control_mapping_
      : *reinterpret_cast< ::Kinova::Api::Base::SwitchControlMapping*>(&::Kinova::Api::Base::_SwitchControlMapping_default_instance_);
}
inline ::Kinova::Api::Base::SwitchControlMapping* Action::mutable_switch_control_mapping() {
  if (!has_switch_control_mapping()) {
    clear_action_parameters();
    set_has_switch_control_mapping();
    action_parameters_.switch_control_mapping_ = new ::Kinova::Api::Base::SwitchControlMapping;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.switch_control_mapping)
  return action_parameters_.switch_control_mapping_;
}

// .Kinova.Api.Base.JointNavigationDirection navigate_joints = 20;
inline bool Action::has_navigate_joints() const {
  return action_parameters_case() == kNavigateJoints;
}
inline void Action::set_has_navigate_joints() {
  _oneof_case_[0] = kNavigateJoints;
}
inline void Action::clear_navigate_joints() {
  if (has_navigate_joints()) {
    action_parameters_.navigate_joints_ = 0;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::JointNavigationDirection Action::navigate_joints() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.navigate_joints)
  if (has_navigate_joints()) {
    return static_cast< ::Kinova::Api::Base::JointNavigationDirection >(action_parameters_.navigate_joints_);
  }
  return static_cast< ::Kinova::Api::Base::JointNavigationDirection >(0);
}
inline void Action::set_navigate_joints(::Kinova::Api::Base::JointNavigationDirection value) {
  if (!has_navigate_joints()) {
    clear_action_parameters();
    set_has_navigate_joints();
  }
  action_parameters_.navigate_joints_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Action.navigate_joints)
}

// .Kinova.Api.Base.NavigationDirection navigate_mappings = 21;
inline bool Action::has_navigate_mappings() const {
  return action_parameters_case() == kNavigateMappings;
}
inline void Action::set_has_navigate_mappings() {
  _oneof_case_[0] = kNavigateMappings;
}
inline void Action::clear_navigate_mappings() {
  if (has_navigate_mappings()) {
    action_parameters_.navigate_mappings_ = 0;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::NavigationDirection Action::navigate_mappings() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.navigate_mappings)
  if (has_navigate_mappings()) {
    return static_cast< ::Kinova::Api::Base::NavigationDirection >(action_parameters_.navigate_mappings_);
  }
  return static_cast< ::Kinova::Api::Base::NavigationDirection >(0);
}
inline void Action::set_navigate_mappings(::Kinova::Api::Base::NavigationDirection value) {
  if (!has_navigate_mappings()) {
    clear_action_parameters();
    set_has_navigate_mappings();
  }
  action_parameters_.navigate_mappings_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Action.navigate_mappings)
}

// .Kinova.Api.Base.ChangeTwist change_twist = 25;
inline bool Action::has_change_twist() const {
  return action_parameters_case() == kChangeTwist;
}
inline void Action::set_has_change_twist() {
  _oneof_case_[0] = kChangeTwist;
}
inline void Action::clear_change_twist() {
  if (has_change_twist()) {
    delete action_parameters_.change_twist_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::ChangeTwist* Action::release_change_twist() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.change_twist)
  if (has_change_twist()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::ChangeTwist* temp = action_parameters_.change_twist_;
    action_parameters_.change_twist_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::ChangeTwist& Action::change_twist() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.change_twist)
  return has_change_twist()
      ? *action_parameters_.change_twist_
      : *reinterpret_cast< ::Kinova::Api::Base::ChangeTwist*>(&::Kinova::Api::Base::_ChangeTwist_default_instance_);
}
inline ::Kinova::Api::Base::ChangeTwist* Action::mutable_change_twist() {
  if (!has_change_twist()) {
    clear_action_parameters();
    set_has_change_twist();
    action_parameters_.change_twist_ = new ::Kinova::Api::Base::ChangeTwist;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.change_twist)
  return action_parameters_.change_twist_;
}

// .Kinova.Api.Base.ChangeJointSpeeds change_joint_speeds = 26;
inline bool Action::has_change_joint_speeds() const {
  return action_parameters_case() == kChangeJointSpeeds;
}
inline void Action::set_has_change_joint_speeds() {
  _oneof_case_[0] = kChangeJointSpeeds;
}
inline void Action::clear_change_joint_speeds() {
  if (has_change_joint_speeds()) {
    delete action_parameters_.change_joint_speeds_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::ChangeJointSpeeds* Action::release_change_joint_speeds() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.change_joint_speeds)
  if (has_change_joint_speeds()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::ChangeJointSpeeds* temp = action_parameters_.change_joint_speeds_;
    action_parameters_.change_joint_speeds_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::ChangeJointSpeeds& Action::change_joint_speeds() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.change_joint_speeds)
  return has_change_joint_speeds()
      ? *action_parameters_.change_joint_speeds_
      : *reinterpret_cast< ::Kinova::Api::Base::ChangeJointSpeeds*>(&::Kinova::Api::Base::_ChangeJointSpeeds_default_instance_);
}
inline ::Kinova::Api::Base::ChangeJointSpeeds* Action::mutable_change_joint_speeds() {
  if (!has_change_joint_speeds()) {
    clear_action_parameters();
    set_has_change_joint_speeds();
    action_parameters_.change_joint_speeds_ = new ::Kinova::Api::Base::ChangeJointSpeeds;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.change_joint_speeds)
  return action_parameters_.change_joint_speeds_;
}

// .Kinova.Api.Base.ChangeWrench change_wrench = 28;
inline bool Action::has_change_wrench() const {
  return action_parameters_case() == kChangeWrench;
}
inline void Action::set_has_change_wrench() {
  _oneof_case_[0] = kChangeWrench;
}
inline void Action::clear_change_wrench() {
  if (has_change_wrench()) {
    delete action_parameters_.change_wrench_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::ChangeWrench* Action::release_change_wrench() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.change_wrench)
  if (has_change_wrench()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::ChangeWrench* temp = action_parameters_.change_wrench_;
    action_parameters_.change_wrench_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::ChangeWrench& Action::change_wrench() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.change_wrench)
  return has_change_wrench()
      ? *action_parameters_.change_wrench_
      : *reinterpret_cast< ::Kinova::Api::Base::ChangeWrench*>(&::Kinova::Api::Base::_ChangeWrench_default_instance_);
}
inline ::Kinova::Api::Base::ChangeWrench* Action::mutable_change_wrench() {
  if (!has_change_wrench()) {
    clear_action_parameters();
    set_has_change_wrench();
    action_parameters_.change_wrench_ = new ::Kinova::Api::Base::ChangeWrench;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.change_wrench)
  return action_parameters_.change_wrench_;
}

// .Kinova.Api.Base.EmergencyStop apply_emergency_stop = 31;
inline bool Action::has_apply_emergency_stop() const {
  return action_parameters_case() == kApplyEmergencyStop;
}
inline void Action::set_has_apply_emergency_stop() {
  _oneof_case_[0] = kApplyEmergencyStop;
}
inline void Action::clear_apply_emergency_stop() {
  if (has_apply_emergency_stop()) {
    delete action_parameters_.apply_emergency_stop_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::EmergencyStop* Action::release_apply_emergency_stop() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.apply_emergency_stop)
  if (has_apply_emergency_stop()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::EmergencyStop* temp = action_parameters_.apply_emergency_stop_;
    action_parameters_.apply_emergency_stop_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::EmergencyStop& Action::apply_emergency_stop() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.apply_emergency_stop)
  return has_apply_emergency_stop()
      ? *action_parameters_.apply_emergency_stop_
      : *reinterpret_cast< ::Kinova::Api::Base::EmergencyStop*>(&::Kinova::Api::Base::_EmergencyStop_default_instance_);
}
inline ::Kinova::Api::Base::EmergencyStop* Action::mutable_apply_emergency_stop() {
  if (!has_apply_emergency_stop()) {
    clear_action_parameters();
    set_has_apply_emergency_stop();
    action_parameters_.apply_emergency_stop_ = new ::Kinova::Api::Base::EmergencyStop;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.apply_emergency_stop)
  return action_parameters_.apply_emergency_stop_;
}

// .Kinova.Api.Base.Faults clear_faults = 32;
inline bool Action::has_clear_faults() const {
  return action_parameters_case() == kClearFaults;
}
inline void Action::set_has_clear_faults() {
  _oneof_case_[0] = kClearFaults;
}
inline void Action::clear_clear_faults() {
  if (has_clear_faults()) {
    delete action_parameters_.clear_faults_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::Faults* Action::release_clear_faults() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.clear_faults)
  if (has_clear_faults()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::Faults* temp = action_parameters_.clear_faults_;
    action_parameters_.clear_faults_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::Faults& Action::clear_faults() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.clear_faults)
  return has_clear_faults()
      ? *action_parameters_.clear_faults_
      : *reinterpret_cast< ::Kinova::Api::Base::Faults*>(&::Kinova::Api::Base::_Faults_default_instance_);
}
inline ::Kinova::Api::Base::Faults* Action::mutable_clear_faults() {
  if (!has_clear_faults()) {
    clear_action_parameters();
    set_has_clear_faults();
    action_parameters_.clear_faults_ = new ::Kinova::Api::Base::Faults;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.clear_faults)
  return action_parameters_.clear_faults_;
}

// .Kinova.Api.Base.Delay delay = 34;
inline bool Action::has_delay() const {
  return action_parameters_case() == kDelay;
}
inline void Action::set_has_delay() {
  _oneof_case_[0] = kDelay;
}
inline void Action::clear_delay() {
  if (has_delay()) {
    delete action_parameters_.delay_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::Delay* Action::release_delay() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.delay)
  if (has_delay()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::Delay* temp = action_parameters_.delay_;
    action_parameters_.delay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::Delay& Action::delay() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.delay)
  return has_delay()
      ? *action_parameters_.delay_
      : *reinterpret_cast< ::Kinova::Api::Base::Delay*>(&::Kinova::Api::Base::_Delay_default_instance_);
}
inline ::Kinova::Api::Base::Delay* Action::mutable_delay() {
  if (!has_delay()) {
    clear_action_parameters();
    set_has_delay();
    action_parameters_.delay_ = new ::Kinova::Api::Base::Delay;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.delay)
  return action_parameters_.delay_;
}

// .Kinova.Api.Base.ActionHandle execute_action = 35;
inline bool Action::has_execute_action() const {
  return action_parameters_case() == kExecuteAction;
}
inline void Action::set_has_execute_action() {
  _oneof_case_[0] = kExecuteAction;
}
inline void Action::clear_execute_action() {
  if (has_execute_action()) {
    delete action_parameters_.execute_action_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::ActionHandle* Action::release_execute_action() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.execute_action)
  if (has_execute_action()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::ActionHandle* temp = action_parameters_.execute_action_;
    action_parameters_.execute_action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::ActionHandle& Action::execute_action() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.execute_action)
  return has_execute_action()
      ? *action_parameters_.execute_action_
      : *reinterpret_cast< ::Kinova::Api::Base::ActionHandle*>(&::Kinova::Api::Base::_ActionHandle_default_instance_);
}
inline ::Kinova::Api::Base::ActionHandle* Action::mutable_execute_action() {
  if (!has_execute_action()) {
    clear_action_parameters();
    set_has_execute_action();
    action_parameters_.execute_action_ = new ::Kinova::Api::Base::ActionHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.execute_action)
  return action_parameters_.execute_action_;
}

// .Kinova.Api.Base.GripperCommand send_gripper_command = 36;
inline bool Action::has_send_gripper_command() const {
  return action_parameters_case() == kSendGripperCommand;
}
inline void Action::set_has_send_gripper_command() {
  _oneof_case_[0] = kSendGripperCommand;
}
inline void Action::clear_send_gripper_command() {
  if (has_send_gripper_command()) {
    delete action_parameters_.send_gripper_command_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::GripperCommand* Action::release_send_gripper_command() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.send_gripper_command)
  if (has_send_gripper_command()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::GripperCommand* temp = action_parameters_.send_gripper_command_;
    action_parameters_.send_gripper_command_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::GripperCommand& Action::send_gripper_command() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.send_gripper_command)
  return has_send_gripper_command()
      ? *action_parameters_.send_gripper_command_
      : *reinterpret_cast< ::Kinova::Api::Base::GripperCommand*>(&::Kinova::Api::Base::_GripperCommand_default_instance_);
}
inline ::Kinova::Api::Base::GripperCommand* Action::mutable_send_gripper_command() {
  if (!has_send_gripper_command()) {
    clear_action_parameters();
    set_has_send_gripper_command();
    action_parameters_.send_gripper_command_ = new ::Kinova::Api::Base::GripperCommand;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.send_gripper_command)
  return action_parameters_.send_gripper_command_;
}

// .Kinova.Api.Base.GpioCommand send_gpio_command = 37;
inline bool Action::has_send_gpio_command() const {
  return action_parameters_case() == kSendGpioCommand;
}
inline void Action::set_has_send_gpio_command() {
  _oneof_case_[0] = kSendGpioCommand;
}
inline void Action::clear_send_gpio_command() {
  if (has_send_gpio_command()) {
    delete action_parameters_.send_gpio_command_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::GpioCommand* Action::release_send_gpio_command() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.send_gpio_command)
  if (has_send_gpio_command()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::GpioCommand* temp = action_parameters_.send_gpio_command_;
    action_parameters_.send_gpio_command_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::GpioCommand& Action::send_gpio_command() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.send_gpio_command)
  return has_send_gpio_command()
      ? *action_parameters_.send_gpio_command_
      : *reinterpret_cast< ::Kinova::Api::Base::GpioCommand*>(&::Kinova::Api::Base::_GpioCommand_default_instance_);
}
inline ::Kinova::Api::Base::GpioCommand* Action::mutable_send_gpio_command() {
  if (!has_send_gpio_command()) {
    clear_action_parameters();
    set_has_send_gpio_command();
    action_parameters_.send_gpio_command_ = new ::Kinova::Api::Base::GpioCommand;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.send_gpio_command)
  return action_parameters_.send_gpio_command_;
}

// .Kinova.Api.Base.Stop stop_action = 38;
inline bool Action::has_stop_action() const {
  return action_parameters_case() == kStopAction;
}
inline void Action::set_has_stop_action() {
  _oneof_case_[0] = kStopAction;
}
inline void Action::clear_stop_action() {
  if (has_stop_action()) {
    delete action_parameters_.stop_action_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::Stop* Action::release_stop_action() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.stop_action)
  if (has_stop_action()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::Stop* temp = action_parameters_.stop_action_;
    action_parameters_.stop_action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::Stop& Action::stop_action() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.stop_action)
  return has_stop_action()
      ? *action_parameters_.stop_action_
      : *reinterpret_cast< ::Kinova::Api::Base::Stop*>(&::Kinova::Api::Base::_Stop_default_instance_);
}
inline ::Kinova::Api::Base::Stop* Action::mutable_stop_action() {
  if (!has_stop_action()) {
    clear_action_parameters();
    set_has_stop_action();
    action_parameters_.stop_action_ = new ::Kinova::Api::Base::Stop;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.stop_action)
  return action_parameters_.stop_action_;
}

// .Kinova.Api.Base.PreComputedJointTrajectory play_pre_computed_trajectory = 39;
inline bool Action::has_play_pre_computed_trajectory() const {
  return action_parameters_case() == kPlayPreComputedTrajectory;
}
inline void Action::set_has_play_pre_computed_trajectory() {
  _oneof_case_[0] = kPlayPreComputedTrajectory;
}
inline void Action::clear_play_pre_computed_trajectory() {
  if (has_play_pre_computed_trajectory()) {
    delete action_parameters_.play_pre_computed_trajectory_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::PreComputedJointTrajectory* Action::release_play_pre_computed_trajectory() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.play_pre_computed_trajectory)
  if (has_play_pre_computed_trajectory()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::PreComputedJointTrajectory* temp = action_parameters_.play_pre_computed_trajectory_;
    action_parameters_.play_pre_computed_trajectory_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::PreComputedJointTrajectory& Action::play_pre_computed_trajectory() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.play_pre_computed_trajectory)
  return has_play_pre_computed_trajectory()
      ? *action_parameters_.play_pre_computed_trajectory_
      : *reinterpret_cast< ::Kinova::Api::Base::PreComputedJointTrajectory*>(&::Kinova::Api::Base::_PreComputedJointTrajectory_default_instance_);
}
inline ::Kinova::Api::Base::PreComputedJointTrajectory* Action::mutable_play_pre_computed_trajectory() {
  if (!has_play_pre_computed_trajectory()) {
    clear_action_parameters();
    set_has_play_pre_computed_trajectory();
    action_parameters_.play_pre_computed_trajectory_ = new ::Kinova::Api::Base::PreComputedJointTrajectory;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.play_pre_computed_trajectory)
  return action_parameters_.play_pre_computed_trajectory_;
}

// .Kinova.Api.Base.SequenceHandle execute_sequence = 40;
inline bool Action::has_execute_sequence() const {
  return action_parameters_case() == kExecuteSequence;
}
inline void Action::set_has_execute_sequence() {
  _oneof_case_[0] = kExecuteSequence;
}
inline void Action::clear_execute_sequence() {
  if (has_execute_sequence()) {
    delete action_parameters_.execute_sequence_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::SequenceHandle* Action::release_execute_sequence() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.execute_sequence)
  if (has_execute_sequence()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::SequenceHandle* temp = action_parameters_.execute_sequence_;
    action_parameters_.execute_sequence_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::SequenceHandle& Action::execute_sequence() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.execute_sequence)
  return has_execute_sequence()
      ? *action_parameters_.execute_sequence_
      : *reinterpret_cast< ::Kinova::Api::Base::SequenceHandle*>(&::Kinova::Api::Base::_SequenceHandle_default_instance_);
}
inline ::Kinova::Api::Base::SequenceHandle* Action::mutable_execute_sequence() {
  if (!has_execute_sequence()) {
    clear_action_parameters();
    set_has_execute_sequence();
    action_parameters_.execute_sequence_ = new ::Kinova::Api::Base::SequenceHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.execute_sequence)
  return action_parameters_.execute_sequence_;
}

// .Kinova.Api.Base.WaypointList execute_waypoint_list = 41;
inline bool Action::has_execute_waypoint_list() const {
  return action_parameters_case() == kExecuteWaypointList;
}
inline void Action::set_has_execute_waypoint_list() {
  _oneof_case_[0] = kExecuteWaypointList;
}
inline void Action::clear_execute_waypoint_list() {
  if (has_execute_waypoint_list()) {
    delete action_parameters_.execute_waypoint_list_;
    clear_has_action_parameters();
  }
}
inline ::Kinova::Api::Base::WaypointList* Action::release_execute_waypoint_list() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Action.execute_waypoint_list)
  if (has_execute_waypoint_list()) {
    clear_has_action_parameters();
      ::Kinova::Api::Base::WaypointList* temp = action_parameters_.execute_waypoint_list_;
    action_parameters_.execute_waypoint_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::WaypointList& Action::execute_waypoint_list() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Action.execute_waypoint_list)
  return has_execute_waypoint_list()
      ? *action_parameters_.execute_waypoint_list_
      : *reinterpret_cast< ::Kinova::Api::Base::WaypointList*>(&::Kinova::Api::Base::_WaypointList_default_instance_);
}
inline ::Kinova::Api::Base::WaypointList* Action::mutable_execute_waypoint_list() {
  if (!has_execute_waypoint_list()) {
    clear_action_parameters();
    set_has_execute_waypoint_list();
    action_parameters_.execute_waypoint_list_ = new ::Kinova::Api::Base::WaypointList;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Action.execute_waypoint_list)
  return action_parameters_.execute_waypoint_list_;
}

inline bool Action::has_action_parameters() const {
  return action_parameters_case() != ACTION_PARAMETERS_NOT_SET;
}
inline void Action::clear_has_action_parameters() {
  _oneof_case_[0] = ACTION_PARAMETERS_NOT_SET;
}
inline Action::ActionParametersCase Action::action_parameters_case() const {
  return Action::ActionParametersCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Snapshot

// .Kinova.Api.Base.SnapshotType snapshot_type = 1;
inline void Snapshot::clear_snapshot_type() {
  snapshot_type_ = 0;
}
inline ::Kinova::Api::Base::SnapshotType Snapshot::snapshot_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Snapshot.snapshot_type)
  return static_cast< ::Kinova::Api::Base::SnapshotType >(snapshot_type_);
}
inline void Snapshot::set_snapshot_type(::Kinova::Api::Base::SnapshotType value) {
  
  snapshot_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Snapshot.snapshot_type)
}

// -------------------------------------------------------------------

// SwitchControlMapping

// uint32 controller_identifier = 1;
inline void SwitchControlMapping::clear_controller_identifier() {
  controller_identifier_ = 0u;
}
inline ::google::protobuf::uint32 SwitchControlMapping::controller_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SwitchControlMapping.controller_identifier)
  return controller_identifier_;
}
inline void SwitchControlMapping::set_controller_identifier(::google::protobuf::uint32 value) {
  
  controller_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SwitchControlMapping.controller_identifier)
}

// .Kinova.Api.Base.MapGroupHandle map_group_handle = 2;
inline bool SwitchControlMapping::has_map_group_handle() const {
  return this != internal_default_instance() && map_group_handle_ != NULL;
}
inline void SwitchControlMapping::clear_map_group_handle() {
  if (GetArenaNoVirtual() == NULL && map_group_handle_ != NULL) {
    delete map_group_handle_;
  }
  map_group_handle_ = NULL;
}
inline const ::Kinova::Api::Base::MapGroupHandle& SwitchControlMapping::map_group_handle() const {
  const ::Kinova::Api::Base::MapGroupHandle* p = map_group_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SwitchControlMapping.map_group_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MapGroupHandle*>(
      &::Kinova::Api::Base::_MapGroupHandle_default_instance_);
}
inline ::Kinova::Api::Base::MapGroupHandle* SwitchControlMapping::release_map_group_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.SwitchControlMapping.map_group_handle)
  
  ::Kinova::Api::Base::MapGroupHandle* temp = map_group_handle_;
  map_group_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MapGroupHandle* SwitchControlMapping::mutable_map_group_handle() {
  
  if (map_group_handle_ == NULL) {
    map_group_handle_ = new ::Kinova::Api::Base::MapGroupHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SwitchControlMapping.map_group_handle)
  return map_group_handle_;
}
inline void SwitchControlMapping::set_allocated_map_group_handle(::Kinova::Api::Base::MapGroupHandle* map_group_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_group_handle_;
  }
  if (map_group_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_group_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_group_handle, submessage_arena);
    }
    
  } else {
    
  }
  map_group_handle_ = map_group_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.SwitchControlMapping.map_group_handle)
}

// .Kinova.Api.Base.MapHandle map_handle = 3;
inline bool SwitchControlMapping::has_map_handle() const {
  return this != internal_default_instance() && map_handle_ != NULL;
}
inline void SwitchControlMapping::clear_map_handle() {
  if (GetArenaNoVirtual() == NULL && map_handle_ != NULL) {
    delete map_handle_;
  }
  map_handle_ = NULL;
}
inline const ::Kinova::Api::Base::MapHandle& SwitchControlMapping::map_handle() const {
  const ::Kinova::Api::Base::MapHandle* p = map_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SwitchControlMapping.map_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MapHandle*>(
      &::Kinova::Api::Base::_MapHandle_default_instance_);
}
inline ::Kinova::Api::Base::MapHandle* SwitchControlMapping::release_map_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.SwitchControlMapping.map_handle)
  
  ::Kinova::Api::Base::MapHandle* temp = map_handle_;
  map_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MapHandle* SwitchControlMapping::mutable_map_handle() {
  
  if (map_handle_ == NULL) {
    map_handle_ = new ::Kinova::Api::Base::MapHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SwitchControlMapping.map_handle)
  return map_handle_;
}
inline void SwitchControlMapping::set_allocated_map_handle(::Kinova::Api::Base::MapHandle* map_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_handle_;
  }
  if (map_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_handle, submessage_arena);
    }
    
  } else {
    
  }
  map_handle_ = map_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.SwitchControlMapping.map_handle)
}

// -------------------------------------------------------------------

// ChangeTwist

// float linear = 1;
inline void ChangeTwist::clear_linear() {
  linear_ = 0;
}
inline float ChangeTwist::linear() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ChangeTwist.linear)
  return linear_;
}
inline void ChangeTwist::set_linear(float value) {
  
  linear_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ChangeTwist.linear)
}

// float angular = 2;
inline void ChangeTwist::clear_angular() {
  angular_ = 0;
}
inline float ChangeTwist::angular() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ChangeTwist.angular)
  return angular_;
}
inline void ChangeTwist::set_angular(float value) {
  
  angular_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ChangeTwist.angular)
}

// -------------------------------------------------------------------

// ChangeJointSpeeds

// .Kinova.Api.Base.JointSpeeds joint_speeds = 1;
inline bool ChangeJointSpeeds::has_joint_speeds() const {
  return this != internal_default_instance() && joint_speeds_ != NULL;
}
inline void ChangeJointSpeeds::clear_joint_speeds() {
  if (GetArenaNoVirtual() == NULL && joint_speeds_ != NULL) {
    delete joint_speeds_;
  }
  joint_speeds_ = NULL;
}
inline const ::Kinova::Api::Base::JointSpeeds& ChangeJointSpeeds::joint_speeds() const {
  const ::Kinova::Api::Base::JointSpeeds* p = joint_speeds_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ChangeJointSpeeds.joint_speeds)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::JointSpeeds*>(
      &::Kinova::Api::Base::_JointSpeeds_default_instance_);
}
inline ::Kinova::Api::Base::JointSpeeds* ChangeJointSpeeds::release_joint_speeds() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ChangeJointSpeeds.joint_speeds)
  
  ::Kinova::Api::Base::JointSpeeds* temp = joint_speeds_;
  joint_speeds_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::JointSpeeds* ChangeJointSpeeds::mutable_joint_speeds() {
  
  if (joint_speeds_ == NULL) {
    joint_speeds_ = new ::Kinova::Api::Base::JointSpeeds;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ChangeJointSpeeds.joint_speeds)
  return joint_speeds_;
}
inline void ChangeJointSpeeds::set_allocated_joint_speeds(::Kinova::Api::Base::JointSpeeds* joint_speeds) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete joint_speeds_;
  }
  if (joint_speeds) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      joint_speeds = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, joint_speeds, submessage_arena);
    }
    
  } else {
    
  }
  joint_speeds_ = joint_speeds;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ChangeJointSpeeds.joint_speeds)
}

// -------------------------------------------------------------------

// ChangeWrench

// float force = 1;
inline void ChangeWrench::clear_force() {
  force_ = 0;
}
inline float ChangeWrench::force() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ChangeWrench.force)
  return force_;
}
inline void ChangeWrench::set_force(float value) {
  
  force_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ChangeWrench.force)
}

// float torque = 2;
inline void ChangeWrench::clear_torque() {
  torque_ = 0;
}
inline float ChangeWrench::torque() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ChangeWrench.torque)
  return torque_;
}
inline void ChangeWrench::set_torque(float value) {
  
  torque_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ChangeWrench.torque)
}

// -------------------------------------------------------------------

// EmergencyStop

// -------------------------------------------------------------------

// Faults

// -------------------------------------------------------------------

// Delay

// uint32 duration = 1;
inline void Delay::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 Delay::duration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Delay.duration)
  return duration_;
}
inline void Delay::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Delay.duration)
}

// -------------------------------------------------------------------

// Stop

// -------------------------------------------------------------------

// ActionList

// repeated .Kinova.Api.Base.Action action_list = 1;
inline int ActionList::action_list_size() const {
  return action_list_.size();
}
inline void ActionList::clear_action_list() {
  action_list_.Clear();
}
inline const ::Kinova::Api::Base::Action& ActionList::action_list(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActionList.action_list)
  return action_list_.Get(index);
}
inline ::Kinova::Api::Base::Action* ActionList::mutable_action_list(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ActionList.action_list)
  return action_list_.Mutable(index);
}
inline ::Kinova::Api::Base::Action* ActionList::add_action_list() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.ActionList.action_list)
  return action_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Action >*
ActionList::mutable_action_list() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.ActionList.action_list)
  return &action_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Action >&
ActionList::action_list() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.ActionList.action_list)
  return action_list_;
}

// -------------------------------------------------------------------

// Timeout

// uint32 value = 1;
inline void Timeout::clear_value() {
  value_ = 0u;
}
inline ::google::protobuf::uint32 Timeout::value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Timeout.value)
  return value_;
}
inline void Timeout::set_value(::google::protobuf::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Timeout.value)
}

// -------------------------------------------------------------------

// Ssid

// string identifier = 1;
inline void Ssid::clear_identifier() {
  identifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Ssid::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Ssid.identifier)
  return identifier_.GetNoArena();
}
inline void Ssid::set_identifier(const ::std::string& value) {
  
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Ssid.identifier)
}
#if LANG_CXX11
inline void Ssid::set_identifier(::std::string&& value) {
  
  identifier_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.Ssid.identifier)
}
#endif
inline void Ssid::set_identifier(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.Ssid.identifier)
}
inline void Ssid::set_identifier(const char* value, size_t size) {
  
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.Ssid.identifier)
}
inline ::std::string* Ssid::mutable_identifier() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Ssid.identifier)
  return identifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ssid::release_identifier() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Ssid.identifier)
  
  return identifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ssid::set_allocated_identifier(::std::string* identifier) {
  if (identifier != NULL) {
    
  } else {
    
  }
  identifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), identifier);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Ssid.identifier)
}

// -------------------------------------------------------------------

// CommunicationInterfaceConfiguration

// .Kinova.Api.Base.NetworkType type = 1;
inline void CommunicationInterfaceConfiguration::clear_type() {
  type_ = 0;
}
inline ::Kinova::Api::Base::NetworkType CommunicationInterfaceConfiguration::type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CommunicationInterfaceConfiguration.type)
  return static_cast< ::Kinova::Api::Base::NetworkType >(type_);
}
inline void CommunicationInterfaceConfiguration::set_type(::Kinova::Api::Base::NetworkType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CommunicationInterfaceConfiguration.type)
}

// bool enable = 2;
inline void CommunicationInterfaceConfiguration::clear_enable() {
  enable_ = false;
}
inline bool CommunicationInterfaceConfiguration::enable() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CommunicationInterfaceConfiguration.enable)
  return enable_;
}
inline void CommunicationInterfaceConfiguration::set_enable(bool value) {
  
  enable_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CommunicationInterfaceConfiguration.enable)
}

// -------------------------------------------------------------------

// NetworkHandle

// .Kinova.Api.Base.NetworkType type = 1;
inline void NetworkHandle::clear_type() {
  type_ = 0;
}
inline ::Kinova::Api::Base::NetworkType NetworkHandle::type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.NetworkHandle.type)
  return static_cast< ::Kinova::Api::Base::NetworkType >(type_);
}
inline void NetworkHandle::set_type(::Kinova::Api::Base::NetworkType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.NetworkHandle.type)
}

// -------------------------------------------------------------------

// IPv4Configuration

// uint32 ip_address = 1;
inline void IPv4Configuration::clear_ip_address() {
  ip_address_ = 0u;
}
inline ::google::protobuf::uint32 IPv4Configuration::ip_address() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.IPv4Configuration.ip_address)
  return ip_address_;
}
inline void IPv4Configuration::set_ip_address(::google::protobuf::uint32 value) {
  
  ip_address_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.IPv4Configuration.ip_address)
}

// uint32 subnet_mask = 2;
inline void IPv4Configuration::clear_subnet_mask() {
  subnet_mask_ = 0u;
}
inline ::google::protobuf::uint32 IPv4Configuration::subnet_mask() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.IPv4Configuration.subnet_mask)
  return subnet_mask_;
}
inline void IPv4Configuration::set_subnet_mask(::google::protobuf::uint32 value) {
  
  subnet_mask_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.IPv4Configuration.subnet_mask)
}

// uint32 default_gateway = 3;
inline void IPv4Configuration::clear_default_gateway() {
  default_gateway_ = 0u;
}
inline ::google::protobuf::uint32 IPv4Configuration::default_gateway() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.IPv4Configuration.default_gateway)
  return default_gateway_;
}
inline void IPv4Configuration::set_default_gateway(::google::protobuf::uint32 value) {
  
  default_gateway_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.IPv4Configuration.default_gateway)
}

// bool dhcp_enabled = 4;
inline void IPv4Configuration::clear_dhcp_enabled() {
  dhcp_enabled_ = false;
}
inline bool IPv4Configuration::dhcp_enabled() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.IPv4Configuration.dhcp_enabled)
  return dhcp_enabled_;
}
inline void IPv4Configuration::set_dhcp_enabled(bool value) {
  
  dhcp_enabled_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.IPv4Configuration.dhcp_enabled)
}

// -------------------------------------------------------------------

// IPv4Information

// uint32 ip_address = 1;
inline void IPv4Information::clear_ip_address() {
  ip_address_ = 0u;
}
inline ::google::protobuf::uint32 IPv4Information::ip_address() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.IPv4Information.ip_address)
  return ip_address_;
}
inline void IPv4Information::set_ip_address(::google::protobuf::uint32 value) {
  
  ip_address_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.IPv4Information.ip_address)
}

// uint32 subnet_mask = 2;
inline void IPv4Information::clear_subnet_mask() {
  subnet_mask_ = 0u;
}
inline ::google::protobuf::uint32 IPv4Information::subnet_mask() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.IPv4Information.subnet_mask)
  return subnet_mask_;
}
inline void IPv4Information::set_subnet_mask(::google::protobuf::uint32 value) {
  
  subnet_mask_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.IPv4Information.subnet_mask)
}

// uint32 default_gateway = 3;
inline void IPv4Information::clear_default_gateway() {
  default_gateway_ = 0u;
}
inline ::google::protobuf::uint32 IPv4Information::default_gateway() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.IPv4Information.default_gateway)
  return default_gateway_;
}
inline void IPv4Information::set_default_gateway(::google::protobuf::uint32 value) {
  
  default_gateway_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.IPv4Information.default_gateway)
}

// -------------------------------------------------------------------

// FullIPv4Configuration

// .Kinova.Api.Base.NetworkHandle handle = 1;
inline bool FullIPv4Configuration::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline void FullIPv4Configuration::clear_handle() {
  if (GetArenaNoVirtual() == NULL && handle_ != NULL) {
    delete handle_;
  }
  handle_ = NULL;
}
inline const ::Kinova::Api::Base::NetworkHandle& FullIPv4Configuration::handle() const {
  const ::Kinova::Api::Base::NetworkHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.FullIPv4Configuration.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::NetworkHandle*>(
      &::Kinova::Api::Base::_NetworkHandle_default_instance_);
}
inline ::Kinova::Api::Base::NetworkHandle* FullIPv4Configuration::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.FullIPv4Configuration.handle)
  
  ::Kinova::Api::Base::NetworkHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::NetworkHandle* FullIPv4Configuration::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Base::NetworkHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.FullIPv4Configuration.handle)
  return handle_;
}
inline void FullIPv4Configuration::set_allocated_handle(::Kinova::Api::Base::NetworkHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handle_;
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.FullIPv4Configuration.handle)
}

// .Kinova.Api.Base.IPv4Configuration ipv4_configuration = 2;
inline bool FullIPv4Configuration::has_ipv4_configuration() const {
  return this != internal_default_instance() && ipv4_configuration_ != NULL;
}
inline void FullIPv4Configuration::clear_ipv4_configuration() {
  if (GetArenaNoVirtual() == NULL && ipv4_configuration_ != NULL) {
    delete ipv4_configuration_;
  }
  ipv4_configuration_ = NULL;
}
inline const ::Kinova::Api::Base::IPv4Configuration& FullIPv4Configuration::ipv4_configuration() const {
  const ::Kinova::Api::Base::IPv4Configuration* p = ipv4_configuration_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.FullIPv4Configuration.ipv4_configuration)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::IPv4Configuration*>(
      &::Kinova::Api::Base::_IPv4Configuration_default_instance_);
}
inline ::Kinova::Api::Base::IPv4Configuration* FullIPv4Configuration::release_ipv4_configuration() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.FullIPv4Configuration.ipv4_configuration)
  
  ::Kinova::Api::Base::IPv4Configuration* temp = ipv4_configuration_;
  ipv4_configuration_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::IPv4Configuration* FullIPv4Configuration::mutable_ipv4_configuration() {
  
  if (ipv4_configuration_ == NULL) {
    ipv4_configuration_ = new ::Kinova::Api::Base::IPv4Configuration;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.FullIPv4Configuration.ipv4_configuration)
  return ipv4_configuration_;
}
inline void FullIPv4Configuration::set_allocated_ipv4_configuration(::Kinova::Api::Base::IPv4Configuration* ipv4_configuration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ipv4_configuration_;
  }
  if (ipv4_configuration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ipv4_configuration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ipv4_configuration, submessage_arena);
    }
    
  } else {
    
  }
  ipv4_configuration_ = ipv4_configuration;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.FullIPv4Configuration.ipv4_configuration)
}

// -------------------------------------------------------------------

// WifiInformation

// .Kinova.Api.Base.Ssid ssid = 1;
inline bool WifiInformation::has_ssid() const {
  return this != internal_default_instance() && ssid_ != NULL;
}
inline void WifiInformation::clear_ssid() {
  if (GetArenaNoVirtual() == NULL && ssid_ != NULL) {
    delete ssid_;
  }
  ssid_ = NULL;
}
inline const ::Kinova::Api::Base::Ssid& WifiInformation::ssid() const {
  const ::Kinova::Api::Base::Ssid* p = ssid_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WifiInformation.ssid)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::Ssid*>(
      &::Kinova::Api::Base::_Ssid_default_instance_);
}
inline ::Kinova::Api::Base::Ssid* WifiInformation::release_ssid() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.WifiInformation.ssid)
  
  ::Kinova::Api::Base::Ssid* temp = ssid_;
  ssid_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::Ssid* WifiInformation::mutable_ssid() {
  
  if (ssid_ == NULL) {
    ssid_ = new ::Kinova::Api::Base::Ssid;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.WifiInformation.ssid)
  return ssid_;
}
inline void WifiInformation::set_allocated_ssid(::Kinova::Api::Base::Ssid* ssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ssid_;
  }
  if (ssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ssid, submessage_arena);
    }
    
  } else {
    
  }
  ssid_ = ssid;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.WifiInformation.ssid)
}

// fixed32 security_type = 2;
inline void WifiInformation::clear_security_type() {
  security_type_ = 0u;
}
inline ::google::protobuf::uint32 WifiInformation::security_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WifiInformation.security_type)
  return security_type_;
}
inline void WifiInformation::set_security_type(::google::protobuf::uint32 value) {
  
  security_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WifiInformation.security_type)
}

// fixed32 encryption_type = 3;
inline void WifiInformation::clear_encryption_type() {
  encryption_type_ = 0u;
}
inline ::google::protobuf::uint32 WifiInformation::encryption_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WifiInformation.encryption_type)
  return encryption_type_;
}
inline void WifiInformation::set_encryption_type(::google::protobuf::uint32 value) {
  
  encryption_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WifiInformation.encryption_type)
}

// .Kinova.Api.Base.SignalQuality signal_quality = 4;
inline void WifiInformation::clear_signal_quality() {
  signal_quality_ = 0;
}
inline ::Kinova::Api::Base::SignalQuality WifiInformation::signal_quality() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WifiInformation.signal_quality)
  return static_cast< ::Kinova::Api::Base::SignalQuality >(signal_quality_);
}
inline void WifiInformation::set_signal_quality(::Kinova::Api::Base::SignalQuality value) {
  
  signal_quality_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WifiInformation.signal_quality)
}

// int32 signal_strength = 5;
inline void WifiInformation::clear_signal_strength() {
  signal_strength_ = 0;
}
inline ::google::protobuf::int32 WifiInformation::signal_strength() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WifiInformation.signal_strength)
  return signal_strength_;
}
inline void WifiInformation::set_signal_strength(::google::protobuf::int32 value) {
  
  signal_strength_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WifiInformation.signal_strength)
}

// uint32 frequency = 6;
inline void WifiInformation::clear_frequency() {
  frequency_ = 0u;
}
inline ::google::protobuf::uint32 WifiInformation::frequency() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WifiInformation.frequency)
  return frequency_;
}
inline void WifiInformation::set_frequency(::google::protobuf::uint32 value) {
  
  frequency_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WifiInformation.frequency)
}

// uint32 channel = 7;
inline void WifiInformation::clear_channel() {
  channel_ = 0u;
}
inline ::google::protobuf::uint32 WifiInformation::channel() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WifiInformation.channel)
  return channel_;
}
inline void WifiInformation::set_channel(::google::protobuf::uint32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WifiInformation.channel)
}

// -------------------------------------------------------------------

// WifiInformationList

// repeated .Kinova.Api.Base.WifiInformation wifi_information_list = 1;
inline int WifiInformationList::wifi_information_list_size() const {
  return wifi_information_list_.size();
}
inline void WifiInformationList::clear_wifi_information_list() {
  wifi_information_list_.Clear();
}
inline const ::Kinova::Api::Base::WifiInformation& WifiInformationList::wifi_information_list(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WifiInformationList.wifi_information_list)
  return wifi_information_list_.Get(index);
}
inline ::Kinova::Api::Base::WifiInformation* WifiInformationList::mutable_wifi_information_list(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.WifiInformationList.wifi_information_list)
  return wifi_information_list_.Mutable(index);
}
inline ::Kinova::Api::Base::WifiInformation* WifiInformationList::add_wifi_information_list() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.WifiInformationList.wifi_information_list)
  return wifi_information_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::WifiInformation >*
WifiInformationList::mutable_wifi_information_list() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.WifiInformationList.wifi_information_list)
  return &wifi_information_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::WifiInformation >&
WifiInformationList::wifi_information_list() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.WifiInformationList.wifi_information_list)
  return wifi_information_list_;
}

// -------------------------------------------------------------------

// WifiConfiguration

// .Kinova.Api.Base.Ssid ssid = 1;
inline bool WifiConfiguration::has_ssid() const {
  return this != internal_default_instance() && ssid_ != NULL;
}
inline void WifiConfiguration::clear_ssid() {
  if (GetArenaNoVirtual() == NULL && ssid_ != NULL) {
    delete ssid_;
  }
  ssid_ = NULL;
}
inline const ::Kinova::Api::Base::Ssid& WifiConfiguration::ssid() const {
  const ::Kinova::Api::Base::Ssid* p = ssid_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WifiConfiguration.ssid)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::Ssid*>(
      &::Kinova::Api::Base::_Ssid_default_instance_);
}
inline ::Kinova::Api::Base::Ssid* WifiConfiguration::release_ssid() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.WifiConfiguration.ssid)
  
  ::Kinova::Api::Base::Ssid* temp = ssid_;
  ssid_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::Ssid* WifiConfiguration::mutable_ssid() {
  
  if (ssid_ == NULL) {
    ssid_ = new ::Kinova::Api::Base::Ssid;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.WifiConfiguration.ssid)
  return ssid_;
}
inline void WifiConfiguration::set_allocated_ssid(::Kinova::Api::Base::Ssid* ssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ssid_;
  }
  if (ssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ssid, submessage_arena);
    }
    
  } else {
    
  }
  ssid_ = ssid;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.WifiConfiguration.ssid)
}

// string security_key = 2;
inline void WifiConfiguration::clear_security_key() {
  security_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WifiConfiguration::security_key() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WifiConfiguration.security_key)
  return security_key_.GetNoArena();
}
inline void WifiConfiguration::set_security_key(const ::std::string& value) {
  
  security_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WifiConfiguration.security_key)
}
#if LANG_CXX11
inline void WifiConfiguration::set_security_key(::std::string&& value) {
  
  security_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.WifiConfiguration.security_key)
}
#endif
inline void WifiConfiguration::set_security_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  security_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.WifiConfiguration.security_key)
}
inline void WifiConfiguration::set_security_key(const char* value, size_t size) {
  
  security_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.WifiConfiguration.security_key)
}
inline ::std::string* WifiConfiguration::mutable_security_key() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.WifiConfiguration.security_key)
  return security_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WifiConfiguration::release_security_key() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.WifiConfiguration.security_key)
  
  return security_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WifiConfiguration::set_allocated_security_key(::std::string* security_key) {
  if (security_key != NULL) {
    
  } else {
    
  }
  security_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), security_key);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.WifiConfiguration.security_key)
}

// bool connect_automatically = 3;
inline void WifiConfiguration::clear_connect_automatically() {
  connect_automatically_ = false;
}
inline bool WifiConfiguration::connect_automatically() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WifiConfiguration.connect_automatically)
  return connect_automatically_;
}
inline void WifiConfiguration::set_connect_automatically(bool value) {
  
  connect_automatically_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WifiConfiguration.connect_automatically)
}

// -------------------------------------------------------------------

// WifiConfigurationList

// repeated .Kinova.Api.Base.WifiConfiguration wifi_configuration_list = 1;
inline int WifiConfigurationList::wifi_configuration_list_size() const {
  return wifi_configuration_list_.size();
}
inline void WifiConfigurationList::clear_wifi_configuration_list() {
  wifi_configuration_list_.Clear();
}
inline const ::Kinova::Api::Base::WifiConfiguration& WifiConfigurationList::wifi_configuration_list(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WifiConfigurationList.wifi_configuration_list)
  return wifi_configuration_list_.Get(index);
}
inline ::Kinova::Api::Base::WifiConfiguration* WifiConfigurationList::mutable_wifi_configuration_list(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.WifiConfigurationList.wifi_configuration_list)
  return wifi_configuration_list_.Mutable(index);
}
inline ::Kinova::Api::Base::WifiConfiguration* WifiConfigurationList::add_wifi_configuration_list() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.WifiConfigurationList.wifi_configuration_list)
  return wifi_configuration_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::WifiConfiguration >*
WifiConfigurationList::mutable_wifi_configuration_list() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.WifiConfigurationList.wifi_configuration_list)
  return &wifi_configuration_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::WifiConfiguration >&
WifiConfigurationList::wifi_configuration_list() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.WifiConfigurationList.wifi_configuration_list)
  return wifi_configuration_list_;
}

// -------------------------------------------------------------------

// ProtectionZoneHandle

// uint32 identifier = 1;
inline void ProtectionZoneHandle::clear_identifier() {
  identifier_ = 0u;
}
inline ::google::protobuf::uint32 ProtectionZoneHandle::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZoneHandle.identifier)
  return identifier_;
}
inline void ProtectionZoneHandle::set_identifier(::google::protobuf::uint32 value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ProtectionZoneHandle.identifier)
}

// fixed32 permission = 2;
inline void ProtectionZoneHandle::clear_permission() {
  permission_ = 0u;
}
inline ::google::protobuf::uint32 ProtectionZoneHandle::permission() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZoneHandle.permission)
  return permission_;
}
inline void ProtectionZoneHandle::set_permission(::google::protobuf::uint32 value) {
  
  permission_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ProtectionZoneHandle.permission)
}

// -------------------------------------------------------------------

// RotationMatrixRow

// float column1 = 1;
inline void RotationMatrixRow::clear_column1() {
  column1_ = 0;
}
inline float RotationMatrixRow::column1() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.RotationMatrixRow.column1)
  return column1_;
}
inline void RotationMatrixRow::set_column1(float value) {
  
  column1_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.RotationMatrixRow.column1)
}

// float column2 = 2;
inline void RotationMatrixRow::clear_column2() {
  column2_ = 0;
}
inline float RotationMatrixRow::column2() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.RotationMatrixRow.column2)
  return column2_;
}
inline void RotationMatrixRow::set_column2(float value) {
  
  column2_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.RotationMatrixRow.column2)
}

// float column3 = 3;
inline void RotationMatrixRow::clear_column3() {
  column3_ = 0;
}
inline float RotationMatrixRow::column3() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.RotationMatrixRow.column3)
  return column3_;
}
inline void RotationMatrixRow::set_column3(float value) {
  
  column3_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.RotationMatrixRow.column3)
}

// -------------------------------------------------------------------

// RotationMatrix

// .Kinova.Api.Base.RotationMatrixRow row1 = 1;
inline bool RotationMatrix::has_row1() const {
  return this != internal_default_instance() && row1_ != NULL;
}
inline void RotationMatrix::clear_row1() {
  if (GetArenaNoVirtual() == NULL && row1_ != NULL) {
    delete row1_;
  }
  row1_ = NULL;
}
inline const ::Kinova::Api::Base::RotationMatrixRow& RotationMatrix::row1() const {
  const ::Kinova::Api::Base::RotationMatrixRow* p = row1_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.RotationMatrix.row1)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::RotationMatrixRow*>(
      &::Kinova::Api::Base::_RotationMatrixRow_default_instance_);
}
inline ::Kinova::Api::Base::RotationMatrixRow* RotationMatrix::release_row1() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.RotationMatrix.row1)
  
  ::Kinova::Api::Base::RotationMatrixRow* temp = row1_;
  row1_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::RotationMatrixRow* RotationMatrix::mutable_row1() {
  
  if (row1_ == NULL) {
    row1_ = new ::Kinova::Api::Base::RotationMatrixRow;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.RotationMatrix.row1)
  return row1_;
}
inline void RotationMatrix::set_allocated_row1(::Kinova::Api::Base::RotationMatrixRow* row1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete row1_;
  }
  if (row1) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      row1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, row1, submessage_arena);
    }
    
  } else {
    
  }
  row1_ = row1;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.RotationMatrix.row1)
}

// .Kinova.Api.Base.RotationMatrixRow row2 = 2;
inline bool RotationMatrix::has_row2() const {
  return this != internal_default_instance() && row2_ != NULL;
}
inline void RotationMatrix::clear_row2() {
  if (GetArenaNoVirtual() == NULL && row2_ != NULL) {
    delete row2_;
  }
  row2_ = NULL;
}
inline const ::Kinova::Api::Base::RotationMatrixRow& RotationMatrix::row2() const {
  const ::Kinova::Api::Base::RotationMatrixRow* p = row2_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.RotationMatrix.row2)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::RotationMatrixRow*>(
      &::Kinova::Api::Base::_RotationMatrixRow_default_instance_);
}
inline ::Kinova::Api::Base::RotationMatrixRow* RotationMatrix::release_row2() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.RotationMatrix.row2)
  
  ::Kinova::Api::Base::RotationMatrixRow* temp = row2_;
  row2_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::RotationMatrixRow* RotationMatrix::mutable_row2() {
  
  if (row2_ == NULL) {
    row2_ = new ::Kinova::Api::Base::RotationMatrixRow;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.RotationMatrix.row2)
  return row2_;
}
inline void RotationMatrix::set_allocated_row2(::Kinova::Api::Base::RotationMatrixRow* row2) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete row2_;
  }
  if (row2) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      row2 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, row2, submessage_arena);
    }
    
  } else {
    
  }
  row2_ = row2;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.RotationMatrix.row2)
}

// .Kinova.Api.Base.RotationMatrixRow row3 = 3;
inline bool RotationMatrix::has_row3() const {
  return this != internal_default_instance() && row3_ != NULL;
}
inline void RotationMatrix::clear_row3() {
  if (GetArenaNoVirtual() == NULL && row3_ != NULL) {
    delete row3_;
  }
  row3_ = NULL;
}
inline const ::Kinova::Api::Base::RotationMatrixRow& RotationMatrix::row3() const {
  const ::Kinova::Api::Base::RotationMatrixRow* p = row3_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.RotationMatrix.row3)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::RotationMatrixRow*>(
      &::Kinova::Api::Base::_RotationMatrixRow_default_instance_);
}
inline ::Kinova::Api::Base::RotationMatrixRow* RotationMatrix::release_row3() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.RotationMatrix.row3)
  
  ::Kinova::Api::Base::RotationMatrixRow* temp = row3_;
  row3_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::RotationMatrixRow* RotationMatrix::mutable_row3() {
  
  if (row3_ == NULL) {
    row3_ = new ::Kinova::Api::Base::RotationMatrixRow;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.RotationMatrix.row3)
  return row3_;
}
inline void RotationMatrix::set_allocated_row3(::Kinova::Api::Base::RotationMatrixRow* row3) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete row3_;
  }
  if (row3) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      row3 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, row3, submessage_arena);
    }
    
  } else {
    
  }
  row3_ = row3;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.RotationMatrix.row3)
}

// -------------------------------------------------------------------

// Point

// float x = 1;
inline void Point::clear_x() {
  x_ = 0;
}
inline float Point::x() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Point.x)
  return x_;
}
inline void Point::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Point.x)
}

// float y = 2;
inline void Point::clear_y() {
  y_ = 0;
}
inline float Point::y() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Point.y)
  return y_;
}
inline void Point::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Point.y)
}

// float z = 3;
inline void Point::clear_z() {
  z_ = 0;
}
inline float Point::z() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Point.z)
  return z_;
}
inline void Point::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Point.z)
}

// -------------------------------------------------------------------

// ZoneShape

// .Kinova.Api.Base.ShapeType shape_type = 1;
inline void ZoneShape::clear_shape_type() {
  shape_type_ = 0;
}
inline ::Kinova::Api::Base::ShapeType ZoneShape::shape_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ZoneShape.shape_type)
  return static_cast< ::Kinova::Api::Base::ShapeType >(shape_type_);
}
inline void ZoneShape::set_shape_type(::Kinova::Api::Base::ShapeType value) {
  
  shape_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ZoneShape.shape_type)
}

// .Kinova.Api.Base.Point origin = 2;
inline bool ZoneShape::has_origin() const {
  return this != internal_default_instance() && origin_ != NULL;
}
inline void ZoneShape::clear_origin() {
  if (GetArenaNoVirtual() == NULL && origin_ != NULL) {
    delete origin_;
  }
  origin_ = NULL;
}
inline const ::Kinova::Api::Base::Point& ZoneShape::origin() const {
  const ::Kinova::Api::Base::Point* p = origin_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ZoneShape.origin)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::Point*>(
      &::Kinova::Api::Base::_Point_default_instance_);
}
inline ::Kinova::Api::Base::Point* ZoneShape::release_origin() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ZoneShape.origin)
  
  ::Kinova::Api::Base::Point* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::Point* ZoneShape::mutable_origin() {
  
  if (origin_ == NULL) {
    origin_ = new ::Kinova::Api::Base::Point;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ZoneShape.origin)
  return origin_;
}
inline void ZoneShape::set_allocated_origin(::Kinova::Api::Base::Point* origin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete origin_;
  }
  if (origin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      origin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    
  } else {
    
  }
  origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ZoneShape.origin)
}

// .Kinova.Api.Base.RotationMatrix orientation = 3;
inline bool ZoneShape::has_orientation() const {
  return this != internal_default_instance() && orientation_ != NULL;
}
inline void ZoneShape::clear_orientation() {
  if (GetArenaNoVirtual() == NULL && orientation_ != NULL) {
    delete orientation_;
  }
  orientation_ = NULL;
}
inline const ::Kinova::Api::Base::RotationMatrix& ZoneShape::orientation() const {
  const ::Kinova::Api::Base::RotationMatrix* p = orientation_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ZoneShape.orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::RotationMatrix*>(
      &::Kinova::Api::Base::_RotationMatrix_default_instance_);
}
inline ::Kinova::Api::Base::RotationMatrix* ZoneShape::release_orientation() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ZoneShape.orientation)
  
  ::Kinova::Api::Base::RotationMatrix* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::RotationMatrix* ZoneShape::mutable_orientation() {
  
  if (orientation_ == NULL) {
    orientation_ = new ::Kinova::Api::Base::RotationMatrix;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ZoneShape.orientation)
  return orientation_;
}
inline void ZoneShape::set_allocated_orientation(::Kinova::Api::Base::RotationMatrix* orientation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orientation_;
  }
  if (orientation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orientation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    
  } else {
    
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ZoneShape.orientation)
}

// repeated float dimensions = 4;
inline int ZoneShape::dimensions_size() const {
  return dimensions_.size();
}
inline void ZoneShape::clear_dimensions() {
  dimensions_.Clear();
}
inline float ZoneShape::dimensions(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ZoneShape.dimensions)
  return dimensions_.Get(index);
}
inline void ZoneShape::set_dimensions(int index, float value) {
  dimensions_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ZoneShape.dimensions)
}
inline void ZoneShape::add_dimensions(float value) {
  dimensions_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.ZoneShape.dimensions)
}
inline const ::google::protobuf::RepeatedField< float >&
ZoneShape::dimensions() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.ZoneShape.dimensions)
  return dimensions_;
}
inline ::google::protobuf::RepeatedField< float >*
ZoneShape::mutable_dimensions() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.ZoneShape.dimensions)
  return &dimensions_;
}

// float envelope_thickness = 5;
inline void ZoneShape::clear_envelope_thickness() {
  envelope_thickness_ = 0;
}
inline float ZoneShape::envelope_thickness() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ZoneShape.envelope_thickness)
  return envelope_thickness_;
}
inline void ZoneShape::set_envelope_thickness(float value) {
  
  envelope_thickness_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ZoneShape.envelope_thickness)
}

// -------------------------------------------------------------------

// ProtectionZone

// .Kinova.Api.Base.ProtectionZoneHandle handle = 1;
inline bool ProtectionZone::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline void ProtectionZone::clear_handle() {
  if (GetArenaNoVirtual() == NULL && handle_ != NULL) {
    delete handle_;
  }
  handle_ = NULL;
}
inline const ::Kinova::Api::Base::ProtectionZoneHandle& ProtectionZone::handle() const {
  const ::Kinova::Api::Base::ProtectionZoneHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZone.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::ProtectionZoneHandle*>(
      &::Kinova::Api::Base::_ProtectionZoneHandle_default_instance_);
}
inline ::Kinova::Api::Base::ProtectionZoneHandle* ProtectionZone::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ProtectionZone.handle)
  
  ::Kinova::Api::Base::ProtectionZoneHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::ProtectionZoneHandle* ProtectionZone::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Base::ProtectionZoneHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ProtectionZone.handle)
  return handle_;
}
inline void ProtectionZone::set_allocated_handle(::Kinova::Api::Base::ProtectionZoneHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handle_;
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ProtectionZone.handle)
}

// string name = 2;
inline void ProtectionZone::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProtectionZone::name() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZone.name)
  return name_.GetNoArena();
}
inline void ProtectionZone::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ProtectionZone.name)
}
#if LANG_CXX11
inline void ProtectionZone::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.ProtectionZone.name)
}
#endif
inline void ProtectionZone::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.ProtectionZone.name)
}
inline void ProtectionZone::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.ProtectionZone.name)
}
inline ::std::string* ProtectionZone::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ProtectionZone.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtectionZone::release_name() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ProtectionZone.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtectionZone::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ProtectionZone.name)
}

// string application_data = 3;
inline void ProtectionZone::clear_application_data() {
  application_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProtectionZone::application_data() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZone.application_data)
  return application_data_.GetNoArena();
}
inline void ProtectionZone::set_application_data(const ::std::string& value) {
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ProtectionZone.application_data)
}
#if LANG_CXX11
inline void ProtectionZone::set_application_data(::std::string&& value) {
  
  application_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.ProtectionZone.application_data)
}
#endif
inline void ProtectionZone::set_application_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.ProtectionZone.application_data)
}
inline void ProtectionZone::set_application_data(const char* value, size_t size) {
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.ProtectionZone.application_data)
}
inline ::std::string* ProtectionZone::mutable_application_data() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ProtectionZone.application_data)
  return application_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtectionZone::release_application_data() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ProtectionZone.application_data)
  
  return application_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtectionZone::set_allocated_application_data(::std::string* application_data) {
  if (application_data != NULL) {
    
  } else {
    
  }
  application_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), application_data);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ProtectionZone.application_data)
}

// bool is_enabled = 4;
inline void ProtectionZone::clear_is_enabled() {
  is_enabled_ = false;
}
inline bool ProtectionZone::is_enabled() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZone.is_enabled)
  return is_enabled_;
}
inline void ProtectionZone::set_is_enabled(bool value) {
  
  is_enabled_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ProtectionZone.is_enabled)
}

// .Kinova.Api.Base.ZoneShape shape = 5;
inline bool ProtectionZone::has_shape() const {
  return this != internal_default_instance() && shape_ != NULL;
}
inline void ProtectionZone::clear_shape() {
  if (GetArenaNoVirtual() == NULL && shape_ != NULL) {
    delete shape_;
  }
  shape_ = NULL;
}
inline const ::Kinova::Api::Base::ZoneShape& ProtectionZone::shape() const {
  const ::Kinova::Api::Base::ZoneShape* p = shape_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZone.shape)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::ZoneShape*>(
      &::Kinova::Api::Base::_ZoneShape_default_instance_);
}
inline ::Kinova::Api::Base::ZoneShape* ProtectionZone::release_shape() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ProtectionZone.shape)
  
  ::Kinova::Api::Base::ZoneShape* temp = shape_;
  shape_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::ZoneShape* ProtectionZone::mutable_shape() {
  
  if (shape_ == NULL) {
    shape_ = new ::Kinova::Api::Base::ZoneShape;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ProtectionZone.shape)
  return shape_;
}
inline void ProtectionZone::set_allocated_shape(::Kinova::Api::Base::ZoneShape* shape) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shape_;
  }
  if (shape) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      shape = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shape, submessage_arena);
    }
    
  } else {
    
  }
  shape_ = shape;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ProtectionZone.shape)
}

// repeated .Kinova.Api.Base.CartesianLimitation limitations = 6;
inline int ProtectionZone::limitations_size() const {
  return limitations_.size();
}
inline void ProtectionZone::clear_limitations() {
  limitations_.Clear();
}
inline const ::Kinova::Api::Base::CartesianLimitation& ProtectionZone::limitations(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZone.limitations)
  return limitations_.Get(index);
}
inline ::Kinova::Api::Base::CartesianLimitation* ProtectionZone::mutable_limitations(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ProtectionZone.limitations)
  return limitations_.Mutable(index);
}
inline ::Kinova::Api::Base::CartesianLimitation* ProtectionZone::add_limitations() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.ProtectionZone.limitations)
  return limitations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation >*
ProtectionZone::mutable_limitations() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.ProtectionZone.limitations)
  return &limitations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation >&
ProtectionZone::limitations() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.ProtectionZone.limitations)
  return limitations_;
}

// repeated .Kinova.Api.Base.CartesianLimitation envelope_limitations = 7;
inline int ProtectionZone::envelope_limitations_size() const {
  return envelope_limitations_.size();
}
inline void ProtectionZone::clear_envelope_limitations() {
  envelope_limitations_.Clear();
}
inline const ::Kinova::Api::Base::CartesianLimitation& ProtectionZone::envelope_limitations(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZone.envelope_limitations)
  return envelope_limitations_.Get(index);
}
inline ::Kinova::Api::Base::CartesianLimitation* ProtectionZone::mutable_envelope_limitations(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ProtectionZone.envelope_limitations)
  return envelope_limitations_.Mutable(index);
}
inline ::Kinova::Api::Base::CartesianLimitation* ProtectionZone::add_envelope_limitations() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.ProtectionZone.envelope_limitations)
  return envelope_limitations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation >*
ProtectionZone::mutable_envelope_limitations() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.ProtectionZone.envelope_limitations)
  return &envelope_limitations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation >&
ProtectionZone::envelope_limitations() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.ProtectionZone.envelope_limitations)
  return envelope_limitations_;
}

// -------------------------------------------------------------------

// ProtectionZoneList

// repeated .Kinova.Api.Base.ProtectionZone protection_zones = 1;
inline int ProtectionZoneList::protection_zones_size() const {
  return protection_zones_.size();
}
inline void ProtectionZoneList::clear_protection_zones() {
  protection_zones_.Clear();
}
inline const ::Kinova::Api::Base::ProtectionZone& ProtectionZoneList::protection_zones(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZoneList.protection_zones)
  return protection_zones_.Get(index);
}
inline ::Kinova::Api::Base::ProtectionZone* ProtectionZoneList::mutable_protection_zones(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ProtectionZoneList.protection_zones)
  return protection_zones_.Mutable(index);
}
inline ::Kinova::Api::Base::ProtectionZone* ProtectionZoneList::add_protection_zones() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.ProtectionZoneList.protection_zones)
  return protection_zones_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ProtectionZone >*
ProtectionZoneList::mutable_protection_zones() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.ProtectionZoneList.protection_zones)
  return &protection_zones_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ProtectionZone >&
ProtectionZoneList::protection_zones() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.ProtectionZoneList.protection_zones)
  return protection_zones_;
}

// -------------------------------------------------------------------

// CartesianLimitation

// .Kinova.Api.Base.LimitationType type = 1;
inline void CartesianLimitation::clear_type() {
  type_ = 0;
}
inline ::Kinova::Api::Base::LimitationType CartesianLimitation::type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CartesianLimitation.type)
  return static_cast< ::Kinova::Api::Base::LimitationType >(type_);
}
inline void CartesianLimitation::set_type(::Kinova::Api::Base::LimitationType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CartesianLimitation.type)
}

// float translation = 2;
inline void CartesianLimitation::clear_translation() {
  translation_ = 0;
}
inline float CartesianLimitation::translation() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CartesianLimitation.translation)
  return translation_;
}
inline void CartesianLimitation::set_translation(float value) {
  
  translation_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CartesianLimitation.translation)
}

// float orientation = 3;
inline void CartesianLimitation::clear_orientation() {
  orientation_ = 0;
}
inline float CartesianLimitation::orientation() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CartesianLimitation.orientation)
  return orientation_;
}
inline void CartesianLimitation::set_orientation(float value) {
  
  orientation_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CartesianLimitation.orientation)
}

// -------------------------------------------------------------------

// TwistLimitation

// float linear = 1;
inline void TwistLimitation::clear_linear() {
  linear_ = 0;
}
inline float TwistLimitation::linear() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TwistLimitation.linear)
  return linear_;
}
inline void TwistLimitation::set_linear(float value) {
  
  linear_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TwistLimitation.linear)
}

// float angular = 2;
inline void TwistLimitation::clear_angular() {
  angular_ = 0;
}
inline float TwistLimitation::angular() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TwistLimitation.angular)
  return angular_;
}
inline void TwistLimitation::set_angular(float value) {
  
  angular_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TwistLimitation.angular)
}

// -------------------------------------------------------------------

// WrenchLimitation

// float force = 1;
inline void WrenchLimitation::clear_force() {
  force_ = 0;
}
inline float WrenchLimitation::force() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WrenchLimitation.force)
  return force_;
}
inline void WrenchLimitation::set_force(float value) {
  
  force_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WrenchLimitation.force)
}

// float torque = 2;
inline void WrenchLimitation::clear_torque() {
  torque_ = 0;
}
inline float WrenchLimitation::torque() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WrenchLimitation.torque)
  return torque_;
}
inline void WrenchLimitation::set_torque(float value) {
  
  torque_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WrenchLimitation.torque)
}

// -------------------------------------------------------------------

// CartesianLimitationList

// repeated .Kinova.Api.Base.CartesianLimitation limitations = 1;
inline int CartesianLimitationList::limitations_size() const {
  return limitations_.size();
}
inline void CartesianLimitationList::clear_limitations() {
  limitations_.Clear();
}
inline const ::Kinova::Api::Base::CartesianLimitation& CartesianLimitationList::limitations(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CartesianLimitationList.limitations)
  return limitations_.Get(index);
}
inline ::Kinova::Api::Base::CartesianLimitation* CartesianLimitationList::mutable_limitations(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.CartesianLimitationList.limitations)
  return limitations_.Mutable(index);
}
inline ::Kinova::Api::Base::CartesianLimitation* CartesianLimitationList::add_limitations() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.CartesianLimitationList.limitations)
  return limitations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation >*
CartesianLimitationList::mutable_limitations() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.CartesianLimitationList.limitations)
  return &limitations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::CartesianLimitation >&
CartesianLimitationList::limitations() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.CartesianLimitationList.limitations)
  return limitations_;
}

// -------------------------------------------------------------------

// JointLimitation

// uint32 joint_identifier = 1;
inline void JointLimitation::clear_joint_identifier() {
  joint_identifier_ = 0u;
}
inline ::google::protobuf::uint32 JointLimitation::joint_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointLimitation.joint_identifier)
  return joint_identifier_;
}
inline void JointLimitation::set_joint_identifier(::google::protobuf::uint32 value) {
  
  joint_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointLimitation.joint_identifier)
}

// .Kinova.Api.Base.LimitationType type = 2;
inline void JointLimitation::clear_type() {
  type_ = 0;
}
inline ::Kinova::Api::Base::LimitationType JointLimitation::type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointLimitation.type)
  return static_cast< ::Kinova::Api::Base::LimitationType >(type_);
}
inline void JointLimitation::set_type(::Kinova::Api::Base::LimitationType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointLimitation.type)
}

// float value = 3;
inline void JointLimitation::clear_value() {
  value_ = 0;
}
inline float JointLimitation::value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointLimitation.value)
  return value_;
}
inline void JointLimitation::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointLimitation.value)
}

// -------------------------------------------------------------------

// JointsLimitationsList

// repeated .Kinova.Api.Base.JointLimitation joints_limitations = 1;
inline int JointsLimitationsList::joints_limitations_size() const {
  return joints_limitations_.size();
}
inline void JointsLimitationsList::clear_joints_limitations() {
  joints_limitations_.Clear();
}
inline const ::Kinova::Api::Base::JointLimitation& JointsLimitationsList::joints_limitations(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointsLimitationsList.joints_limitations)
  return joints_limitations_.Get(index);
}
inline ::Kinova::Api::Base::JointLimitation* JointsLimitationsList::mutable_joints_limitations(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.JointsLimitationsList.joints_limitations)
  return joints_limitations_.Mutable(index);
}
inline ::Kinova::Api::Base::JointLimitation* JointsLimitationsList::add_joints_limitations() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.JointsLimitationsList.joints_limitations)
  return joints_limitations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointLimitation >*
JointsLimitationsList::mutable_joints_limitations() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.JointsLimitationsList.joints_limitations)
  return &joints_limitations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointLimitation >&
JointsLimitationsList::joints_limitations() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.JointsLimitationsList.joints_limitations)
  return joints_limitations_;
}

// -------------------------------------------------------------------

// Query

// .Kinova.Api.Common.Timestamp start_timestamp = 1;
inline bool Query::has_start_timestamp() const {
  return this != internal_default_instance() && start_timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& Query::start_timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = start_timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Query.start_timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* Query::release_start_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Query.start_timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = start_timestamp_;
  start_timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* Query::mutable_start_timestamp() {
  
  if (start_timestamp_ == NULL) {
    start_timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Query.start_timestamp)
  return start_timestamp_;
}
inline void Query::set_allocated_start_timestamp(::Kinova::Api::Common::Timestamp* start_timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_timestamp_);
  }
  if (start_timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  start_timestamp_ = start_timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Query.start_timestamp)
}

// .Kinova.Api.Common.Timestamp end_timestamp = 2;
inline bool Query::has_end_timestamp() const {
  return this != internal_default_instance() && end_timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& Query::end_timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = end_timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Query.end_timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* Query::release_end_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Query.end_timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = end_timestamp_;
  end_timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* Query::mutable_end_timestamp() {
  
  if (end_timestamp_ == NULL) {
    end_timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Query.end_timestamp)
  return end_timestamp_;
}
inline void Query::set_allocated_end_timestamp(::Kinova::Api::Common::Timestamp* end_timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(end_timestamp_);
  }
  if (end_timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end_timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  end_timestamp_ = end_timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Query.end_timestamp)
}

// string username = 3;
inline void Query::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Query::username() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Query.username)
  return username_.GetNoArena();
}
inline void Query::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Query.username)
}
#if LANG_CXX11
inline void Query::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.Query.username)
}
#endif
inline void Query::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.Query.username)
}
inline void Query::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.Query.username)
}
inline ::std::string* Query::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Query.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Query::release_username() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Query.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Query::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Query.username)
}

// -------------------------------------------------------------------

// ConfigurationChangeNotification

// .Kinova.Api.Base.ConfigurationNotificationEvent event = 1;
inline void ConfigurationChangeNotification::clear_event() {
  event_ = 0;
}
inline ::Kinova::Api::Base::ConfigurationNotificationEvent ConfigurationChangeNotification::event() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.event)
  return static_cast< ::Kinova::Api::Base::ConfigurationNotificationEvent >(event_);
}
inline void ConfigurationChangeNotification::set_event(::Kinova::Api::Base::ConfigurationNotificationEvent value) {
  
  event_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ConfigurationChangeNotification.event)
}

// .Kinova.Api.Common.Timestamp timestamp = 2;
inline bool ConfigurationChangeNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& ConfigurationChangeNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* ConfigurationChangeNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConfigurationChangeNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* ConfigurationChangeNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotification.timestamp)
  return timestamp_;
}
inline void ConfigurationChangeNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ConfigurationChangeNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 3;
inline bool ConfigurationChangeNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& ConfigurationChangeNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* ConfigurationChangeNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConfigurationChangeNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* ConfigurationChangeNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotification.user_handle)
  return user_handle_;
}
inline void ConfigurationChangeNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ConfigurationChangeNotification.user_handle)
}

// .Kinova.Api.Base.SequenceHandle sequence_handle = 4;
inline bool ConfigurationChangeNotification::has_sequence_handle() const {
  return configuration_change_case() == kSequenceHandle;
}
inline void ConfigurationChangeNotification::set_has_sequence_handle() {
  _oneof_case_[0] = kSequenceHandle;
}
inline void ConfigurationChangeNotification::clear_sequence_handle() {
  if (has_sequence_handle()) {
    delete configuration_change_.sequence_handle_;
    clear_has_configuration_change();
  }
}
inline ::Kinova::Api::Base::SequenceHandle* ConfigurationChangeNotification::release_sequence_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConfigurationChangeNotification.sequence_handle)
  if (has_sequence_handle()) {
    clear_has_configuration_change();
      ::Kinova::Api::Base::SequenceHandle* temp = configuration_change_.sequence_handle_;
    configuration_change_.sequence_handle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::SequenceHandle& ConfigurationChangeNotification::sequence_handle() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.sequence_handle)
  return has_sequence_handle()
      ? *configuration_change_.sequence_handle_
      : *reinterpret_cast< ::Kinova::Api::Base::SequenceHandle*>(&::Kinova::Api::Base::_SequenceHandle_default_instance_);
}
inline ::Kinova::Api::Base::SequenceHandle* ConfigurationChangeNotification::mutable_sequence_handle() {
  if (!has_sequence_handle()) {
    clear_configuration_change();
    set_has_sequence_handle();
    configuration_change_.sequence_handle_ = new ::Kinova::Api::Base::SequenceHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotification.sequence_handle)
  return configuration_change_.sequence_handle_;
}

// .Kinova.Api.Base.ActionHandle action_handle = 5;
inline bool ConfigurationChangeNotification::has_action_handle() const {
  return configuration_change_case() == kActionHandle;
}
inline void ConfigurationChangeNotification::set_has_action_handle() {
  _oneof_case_[0] = kActionHandle;
}
inline void ConfigurationChangeNotification::clear_action_handle() {
  if (has_action_handle()) {
    delete configuration_change_.action_handle_;
    clear_has_configuration_change();
  }
}
inline ::Kinova::Api::Base::ActionHandle* ConfigurationChangeNotification::release_action_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConfigurationChangeNotification.action_handle)
  if (has_action_handle()) {
    clear_has_configuration_change();
      ::Kinova::Api::Base::ActionHandle* temp = configuration_change_.action_handle_;
    configuration_change_.action_handle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::ActionHandle& ConfigurationChangeNotification::action_handle() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.action_handle)
  return has_action_handle()
      ? *configuration_change_.action_handle_
      : *reinterpret_cast< ::Kinova::Api::Base::ActionHandle*>(&::Kinova::Api::Base::_ActionHandle_default_instance_);
}
inline ::Kinova::Api::Base::ActionHandle* ConfigurationChangeNotification::mutable_action_handle() {
  if (!has_action_handle()) {
    clear_configuration_change();
    set_has_action_handle();
    configuration_change_.action_handle_ = new ::Kinova::Api::Base::ActionHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotification.action_handle)
  return configuration_change_.action_handle_;
}

// .Kinova.Api.Base.MappingHandle mapping_handle = 6;
inline bool ConfigurationChangeNotification::has_mapping_handle() const {
  return configuration_change_case() == kMappingHandle;
}
inline void ConfigurationChangeNotification::set_has_mapping_handle() {
  _oneof_case_[0] = kMappingHandle;
}
inline void ConfigurationChangeNotification::clear_mapping_handle() {
  if (has_mapping_handle()) {
    delete configuration_change_.mapping_handle_;
    clear_has_configuration_change();
  }
}
inline ::Kinova::Api::Base::MappingHandle* ConfigurationChangeNotification::release_mapping_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConfigurationChangeNotification.mapping_handle)
  if (has_mapping_handle()) {
    clear_has_configuration_change();
      ::Kinova::Api::Base::MappingHandle* temp = configuration_change_.mapping_handle_;
    configuration_change_.mapping_handle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::MappingHandle& ConfigurationChangeNotification::mapping_handle() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.mapping_handle)
  return has_mapping_handle()
      ? *configuration_change_.mapping_handle_
      : *reinterpret_cast< ::Kinova::Api::Base::MappingHandle*>(&::Kinova::Api::Base::_MappingHandle_default_instance_);
}
inline ::Kinova::Api::Base::MappingHandle* ConfigurationChangeNotification::mutable_mapping_handle() {
  if (!has_mapping_handle()) {
    clear_configuration_change();
    set_has_mapping_handle();
    configuration_change_.mapping_handle_ = new ::Kinova::Api::Base::MappingHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotification.mapping_handle)
  return configuration_change_.mapping_handle_;
}

// .Kinova.Api.Base.MapGroupHandle map_group_handle = 7;
inline bool ConfigurationChangeNotification::has_map_group_handle() const {
  return configuration_change_case() == kMapGroupHandle;
}
inline void ConfigurationChangeNotification::set_has_map_group_handle() {
  _oneof_case_[0] = kMapGroupHandle;
}
inline void ConfigurationChangeNotification::clear_map_group_handle() {
  if (has_map_group_handle()) {
    delete configuration_change_.map_group_handle_;
    clear_has_configuration_change();
  }
}
inline ::Kinova::Api::Base::MapGroupHandle* ConfigurationChangeNotification::release_map_group_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConfigurationChangeNotification.map_group_handle)
  if (has_map_group_handle()) {
    clear_has_configuration_change();
      ::Kinova::Api::Base::MapGroupHandle* temp = configuration_change_.map_group_handle_;
    configuration_change_.map_group_handle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::MapGroupHandle& ConfigurationChangeNotification::map_group_handle() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.map_group_handle)
  return has_map_group_handle()
      ? *configuration_change_.map_group_handle_
      : *reinterpret_cast< ::Kinova::Api::Base::MapGroupHandle*>(&::Kinova::Api::Base::_MapGroupHandle_default_instance_);
}
inline ::Kinova::Api::Base::MapGroupHandle* ConfigurationChangeNotification::mutable_map_group_handle() {
  if (!has_map_group_handle()) {
    clear_configuration_change();
    set_has_map_group_handle();
    configuration_change_.map_group_handle_ = new ::Kinova::Api::Base::MapGroupHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotification.map_group_handle)
  return configuration_change_.map_group_handle_;
}

// .Kinova.Api.Base.MapHandle map_handle = 8;
inline bool ConfigurationChangeNotification::has_map_handle() const {
  return configuration_change_case() == kMapHandle;
}
inline void ConfigurationChangeNotification::set_has_map_handle() {
  _oneof_case_[0] = kMapHandle;
}
inline void ConfigurationChangeNotification::clear_map_handle() {
  if (has_map_handle()) {
    delete configuration_change_.map_handle_;
    clear_has_configuration_change();
  }
}
inline ::Kinova::Api::Base::MapHandle* ConfigurationChangeNotification::release_map_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConfigurationChangeNotification.map_handle)
  if (has_map_handle()) {
    clear_has_configuration_change();
      ::Kinova::Api::Base::MapHandle* temp = configuration_change_.map_handle_;
    configuration_change_.map_handle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::MapHandle& ConfigurationChangeNotification::map_handle() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.map_handle)
  return has_map_handle()
      ? *configuration_change_.map_handle_
      : *reinterpret_cast< ::Kinova::Api::Base::MapHandle*>(&::Kinova::Api::Base::_MapHandle_default_instance_);
}
inline ::Kinova::Api::Base::MapHandle* ConfigurationChangeNotification::mutable_map_handle() {
  if (!has_map_handle()) {
    clear_configuration_change();
    set_has_map_handle();
    configuration_change_.map_handle_ = new ::Kinova::Api::Base::MapHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotification.map_handle)
  return configuration_change_.map_handle_;
}

// .Kinova.Api.Common.UserProfileHandle user_profile_handle = 9;
inline bool ConfigurationChangeNotification::has_user_profile_handle() const {
  return configuration_change_case() == kUserProfileHandle;
}
inline void ConfigurationChangeNotification::set_has_user_profile_handle() {
  _oneof_case_[0] = kUserProfileHandle;
}
inline ::Kinova::Api::Common::UserProfileHandle* ConfigurationChangeNotification::release_user_profile_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConfigurationChangeNotification.user_profile_handle)
  if (has_user_profile_handle()) {
    clear_has_configuration_change();
      ::Kinova::Api::Common::UserProfileHandle* temp = configuration_change_.user_profile_handle_;
    configuration_change_.user_profile_handle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Common::UserProfileHandle& ConfigurationChangeNotification::user_profile_handle() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.user_profile_handle)
  return has_user_profile_handle()
      ? *configuration_change_.user_profile_handle_
      : *reinterpret_cast< ::Kinova::Api::Common::UserProfileHandle*>(&::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* ConfigurationChangeNotification::mutable_user_profile_handle() {
  if (!has_user_profile_handle()) {
    clear_configuration_change();
    set_has_user_profile_handle();
    configuration_change_.user_profile_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotification.user_profile_handle)
  return configuration_change_.user_profile_handle_;
}

// .Kinova.Api.Base.ProtectionZoneHandle protection_zone_handle = 10;
inline bool ConfigurationChangeNotification::has_protection_zone_handle() const {
  return configuration_change_case() == kProtectionZoneHandle;
}
inline void ConfigurationChangeNotification::set_has_protection_zone_handle() {
  _oneof_case_[0] = kProtectionZoneHandle;
}
inline void ConfigurationChangeNotification::clear_protection_zone_handle() {
  if (has_protection_zone_handle()) {
    delete configuration_change_.protection_zone_handle_;
    clear_has_configuration_change();
  }
}
inline ::Kinova::Api::Base::ProtectionZoneHandle* ConfigurationChangeNotification::release_protection_zone_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConfigurationChangeNotification.protection_zone_handle)
  if (has_protection_zone_handle()) {
    clear_has_configuration_change();
      ::Kinova::Api::Base::ProtectionZoneHandle* temp = configuration_change_.protection_zone_handle_;
    configuration_change_.protection_zone_handle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::ProtectionZoneHandle& ConfigurationChangeNotification::protection_zone_handle() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.protection_zone_handle)
  return has_protection_zone_handle()
      ? *configuration_change_.protection_zone_handle_
      : *reinterpret_cast< ::Kinova::Api::Base::ProtectionZoneHandle*>(&::Kinova::Api::Base::_ProtectionZoneHandle_default_instance_);
}
inline ::Kinova::Api::Base::ProtectionZoneHandle* ConfigurationChangeNotification::mutable_protection_zone_handle() {
  if (!has_protection_zone_handle()) {
    clear_configuration_change();
    set_has_protection_zone_handle();
    configuration_change_.protection_zone_handle_ = new ::Kinova::Api::Base::ProtectionZoneHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotification.protection_zone_handle)
  return configuration_change_.protection_zone_handle_;
}

// .Kinova.Api.Common.SafetyHandle safety_handle = 11;
inline bool ConfigurationChangeNotification::has_safety_handle() const {
  return configuration_change_case() == kSafetyHandle;
}
inline void ConfigurationChangeNotification::set_has_safety_handle() {
  _oneof_case_[0] = kSafetyHandle;
}
inline ::Kinova::Api::Common::SafetyHandle* ConfigurationChangeNotification::release_safety_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConfigurationChangeNotification.safety_handle)
  if (has_safety_handle()) {
    clear_has_configuration_change();
      ::Kinova::Api::Common::SafetyHandle* temp = configuration_change_.safety_handle_;
    configuration_change_.safety_handle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Common::SafetyHandle& ConfigurationChangeNotification::safety_handle() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.safety_handle)
  return has_safety_handle()
      ? *configuration_change_.safety_handle_
      : *reinterpret_cast< ::Kinova::Api::Common::SafetyHandle*>(&::Kinova::Api::Common::_SafetyHandle_default_instance_);
}
inline ::Kinova::Api::Common::SafetyHandle* ConfigurationChangeNotification::mutable_safety_handle() {
  if (!has_safety_handle()) {
    clear_configuration_change();
    set_has_safety_handle();
    configuration_change_.safety_handle_ = new ::Kinova::Api::Common::SafetyHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotification.safety_handle)
  return configuration_change_.safety_handle_;
}

// .Kinova.Api.Base.NetworkHandle network_handle = 12;
inline bool ConfigurationChangeNotification::has_network_handle() const {
  return configuration_change_case() == kNetworkHandle;
}
inline void ConfigurationChangeNotification::set_has_network_handle() {
  _oneof_case_[0] = kNetworkHandle;
}
inline void ConfigurationChangeNotification::clear_network_handle() {
  if (has_network_handle()) {
    delete configuration_change_.network_handle_;
    clear_has_configuration_change();
  }
}
inline ::Kinova::Api::Base::NetworkHandle* ConfigurationChangeNotification::release_network_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConfigurationChangeNotification.network_handle)
  if (has_network_handle()) {
    clear_has_configuration_change();
      ::Kinova::Api::Base::NetworkHandle* temp = configuration_change_.network_handle_;
    configuration_change_.network_handle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::NetworkHandle& ConfigurationChangeNotification::network_handle() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.network_handle)
  return has_network_handle()
      ? *configuration_change_.network_handle_
      : *reinterpret_cast< ::Kinova::Api::Base::NetworkHandle*>(&::Kinova::Api::Base::_NetworkHandle_default_instance_);
}
inline ::Kinova::Api::Base::NetworkHandle* ConfigurationChangeNotification::mutable_network_handle() {
  if (!has_network_handle()) {
    clear_configuration_change();
    set_has_network_handle();
    configuration_change_.network_handle_ = new ::Kinova::Api::Base::NetworkHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotification.network_handle)
  return configuration_change_.network_handle_;
}

// .Kinova.Api.Base.Ssid ssid = 14;
inline bool ConfigurationChangeNotification::has_ssid() const {
  return configuration_change_case() == kSsid;
}
inline void ConfigurationChangeNotification::set_has_ssid() {
  _oneof_case_[0] = kSsid;
}
inline void ConfigurationChangeNotification::clear_ssid() {
  if (has_ssid()) {
    delete configuration_change_.ssid_;
    clear_has_configuration_change();
  }
}
inline ::Kinova::Api::Base::Ssid* ConfigurationChangeNotification::release_ssid() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConfigurationChangeNotification.ssid)
  if (has_ssid()) {
    clear_has_configuration_change();
      ::Kinova::Api::Base::Ssid* temp = configuration_change_.ssid_;
    configuration_change_.ssid_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::Ssid& ConfigurationChangeNotification::ssid() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.ssid)
  return has_ssid()
      ? *configuration_change_.ssid_
      : *reinterpret_cast< ::Kinova::Api::Base::Ssid*>(&::Kinova::Api::Base::_Ssid_default_instance_);
}
inline ::Kinova::Api::Base::Ssid* ConfigurationChangeNotification::mutable_ssid() {
  if (!has_ssid()) {
    clear_configuration_change();
    set_has_ssid();
    configuration_change_.ssid_ = new ::Kinova::Api::Base::Ssid;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotification.ssid)
  return configuration_change_.ssid_;
}

// .Kinova.Api.Base.ControllerHandle controller_handle = 16;
inline bool ConfigurationChangeNotification::has_controller_handle() const {
  return configuration_change_case() == kControllerHandle;
}
inline void ConfigurationChangeNotification::set_has_controller_handle() {
  _oneof_case_[0] = kControllerHandle;
}
inline void ConfigurationChangeNotification::clear_controller_handle() {
  if (has_controller_handle()) {
    delete configuration_change_.controller_handle_;
    clear_has_configuration_change();
  }
}
inline ::Kinova::Api::Base::ControllerHandle* ConfigurationChangeNotification::release_controller_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConfigurationChangeNotification.controller_handle)
  if (has_controller_handle()) {
    clear_has_configuration_change();
      ::Kinova::Api::Base::ControllerHandle* temp = configuration_change_.controller_handle_;
    configuration_change_.controller_handle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::ControllerHandle& ConfigurationChangeNotification::controller_handle() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.controller_handle)
  return has_controller_handle()
      ? *configuration_change_.controller_handle_
      : *reinterpret_cast< ::Kinova::Api::Base::ControllerHandle*>(&::Kinova::Api::Base::_ControllerHandle_default_instance_);
}
inline ::Kinova::Api::Base::ControllerHandle* ConfigurationChangeNotification::mutable_controller_handle() {
  if (!has_controller_handle()) {
    clear_configuration_change();
    set_has_controller_handle();
    configuration_change_.controller_handle_ = new ::Kinova::Api::Base::ControllerHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotification.controller_handle)
  return configuration_change_.controller_handle_;
}

// .Kinova.Api.Common.Connection connection = 15;
inline bool ConfigurationChangeNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& ConfigurationChangeNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* ConfigurationChangeNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConfigurationChangeNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* ConfigurationChangeNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotification.connection)
  return connection_;
}
inline void ConfigurationChangeNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ConfigurationChangeNotification.connection)
}

inline bool ConfigurationChangeNotification::has_configuration_change() const {
  return configuration_change_case() != CONFIGURATION_CHANGE_NOT_SET;
}
inline void ConfigurationChangeNotification::clear_has_configuration_change() {
  _oneof_case_[0] = CONFIGURATION_CHANGE_NOT_SET;
}
inline ConfigurationChangeNotification::ConfigurationChangeCase ConfigurationChangeNotification::configuration_change_case() const {
  return ConfigurationChangeNotification::ConfigurationChangeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MappingInfoNotification

// uint32 controller_identifier = 1;
inline void MappingInfoNotification::clear_controller_identifier() {
  controller_identifier_ = 0u;
}
inline ::google::protobuf::uint32 MappingInfoNotification::controller_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MappingInfoNotification.controller_identifier)
  return controller_identifier_;
}
inline void MappingInfoNotification::set_controller_identifier(::google::protobuf::uint32 value) {
  
  controller_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.MappingInfoNotification.controller_identifier)
}

// .Kinova.Api.Base.MapHandle active_map_handle = 2;
inline bool MappingInfoNotification::has_active_map_handle() const {
  return this != internal_default_instance() && active_map_handle_ != NULL;
}
inline void MappingInfoNotification::clear_active_map_handle() {
  if (GetArenaNoVirtual() == NULL && active_map_handle_ != NULL) {
    delete active_map_handle_;
  }
  active_map_handle_ = NULL;
}
inline const ::Kinova::Api::Base::MapHandle& MappingInfoNotification::active_map_handle() const {
  const ::Kinova::Api::Base::MapHandle* p = active_map_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MappingInfoNotification.active_map_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MapHandle*>(
      &::Kinova::Api::Base::_MapHandle_default_instance_);
}
inline ::Kinova::Api::Base::MapHandle* MappingInfoNotification::release_active_map_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MappingInfoNotification.active_map_handle)
  
  ::Kinova::Api::Base::MapHandle* temp = active_map_handle_;
  active_map_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MapHandle* MappingInfoNotification::mutable_active_map_handle() {
  
  if (active_map_handle_ == NULL) {
    active_map_handle_ = new ::Kinova::Api::Base::MapHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MappingInfoNotification.active_map_handle)
  return active_map_handle_;
}
inline void MappingInfoNotification::set_allocated_active_map_handle(::Kinova::Api::Base::MapHandle* active_map_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete active_map_handle_;
  }
  if (active_map_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      active_map_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, active_map_handle, submessage_arena);
    }
    
  } else {
    
  }
  active_map_handle_ = active_map_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.MappingInfoNotification.active_map_handle)
}

// .Kinova.Api.Common.Timestamp timestamp = 3;
inline bool MappingInfoNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& MappingInfoNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MappingInfoNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* MappingInfoNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MappingInfoNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* MappingInfoNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MappingInfoNotification.timestamp)
  return timestamp_;
}
inline void MappingInfoNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.MappingInfoNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 4;
inline bool MappingInfoNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& MappingInfoNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MappingInfoNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* MappingInfoNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MappingInfoNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* MappingInfoNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MappingInfoNotification.user_handle)
  return user_handle_;
}
inline void MappingInfoNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.MappingInfoNotification.user_handle)
}

// .Kinova.Api.Common.Connection connection = 5;
inline bool MappingInfoNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& MappingInfoNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MappingInfoNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* MappingInfoNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MappingInfoNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* MappingInfoNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MappingInfoNotification.connection)
  return connection_;
}
inline void MappingInfoNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.MappingInfoNotification.connection)
}

// .Kinova.Api.Base.MappingHandle mapping_handle = 6;
inline bool MappingInfoNotification::has_mapping_handle() const {
  return this != internal_default_instance() && mapping_handle_ != NULL;
}
inline void MappingInfoNotification::clear_mapping_handle() {
  if (GetArenaNoVirtual() == NULL && mapping_handle_ != NULL) {
    delete mapping_handle_;
  }
  mapping_handle_ = NULL;
}
inline const ::Kinova::Api::Base::MappingHandle& MappingInfoNotification::mapping_handle() const {
  const ::Kinova::Api::Base::MappingHandle* p = mapping_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MappingInfoNotification.mapping_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MappingHandle*>(
      &::Kinova::Api::Base::_MappingHandle_default_instance_);
}
inline ::Kinova::Api::Base::MappingHandle* MappingInfoNotification::release_mapping_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MappingInfoNotification.mapping_handle)
  
  ::Kinova::Api::Base::MappingHandle* temp = mapping_handle_;
  mapping_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MappingHandle* MappingInfoNotification::mutable_mapping_handle() {
  
  if (mapping_handle_ == NULL) {
    mapping_handle_ = new ::Kinova::Api::Base::MappingHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MappingInfoNotification.mapping_handle)
  return mapping_handle_;
}
inline void MappingInfoNotification::set_allocated_mapping_handle(::Kinova::Api::Base::MappingHandle* mapping_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mapping_handle_;
  }
  if (mapping_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mapping_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mapping_handle, submessage_arena);
    }
    
  } else {
    
  }
  mapping_handle_ = mapping_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.MappingInfoNotification.mapping_handle)
}

// -------------------------------------------------------------------

// ControlModeInformation

// .Kinova.Api.Base.ControlMode mode = 1;
inline void ControlModeInformation::clear_mode() {
  mode_ = 0;
}
inline ::Kinova::Api::Base::ControlMode ControlModeInformation::mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControlModeInformation.mode)
  return static_cast< ::Kinova::Api::Base::ControlMode >(mode_);
}
inline void ControlModeInformation::set_mode(::Kinova::Api::Base::ControlMode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControlModeInformation.mode)
}

// -------------------------------------------------------------------

// ControlModeNotification

// .Kinova.Api.Base.ControlMode control_mode = 1;
inline void ControlModeNotification::clear_control_mode() {
  control_mode_ = 0;
}
inline ::Kinova::Api::Base::ControlMode ControlModeNotification::control_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControlModeNotification.control_mode)
  return static_cast< ::Kinova::Api::Base::ControlMode >(control_mode_);
}
inline void ControlModeNotification::set_control_mode(::Kinova::Api::Base::ControlMode value) {
  
  control_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControlModeNotification.control_mode)
}

// .Kinova.Api.Common.Timestamp timestamp = 2;
inline bool ControlModeNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& ControlModeNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControlModeNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* ControlModeNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControlModeNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* ControlModeNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControlModeNotification.timestamp)
  return timestamp_;
}
inline void ControlModeNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ControlModeNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 3;
inline bool ControlModeNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& ControlModeNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControlModeNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* ControlModeNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControlModeNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* ControlModeNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControlModeNotification.user_handle)
  return user_handle_;
}
inline void ControlModeNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ControlModeNotification.user_handle)
}

// .Kinova.Api.Common.Connection connection = 4;
inline bool ControlModeNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& ControlModeNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControlModeNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* ControlModeNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControlModeNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* ControlModeNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControlModeNotification.connection)
  return connection_;
}
inline void ControlModeNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ControlModeNotification.connection)
}

// -------------------------------------------------------------------

// ServoingModeInformation

// .Kinova.Api.Base.ServoingMode servoing_mode = 1;
inline void ServoingModeInformation::clear_servoing_mode() {
  servoing_mode_ = 0;
}
inline ::Kinova::Api::Base::ServoingMode ServoingModeInformation::servoing_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ServoingModeInformation.servoing_mode)
  return static_cast< ::Kinova::Api::Base::ServoingMode >(servoing_mode_);
}
inline void ServoingModeInformation::set_servoing_mode(::Kinova::Api::Base::ServoingMode value) {
  
  servoing_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ServoingModeInformation.servoing_mode)
}

// -------------------------------------------------------------------

// OperatingModeInformation

// .Kinova.Api.Base.OperatingMode operating_mode = 1;
inline void OperatingModeInformation::clear_operating_mode() {
  operating_mode_ = 0;
}
inline ::Kinova::Api::Base::OperatingMode OperatingModeInformation::operating_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.OperatingModeInformation.operating_mode)
  return static_cast< ::Kinova::Api::Base::OperatingMode >(operating_mode_);
}
inline void OperatingModeInformation::set_operating_mode(::Kinova::Api::Base::OperatingMode value) {
  
  operating_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.OperatingModeInformation.operating_mode)
}

// .Kinova.Api.Common.DeviceHandle device_handle = 2;
inline bool OperatingModeInformation::has_device_handle() const {
  return this != internal_default_instance() && device_handle_ != NULL;
}
inline const ::Kinova::Api::Common::DeviceHandle& OperatingModeInformation::device_handle() const {
  const ::Kinova::Api::Common::DeviceHandle* p = device_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.OperatingModeInformation.device_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::DeviceHandle*>(
      &::Kinova::Api::Common::_DeviceHandle_default_instance_);
}
inline ::Kinova::Api::Common::DeviceHandle* OperatingModeInformation::release_device_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.OperatingModeInformation.device_handle)
  
  ::Kinova::Api::Common::DeviceHandle* temp = device_handle_;
  device_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::DeviceHandle* OperatingModeInformation::mutable_device_handle() {
  
  if (device_handle_ == NULL) {
    device_handle_ = new ::Kinova::Api::Common::DeviceHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.OperatingModeInformation.device_handle)
  return device_handle_;
}
inline void OperatingModeInformation::set_allocated_device_handle(::Kinova::Api::Common::DeviceHandle* device_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(device_handle_);
  }
  if (device_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      device_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device_handle, submessage_arena);
    }
    
  } else {
    
  }
  device_handle_ = device_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.OperatingModeInformation.device_handle)
}

// -------------------------------------------------------------------

// OperatingModeNotification

// .Kinova.Api.Base.OperatingMode operating_mode = 1;
inline void OperatingModeNotification::clear_operating_mode() {
  operating_mode_ = 0;
}
inline ::Kinova::Api::Base::OperatingMode OperatingModeNotification::operating_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.OperatingModeNotification.operating_mode)
  return static_cast< ::Kinova::Api::Base::OperatingMode >(operating_mode_);
}
inline void OperatingModeNotification::set_operating_mode(::Kinova::Api::Base::OperatingMode value) {
  
  operating_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.OperatingModeNotification.operating_mode)
}

// .Kinova.Api.Common.Timestamp timestamp = 2;
inline bool OperatingModeNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& OperatingModeNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.OperatingModeNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* OperatingModeNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.OperatingModeNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* OperatingModeNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.OperatingModeNotification.timestamp)
  return timestamp_;
}
inline void OperatingModeNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.OperatingModeNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 3;
inline bool OperatingModeNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& OperatingModeNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.OperatingModeNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* OperatingModeNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.OperatingModeNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* OperatingModeNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.OperatingModeNotification.user_handle)
  return user_handle_;
}
inline void OperatingModeNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.OperatingModeNotification.user_handle)
}

// .Kinova.Api.Common.Connection connection = 4;
inline bool OperatingModeNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& OperatingModeNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.OperatingModeNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* OperatingModeNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.OperatingModeNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* OperatingModeNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.OperatingModeNotification.connection)
  return connection_;
}
inline void OperatingModeNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.OperatingModeNotification.connection)
}

// .Kinova.Api.Common.DeviceHandle device_handle = 5;
inline bool OperatingModeNotification::has_device_handle() const {
  return this != internal_default_instance() && device_handle_ != NULL;
}
inline const ::Kinova::Api::Common::DeviceHandle& OperatingModeNotification::device_handle() const {
  const ::Kinova::Api::Common::DeviceHandle* p = device_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.OperatingModeNotification.device_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::DeviceHandle*>(
      &::Kinova::Api::Common::_DeviceHandle_default_instance_);
}
inline ::Kinova::Api::Common::DeviceHandle* OperatingModeNotification::release_device_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.OperatingModeNotification.device_handle)
  
  ::Kinova::Api::Common::DeviceHandle* temp = device_handle_;
  device_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::DeviceHandle* OperatingModeNotification::mutable_device_handle() {
  
  if (device_handle_ == NULL) {
    device_handle_ = new ::Kinova::Api::Common::DeviceHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.OperatingModeNotification.device_handle)
  return device_handle_;
}
inline void OperatingModeNotification::set_allocated_device_handle(::Kinova::Api::Common::DeviceHandle* device_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(device_handle_);
  }
  if (device_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      device_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device_handle, submessage_arena);
    }
    
  } else {
    
  }
  device_handle_ = device_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.OperatingModeNotification.device_handle)
}

// -------------------------------------------------------------------

// ServoingModeNotification

// .Kinova.Api.Base.ServoingMode servoing_mode = 1;
inline void ServoingModeNotification::clear_servoing_mode() {
  servoing_mode_ = 0;
}
inline ::Kinova::Api::Base::ServoingMode ServoingModeNotification::servoing_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ServoingModeNotification.servoing_mode)
  return static_cast< ::Kinova::Api::Base::ServoingMode >(servoing_mode_);
}
inline void ServoingModeNotification::set_servoing_mode(::Kinova::Api::Base::ServoingMode value) {
  
  servoing_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ServoingModeNotification.servoing_mode)
}

// .Kinova.Api.Common.Timestamp timestamp = 2;
inline bool ServoingModeNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& ServoingModeNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ServoingModeNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* ServoingModeNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ServoingModeNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* ServoingModeNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ServoingModeNotification.timestamp)
  return timestamp_;
}
inline void ServoingModeNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ServoingModeNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 3;
inline bool ServoingModeNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& ServoingModeNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ServoingModeNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* ServoingModeNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ServoingModeNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* ServoingModeNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ServoingModeNotification.user_handle)
  return user_handle_;
}
inline void ServoingModeNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ServoingModeNotification.user_handle)
}

// .Kinova.Api.Common.Connection connection = 4;
inline bool ServoingModeNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& ServoingModeNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ServoingModeNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* ServoingModeNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ServoingModeNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* ServoingModeNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ServoingModeNotification.connection)
  return connection_;
}
inline void ServoingModeNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ServoingModeNotification.connection)
}

// -------------------------------------------------------------------

// SequenceInfoNotification

// .Kinova.Api.Base.EventIdSequenceInfoNotification event_identifier = 1;
inline void SequenceInfoNotification::clear_event_identifier() {
  event_identifier_ = 0;
}
inline ::Kinova::Api::Base::EventIdSequenceInfoNotification SequenceInfoNotification::event_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceInfoNotification.event_identifier)
  return static_cast< ::Kinova::Api::Base::EventIdSequenceInfoNotification >(event_identifier_);
}
inline void SequenceInfoNotification::set_event_identifier(::Kinova::Api::Base::EventIdSequenceInfoNotification value) {
  
  event_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceInfoNotification.event_identifier)
}

// .Kinova.Api.Base.SequenceHandle sequence_handle = 2;
inline bool SequenceInfoNotification::has_sequence_handle() const {
  return this != internal_default_instance() && sequence_handle_ != NULL;
}
inline void SequenceInfoNotification::clear_sequence_handle() {
  if (GetArenaNoVirtual() == NULL && sequence_handle_ != NULL) {
    delete sequence_handle_;
  }
  sequence_handle_ = NULL;
}
inline const ::Kinova::Api::Base::SequenceHandle& SequenceInfoNotification::sequence_handle() const {
  const ::Kinova::Api::Base::SequenceHandle* p = sequence_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceInfoNotification.sequence_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::SequenceHandle*>(
      &::Kinova::Api::Base::_SequenceHandle_default_instance_);
}
inline ::Kinova::Api::Base::SequenceHandle* SequenceInfoNotification::release_sequence_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.SequenceInfoNotification.sequence_handle)
  
  ::Kinova::Api::Base::SequenceHandle* temp = sequence_handle_;
  sequence_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::SequenceHandle* SequenceInfoNotification::mutable_sequence_handle() {
  
  if (sequence_handle_ == NULL) {
    sequence_handle_ = new ::Kinova::Api::Base::SequenceHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceInfoNotification.sequence_handle)
  return sequence_handle_;
}
inline void SequenceInfoNotification::set_allocated_sequence_handle(::Kinova::Api::Base::SequenceHandle* sequence_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sequence_handle_;
  }
  if (sequence_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sequence_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sequence_handle, submessage_arena);
    }
    
  } else {
    
  }
  sequence_handle_ = sequence_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.SequenceInfoNotification.sequence_handle)
}

// uint32 task_index = 3;
inline void SequenceInfoNotification::clear_task_index() {
  task_index_ = 0u;
}
inline ::google::protobuf::uint32 SequenceInfoNotification::task_index() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceInfoNotification.task_index)
  return task_index_;
}
inline void SequenceInfoNotification::set_task_index(::google::protobuf::uint32 value) {
  
  task_index_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceInfoNotification.task_index)
}

// uint32 group_identifier = 4;
inline void SequenceInfoNotification::clear_group_identifier() {
  group_identifier_ = 0u;
}
inline ::google::protobuf::uint32 SequenceInfoNotification::group_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceInfoNotification.group_identifier)
  return group_identifier_;
}
inline void SequenceInfoNotification::set_group_identifier(::google::protobuf::uint32 value) {
  
  group_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceInfoNotification.group_identifier)
}

// .Kinova.Api.Common.Timestamp timestamp = 5;
inline bool SequenceInfoNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& SequenceInfoNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceInfoNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* SequenceInfoNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.SequenceInfoNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* SequenceInfoNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceInfoNotification.timestamp)
  return timestamp_;
}
inline void SequenceInfoNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.SequenceInfoNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 6;
inline bool SequenceInfoNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& SequenceInfoNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceInfoNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* SequenceInfoNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.SequenceInfoNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* SequenceInfoNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceInfoNotification.user_handle)
  return user_handle_;
}
inline void SequenceInfoNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.SequenceInfoNotification.user_handle)
}

// .Kinova.Api.SubErrorCodes abort_details = 7;
inline void SequenceInfoNotification::clear_abort_details() {
  abort_details_ = 0;
}
inline ::Kinova::Api::SubErrorCodes SequenceInfoNotification::abort_details() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceInfoNotification.abort_details)
  return static_cast< ::Kinova::Api::SubErrorCodes >(abort_details_);
}
inline void SequenceInfoNotification::set_abort_details(::Kinova::Api::SubErrorCodes value) {
  
  abort_details_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceInfoNotification.abort_details)
}

// .Kinova.Api.Common.Connection connection = 8;
inline bool SequenceInfoNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& SequenceInfoNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceInfoNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* SequenceInfoNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.SequenceInfoNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* SequenceInfoNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceInfoNotification.connection)
  return connection_;
}
inline void SequenceInfoNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.SequenceInfoNotification.connection)
}

// -------------------------------------------------------------------

// SequenceInformation

// .Kinova.Api.Base.EventIdSequenceInfoNotification event_identifier = 1;
inline void SequenceInformation::clear_event_identifier() {
  event_identifier_ = 0;
}
inline ::Kinova::Api::Base::EventIdSequenceInfoNotification SequenceInformation::event_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceInformation.event_identifier)
  return static_cast< ::Kinova::Api::Base::EventIdSequenceInfoNotification >(event_identifier_);
}
inline void SequenceInformation::set_event_identifier(::Kinova::Api::Base::EventIdSequenceInfoNotification value) {
  
  event_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceInformation.event_identifier)
}

// uint32 task_index = 2;
inline void SequenceInformation::clear_task_index() {
  task_index_ = 0u;
}
inline ::google::protobuf::uint32 SequenceInformation::task_index() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceInformation.task_index)
  return task_index_;
}
inline void SequenceInformation::set_task_index(::google::protobuf::uint32 value) {
  
  task_index_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceInformation.task_index)
}

// uint32 task_identifier = 3;
inline void SequenceInformation::clear_task_identifier() {
  task_identifier_ = 0u;
}
inline ::google::protobuf::uint32 SequenceInformation::task_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceInformation.task_identifier)
  return task_identifier_;
}
inline void SequenceInformation::set_task_identifier(::google::protobuf::uint32 value) {
  
  task_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SequenceInformation.task_identifier)
}

// -------------------------------------------------------------------

// ProtectionZoneNotification

// .Kinova.Api.Base.ProtectionZoneEvent event = 1;
inline void ProtectionZoneNotification::clear_event() {
  event_ = 0;
}
inline ::Kinova::Api::Base::ProtectionZoneEvent ProtectionZoneNotification::event() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZoneNotification.event)
  return static_cast< ::Kinova::Api::Base::ProtectionZoneEvent >(event_);
}
inline void ProtectionZoneNotification::set_event(::Kinova::Api::Base::ProtectionZoneEvent value) {
  
  event_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ProtectionZoneNotification.event)
}

// .Kinova.Api.Base.ProtectionZoneHandle handle = 2;
inline bool ProtectionZoneNotification::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline void ProtectionZoneNotification::clear_handle() {
  if (GetArenaNoVirtual() == NULL && handle_ != NULL) {
    delete handle_;
  }
  handle_ = NULL;
}
inline const ::Kinova::Api::Base::ProtectionZoneHandle& ProtectionZoneNotification::handle() const {
  const ::Kinova::Api::Base::ProtectionZoneHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZoneNotification.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::ProtectionZoneHandle*>(
      &::Kinova::Api::Base::_ProtectionZoneHandle_default_instance_);
}
inline ::Kinova::Api::Base::ProtectionZoneHandle* ProtectionZoneNotification::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ProtectionZoneNotification.handle)
  
  ::Kinova::Api::Base::ProtectionZoneHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::ProtectionZoneHandle* ProtectionZoneNotification::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Base::ProtectionZoneHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ProtectionZoneNotification.handle)
  return handle_;
}
inline void ProtectionZoneNotification::set_allocated_handle(::Kinova::Api::Base::ProtectionZoneHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handle_;
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ProtectionZoneNotification.handle)
}

// .Kinova.Api.Common.Timestamp timestamp = 3;
inline bool ProtectionZoneNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& ProtectionZoneNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZoneNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* ProtectionZoneNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ProtectionZoneNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* ProtectionZoneNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ProtectionZoneNotification.timestamp)
  return timestamp_;
}
inline void ProtectionZoneNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ProtectionZoneNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 4;
inline bool ProtectionZoneNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& ProtectionZoneNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZoneNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* ProtectionZoneNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ProtectionZoneNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* ProtectionZoneNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ProtectionZoneNotification.user_handle)
  return user_handle_;
}
inline void ProtectionZoneNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ProtectionZoneNotification.user_handle)
}

// .Kinova.Api.Common.Connection connection = 5;
inline bool ProtectionZoneNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& ProtectionZoneNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZoneNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* ProtectionZoneNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ProtectionZoneNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* ProtectionZoneNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ProtectionZoneNotification.connection)
  return connection_;
}
inline void ProtectionZoneNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ProtectionZoneNotification.connection)
}

// -------------------------------------------------------------------

// ProtectionZoneInformation

// .Kinova.Api.Base.ProtectionZoneEvent event = 1;
inline void ProtectionZoneInformation::clear_event() {
  event_ = 0;
}
inline ::Kinova::Api::Base::ProtectionZoneEvent ProtectionZoneInformation::event() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZoneInformation.event)
  return static_cast< ::Kinova::Api::Base::ProtectionZoneEvent >(event_);
}
inline void ProtectionZoneInformation::set_event(::Kinova::Api::Base::ProtectionZoneEvent value) {
  
  event_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ProtectionZoneInformation.event)
}

// -------------------------------------------------------------------

// UserNotification

// .Kinova.Api.Base.UserEvent user_event = 1;
inline void UserNotification::clear_user_event() {
  user_event_ = 0;
}
inline ::Kinova::Api::Base::UserEvent UserNotification::user_event() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.UserNotification.user_event)
  return static_cast< ::Kinova::Api::Base::UserEvent >(user_event_);
}
inline void UserNotification::set_user_event(::Kinova::Api::Base::UserEvent value) {
  
  user_event_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.UserNotification.user_event)
}

// .Kinova.Api.Common.UserProfileHandle modified_user = 2;
inline bool UserNotification::has_modified_user() const {
  return this != internal_default_instance() && modified_user_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& UserNotification::modified_user() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = modified_user_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.UserNotification.modified_user)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* UserNotification::release_modified_user() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.UserNotification.modified_user)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = modified_user_;
  modified_user_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* UserNotification::mutable_modified_user() {
  
  if (modified_user_ == NULL) {
    modified_user_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.UserNotification.modified_user)
  return modified_user_;
}
inline void UserNotification::set_allocated_modified_user(::Kinova::Api::Common::UserProfileHandle* modified_user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(modified_user_);
  }
  if (modified_user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      modified_user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, modified_user, submessage_arena);
    }
    
  } else {
    
  }
  modified_user_ = modified_user;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.UserNotification.modified_user)
}

// .Kinova.Api.Common.Timestamp timestamp = 3;
inline bool UserNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& UserNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.UserNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* UserNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.UserNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* UserNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.UserNotification.timestamp)
  return timestamp_;
}
inline void UserNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.UserNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 4;
inline bool UserNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& UserNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.UserNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* UserNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.UserNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* UserNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.UserNotification.user_handle)
  return user_handle_;
}
inline void UserNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.UserNotification.user_handle)
}

// .Kinova.Api.Common.Connection connection = 5;
inline bool UserNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& UserNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.UserNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* UserNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.UserNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* UserNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.UserNotification.connection)
  return connection_;
}
inline void UserNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.UserNotification.connection)
}

// -------------------------------------------------------------------

// ControllerHandle

// .Kinova.Api.Base.ControllerType type = 1;
inline void ControllerHandle::clear_type() {
  type_ = 0;
}
inline ::Kinova::Api::Base::ControllerType ControllerHandle::type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerHandle.type)
  return static_cast< ::Kinova::Api::Base::ControllerType >(type_);
}
inline void ControllerHandle::set_type(::Kinova::Api::Base::ControllerType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControllerHandle.type)
}

// uint32 controller_identifier = 2;
inline void ControllerHandle::clear_controller_identifier() {
  controller_identifier_ = 0u;
}
inline ::google::protobuf::uint32 ControllerHandle::controller_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerHandle.controller_identifier)
  return controller_identifier_;
}
inline void ControllerHandle::set_controller_identifier(::google::protobuf::uint32 value) {
  
  controller_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControllerHandle.controller_identifier)
}

// -------------------------------------------------------------------

// ControllerElementHandle

// .Kinova.Api.Base.ControllerHandle controller_handle = 1;
inline bool ControllerElementHandle::has_controller_handle() const {
  return this != internal_default_instance() && controller_handle_ != NULL;
}
inline void ControllerElementHandle::clear_controller_handle() {
  if (GetArenaNoVirtual() == NULL && controller_handle_ != NULL) {
    delete controller_handle_;
  }
  controller_handle_ = NULL;
}
inline const ::Kinova::Api::Base::ControllerHandle& ControllerElementHandle::controller_handle() const {
  const ::Kinova::Api::Base::ControllerHandle* p = controller_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerElementHandle.controller_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::ControllerHandle*>(
      &::Kinova::Api::Base::_ControllerHandle_default_instance_);
}
inline ::Kinova::Api::Base::ControllerHandle* ControllerElementHandle::release_controller_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControllerElementHandle.controller_handle)
  
  ::Kinova::Api::Base::ControllerHandle* temp = controller_handle_;
  controller_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::ControllerHandle* ControllerElementHandle::mutable_controller_handle() {
  
  if (controller_handle_ == NULL) {
    controller_handle_ = new ::Kinova::Api::Base::ControllerHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerElementHandle.controller_handle)
  return controller_handle_;
}
inline void ControllerElementHandle::set_allocated_controller_handle(::Kinova::Api::Base::ControllerHandle* controller_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete controller_handle_;
  }
  if (controller_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      controller_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controller_handle, submessage_arena);
    }
    
  } else {
    
  }
  controller_handle_ = controller_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ControllerElementHandle.controller_handle)
}

// uint32 button = 2;
inline bool ControllerElementHandle::has_button() const {
  return identifier_case() == kButton;
}
inline void ControllerElementHandle::set_has_button() {
  _oneof_case_[0] = kButton;
}
inline void ControllerElementHandle::clear_button() {
  if (has_button()) {
    identifier_.button_ = 0u;
    clear_has_identifier();
  }
}
inline ::google::protobuf::uint32 ControllerElementHandle::button() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerElementHandle.button)
  if (has_button()) {
    return identifier_.button_;
  }
  return 0u;
}
inline void ControllerElementHandle::set_button(::google::protobuf::uint32 value) {
  if (!has_button()) {
    clear_identifier();
    set_has_button();
  }
  identifier_.button_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControllerElementHandle.button)
}

// uint32 axis = 3;
inline bool ControllerElementHandle::has_axis() const {
  return identifier_case() == kAxis;
}
inline void ControllerElementHandle::set_has_axis() {
  _oneof_case_[0] = kAxis;
}
inline void ControllerElementHandle::clear_axis() {
  if (has_axis()) {
    identifier_.axis_ = 0u;
    clear_has_identifier();
  }
}
inline ::google::protobuf::uint32 ControllerElementHandle::axis() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerElementHandle.axis)
  if (has_axis()) {
    return identifier_.axis_;
  }
  return 0u;
}
inline void ControllerElementHandle::set_axis(::google::protobuf::uint32 value) {
  if (!has_axis()) {
    clear_identifier();
    set_has_axis();
  }
  identifier_.axis_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControllerElementHandle.axis)
}

inline bool ControllerElementHandle::has_identifier() const {
  return identifier_case() != IDENTIFIER_NOT_SET;
}
inline void ControllerElementHandle::clear_has_identifier() {
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}
inline ControllerElementHandle::IdentifierCase ControllerElementHandle::identifier_case() const {
  return ControllerElementHandle::IdentifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ControllerNotification

// .Kinova.Api.Base.ControllerState controller_state = 1;
inline bool ControllerNotification::has_controller_state() const {
  return state_case() == kControllerState;
}
inline void ControllerNotification::set_has_controller_state() {
  _oneof_case_[0] = kControllerState;
}
inline void ControllerNotification::clear_controller_state() {
  if (has_controller_state()) {
    delete state_.controller_state_;
    clear_has_state();
  }
}
inline ::Kinova::Api::Base::ControllerState* ControllerNotification::release_controller_state() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControllerNotification.controller_state)
  if (has_controller_state()) {
    clear_has_state();
      ::Kinova::Api::Base::ControllerState* temp = state_.controller_state_;
    state_.controller_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::ControllerState& ControllerNotification::controller_state() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerNotification.controller_state)
  return has_controller_state()
      ? *state_.controller_state_
      : *reinterpret_cast< ::Kinova::Api::Base::ControllerState*>(&::Kinova::Api::Base::_ControllerState_default_instance_);
}
inline ::Kinova::Api::Base::ControllerState* ControllerNotification::mutable_controller_state() {
  if (!has_controller_state()) {
    clear_state();
    set_has_controller_state();
    state_.controller_state_ = new ::Kinova::Api::Base::ControllerState;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerNotification.controller_state)
  return state_.controller_state_;
}

// .Kinova.Api.Base.ControllerElementState controller_element = 2;
inline bool ControllerNotification::has_controller_element() const {
  return state_case() == kControllerElement;
}
inline void ControllerNotification::set_has_controller_element() {
  _oneof_case_[0] = kControllerElement;
}
inline void ControllerNotification::clear_controller_element() {
  if (has_controller_element()) {
    delete state_.controller_element_;
    clear_has_state();
  }
}
inline ::Kinova::Api::Base::ControllerElementState* ControllerNotification::release_controller_element() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControllerNotification.controller_element)
  if (has_controller_element()) {
    clear_has_state();
      ::Kinova::Api::Base::ControllerElementState* temp = state_.controller_element_;
    state_.controller_element_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::ControllerElementState& ControllerNotification::controller_element() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerNotification.controller_element)
  return has_controller_element()
      ? *state_.controller_element_
      : *reinterpret_cast< ::Kinova::Api::Base::ControllerElementState*>(&::Kinova::Api::Base::_ControllerElementState_default_instance_);
}
inline ::Kinova::Api::Base::ControllerElementState* ControllerNotification::mutable_controller_element() {
  if (!has_controller_element()) {
    clear_state();
    set_has_controller_element();
    state_.controller_element_ = new ::Kinova::Api::Base::ControllerElementState;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerNotification.controller_element)
  return state_.controller_element_;
}

// .Kinova.Api.Common.Timestamp timestamp = 3;
inline bool ControllerNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& ControllerNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* ControllerNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControllerNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* ControllerNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerNotification.timestamp)
  return timestamp_;
}
inline void ControllerNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ControllerNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 4;
inline bool ControllerNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& ControllerNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* ControllerNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControllerNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* ControllerNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerNotification.user_handle)
  return user_handle_;
}
inline void ControllerNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ControllerNotification.user_handle)
}

// .Kinova.Api.Common.Connection connection = 5;
inline bool ControllerNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& ControllerNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* ControllerNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControllerNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* ControllerNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerNotification.connection)
  return connection_;
}
inline void ControllerNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ControllerNotification.connection)
}

inline bool ControllerNotification::has_state() const {
  return state_case() != STATE_NOT_SET;
}
inline void ControllerNotification::clear_has_state() {
  _oneof_case_[0] = STATE_NOT_SET;
}
inline ControllerNotification::StateCase ControllerNotification::state_case() const {
  return ControllerNotification::StateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ControllerList

// repeated .Kinova.Api.Base.ControllerHandle handles = 1;
inline int ControllerList::handles_size() const {
  return handles_.size();
}
inline void ControllerList::clear_handles() {
  handles_.Clear();
}
inline const ::Kinova::Api::Base::ControllerHandle& ControllerList::handles(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerList.handles)
  return handles_.Get(index);
}
inline ::Kinova::Api::Base::ControllerHandle* ControllerList::mutable_handles(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerList.handles)
  return handles_.Mutable(index);
}
inline ::Kinova::Api::Base::ControllerHandle* ControllerList::add_handles() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.ControllerList.handles)
  return handles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerHandle >*
ControllerList::mutable_handles() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.ControllerList.handles)
  return &handles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerHandle >&
ControllerList::handles() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.ControllerList.handles)
  return handles_;
}

// -------------------------------------------------------------------

// ControllerState

// .Kinova.Api.Base.ControllerHandle handle = 1;
inline bool ControllerState::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline void ControllerState::clear_handle() {
  if (GetArenaNoVirtual() == NULL && handle_ != NULL) {
    delete handle_;
  }
  handle_ = NULL;
}
inline const ::Kinova::Api::Base::ControllerHandle& ControllerState::handle() const {
  const ::Kinova::Api::Base::ControllerHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerState.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::ControllerHandle*>(
      &::Kinova::Api::Base::_ControllerHandle_default_instance_);
}
inline ::Kinova::Api::Base::ControllerHandle* ControllerState::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControllerState.handle)
  
  ::Kinova::Api::Base::ControllerHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::ControllerHandle* ControllerState::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Base::ControllerHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerState.handle)
  return handle_;
}
inline void ControllerState::set_allocated_handle(::Kinova::Api::Base::ControllerHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handle_;
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ControllerState.handle)
}

// .Kinova.Api.Base.ControllerEventType event_type = 2;
inline void ControllerState::clear_event_type() {
  event_type_ = 0;
}
inline ::Kinova::Api::Base::ControllerEventType ControllerState::event_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerState.event_type)
  return static_cast< ::Kinova::Api::Base::ControllerEventType >(event_type_);
}
inline void ControllerState::set_event_type(::Kinova::Api::Base::ControllerEventType value) {
  
  event_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControllerState.event_type)
}

// -------------------------------------------------------------------

// ControllerElementState

// .Kinova.Api.Base.ControllerElementHandle handle = 1;
inline bool ControllerElementState::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline void ControllerElementState::clear_handle() {
  if (GetArenaNoVirtual() == NULL && handle_ != NULL) {
    delete handle_;
  }
  handle_ = NULL;
}
inline const ::Kinova::Api::Base::ControllerElementHandle& ControllerElementState::handle() const {
  const ::Kinova::Api::Base::ControllerElementHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerElementState.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::ControllerElementHandle*>(
      &::Kinova::Api::Base::_ControllerElementHandle_default_instance_);
}
inline ::Kinova::Api::Base::ControllerElementHandle* ControllerElementState::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControllerElementState.handle)
  
  ::Kinova::Api::Base::ControllerElementHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::ControllerElementHandle* ControllerElementState::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Base::ControllerElementHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerElementState.handle)
  return handle_;
}
inline void ControllerElementState::set_allocated_handle(::Kinova::Api::Base::ControllerElementHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handle_;
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ControllerElementState.handle)
}

// .Kinova.Api.Base.ControllerElementEventType event_type = 2;
inline void ControllerElementState::clear_event_type() {
  event_type_ = 0;
}
inline ::Kinova::Api::Base::ControllerElementEventType ControllerElementState::event_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerElementState.event_type)
  return static_cast< ::Kinova::Api::Base::ControllerElementEventType >(event_type_);
}
inline void ControllerElementState::set_event_type(::Kinova::Api::Base::ControllerElementEventType value) {
  
  event_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControllerElementState.event_type)
}

// float axis_value = 3;
inline void ControllerElementState::clear_axis_value() {
  axis_value_ = 0;
}
inline float ControllerElementState::axis_value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerElementState.axis_value)
  return axis_value_;
}
inline void ControllerElementState::set_axis_value(float value) {
  
  axis_value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControllerElementState.axis_value)
}

// -------------------------------------------------------------------

// ActionNotification

// .Kinova.Api.Base.ActionEvent action_event = 1;
inline void ActionNotification::clear_action_event() {
  action_event_ = 0;
}
inline ::Kinova::Api::Base::ActionEvent ActionNotification::action_event() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActionNotification.action_event)
  return static_cast< ::Kinova::Api::Base::ActionEvent >(action_event_);
}
inline void ActionNotification::set_action_event(::Kinova::Api::Base::ActionEvent value) {
  
  action_event_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ActionNotification.action_event)
}

// .Kinova.Api.Base.ActionHandle handle = 2;
inline bool ActionNotification::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline void ActionNotification::clear_handle() {
  if (GetArenaNoVirtual() == NULL && handle_ != NULL) {
    delete handle_;
  }
  handle_ = NULL;
}
inline const ::Kinova::Api::Base::ActionHandle& ActionNotification::handle() const {
  const ::Kinova::Api::Base::ActionHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActionNotification.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::ActionHandle*>(
      &::Kinova::Api::Base::_ActionHandle_default_instance_);
}
inline ::Kinova::Api::Base::ActionHandle* ActionNotification::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ActionNotification.handle)
  
  ::Kinova::Api::Base::ActionHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::ActionHandle* ActionNotification::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Base::ActionHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ActionNotification.handle)
  return handle_;
}
inline void ActionNotification::set_allocated_handle(::Kinova::Api::Base::ActionHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handle_;
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ActionNotification.handle)
}

// .Kinova.Api.Common.Timestamp timestamp = 3;
inline bool ActionNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& ActionNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActionNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* ActionNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ActionNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* ActionNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ActionNotification.timestamp)
  return timestamp_;
}
inline void ActionNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ActionNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 4;
inline bool ActionNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& ActionNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActionNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* ActionNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ActionNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* ActionNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ActionNotification.user_handle)
  return user_handle_;
}
inline void ActionNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ActionNotification.user_handle)
}

// .Kinova.Api.SubErrorCodes abort_details = 5;
inline void ActionNotification::clear_abort_details() {
  abort_details_ = 0;
}
inline ::Kinova::Api::SubErrorCodes ActionNotification::abort_details() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActionNotification.abort_details)
  return static_cast< ::Kinova::Api::SubErrorCodes >(abort_details_);
}
inline void ActionNotification::set_abort_details(::Kinova::Api::SubErrorCodes value) {
  
  abort_details_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ActionNotification.abort_details)
}

// .Kinova.Api.Common.Connection connection = 6;
inline bool ActionNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& ActionNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActionNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* ActionNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ActionNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* ActionNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ActionNotification.connection)
  return connection_;
}
inline void ActionNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ActionNotification.connection)
}

// repeated .Kinova.Api.Base.TrajectoryInfo trajectory_info = 7;
inline int ActionNotification::trajectory_info_size() const {
  return trajectory_info_.size();
}
inline void ActionNotification::clear_trajectory_info() {
  trajectory_info_.Clear();
}
inline const ::Kinova::Api::Base::TrajectoryInfo& ActionNotification::trajectory_info(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActionNotification.trajectory_info)
  return trajectory_info_.Get(index);
}
inline ::Kinova::Api::Base::TrajectoryInfo* ActionNotification::mutable_trajectory_info(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ActionNotification.trajectory_info)
  return trajectory_info_.Mutable(index);
}
inline ::Kinova::Api::Base::TrajectoryInfo* ActionNotification::add_trajectory_info() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.ActionNotification.trajectory_info)
  return trajectory_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::TrajectoryInfo >*
ActionNotification::mutable_trajectory_info() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.ActionNotification.trajectory_info)
  return &trajectory_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::TrajectoryInfo >&
ActionNotification::trajectory_info() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.ActionNotification.trajectory_info)
  return trajectory_info_;
}

// -------------------------------------------------------------------

// TrajectoryInfo

// .Kinova.Api.Base.TrajectoryInfoType trajectory_info_type = 1;
inline void TrajectoryInfo::clear_trajectory_info_type() {
  trajectory_info_type_ = 0;
}
inline ::Kinova::Api::Base::TrajectoryInfoType TrajectoryInfo::trajectory_info_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TrajectoryInfo.trajectory_info_type)
  return static_cast< ::Kinova::Api::Base::TrajectoryInfoType >(trajectory_info_type_);
}
inline void TrajectoryInfo::set_trajectory_info_type(::Kinova::Api::Base::TrajectoryInfoType value) {
  
  trajectory_info_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TrajectoryInfo.trajectory_info_type)
}

// uint32 waypoint_index = 2;
inline void TrajectoryInfo::clear_waypoint_index() {
  waypoint_index_ = 0u;
}
inline ::google::protobuf::uint32 TrajectoryInfo::waypoint_index() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TrajectoryInfo.waypoint_index)
  return waypoint_index_;
}
inline void TrajectoryInfo::set_waypoint_index(::google::protobuf::uint32 value) {
  
  waypoint_index_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TrajectoryInfo.waypoint_index)
}

// uint32 joint_index = 3;
inline void TrajectoryInfo::clear_joint_index() {
  joint_index_ = 0u;
}
inline ::google::protobuf::uint32 TrajectoryInfo::joint_index() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TrajectoryInfo.joint_index)
  return joint_index_;
}
inline void TrajectoryInfo::set_joint_index(::google::protobuf::uint32 value) {
  
  joint_index_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TrajectoryInfo.joint_index)
}

// -------------------------------------------------------------------

// ActionExecutionState

// .Kinova.Api.Base.ActionEvent action_event = 1;
inline void ActionExecutionState::clear_action_event() {
  action_event_ = 0;
}
inline ::Kinova::Api::Base::ActionEvent ActionExecutionState::action_event() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActionExecutionState.action_event)
  return static_cast< ::Kinova::Api::Base::ActionEvent >(action_event_);
}
inline void ActionExecutionState::set_action_event(::Kinova::Api::Base::ActionEvent value) {
  
  action_event_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ActionExecutionState.action_event)
}

// .Kinova.Api.Base.ActionHandle handle = 2;
inline bool ActionExecutionState::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline void ActionExecutionState::clear_handle() {
  if (GetArenaNoVirtual() == NULL && handle_ != NULL) {
    delete handle_;
  }
  handle_ = NULL;
}
inline const ::Kinova::Api::Base::ActionHandle& ActionExecutionState::handle() const {
  const ::Kinova::Api::Base::ActionHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActionExecutionState.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::ActionHandle*>(
      &::Kinova::Api::Base::_ActionHandle_default_instance_);
}
inline ::Kinova::Api::Base::ActionHandle* ActionExecutionState::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ActionExecutionState.handle)
  
  ::Kinova::Api::Base::ActionHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::ActionHandle* ActionExecutionState::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Base::ActionHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ActionExecutionState.handle)
  return handle_;
}
inline void ActionExecutionState::set_allocated_handle(::Kinova::Api::Base::ActionHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handle_;
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ActionExecutionState.handle)
}

// -------------------------------------------------------------------

// RobotEventNotification

// .Kinova.Api.Base.RobotEvent event = 1;
inline void RobotEventNotification::clear_event() {
  event_ = 0;
}
inline ::Kinova::Api::Base::RobotEvent RobotEventNotification::event() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.RobotEventNotification.event)
  return static_cast< ::Kinova::Api::Base::RobotEvent >(event_);
}
inline void RobotEventNotification::set_event(::Kinova::Api::Base::RobotEvent value) {
  
  event_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.RobotEventNotification.event)
}

// .Kinova.Api.Common.DeviceHandle handle = 2;
inline bool RobotEventNotification::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline const ::Kinova::Api::Common::DeviceHandle& RobotEventNotification::handle() const {
  const ::Kinova::Api::Common::DeviceHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.RobotEventNotification.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::DeviceHandle*>(
      &::Kinova::Api::Common::_DeviceHandle_default_instance_);
}
inline ::Kinova::Api::Common::DeviceHandle* RobotEventNotification::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.RobotEventNotification.handle)
  
  ::Kinova::Api::Common::DeviceHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::DeviceHandle* RobotEventNotification::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Common::DeviceHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.RobotEventNotification.handle)
  return handle_;
}
inline void RobotEventNotification::set_allocated_handle(::Kinova::Api::Common::DeviceHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(handle_);
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.RobotEventNotification.handle)
}

// .Kinova.Api.Common.Timestamp timestamp = 3;
inline bool RobotEventNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& RobotEventNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.RobotEventNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* RobotEventNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.RobotEventNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* RobotEventNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.RobotEventNotification.timestamp)
  return timestamp_;
}
inline void RobotEventNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.RobotEventNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 4;
inline bool RobotEventNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& RobotEventNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.RobotEventNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* RobotEventNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.RobotEventNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* RobotEventNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.RobotEventNotification.user_handle)
  return user_handle_;
}
inline void RobotEventNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.RobotEventNotification.user_handle)
}

// .Kinova.Api.Common.Connection connection = 6;
inline bool RobotEventNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& RobotEventNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.RobotEventNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* RobotEventNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.RobotEventNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* RobotEventNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.RobotEventNotification.connection)
  return connection_;
}
inline void RobotEventNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.RobotEventNotification.connection)
}

// -------------------------------------------------------------------

// FactoryNotification

// .Kinova.Api.Base.FactoryEvent event = 1;
inline void FactoryNotification::clear_event() {
  event_ = 0;
}
inline ::Kinova::Api::Base::FactoryEvent FactoryNotification::event() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.FactoryNotification.event)
  return static_cast< ::Kinova::Api::Base::FactoryEvent >(event_);
}
inline void FactoryNotification::set_event(::Kinova::Api::Base::FactoryEvent value) {
  
  event_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.FactoryNotification.event)
}

// .Kinova.Api.Common.Timestamp timestamp = 2;
inline bool FactoryNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& FactoryNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.FactoryNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* FactoryNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.FactoryNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* FactoryNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.FactoryNotification.timestamp)
  return timestamp_;
}
inline void FactoryNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.FactoryNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 3;
inline bool FactoryNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& FactoryNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.FactoryNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* FactoryNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.FactoryNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* FactoryNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.FactoryNotification.user_handle)
  return user_handle_;
}
inline void FactoryNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.FactoryNotification.user_handle)
}

// .Kinova.Api.Common.Connection connection = 4;
inline bool FactoryNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& FactoryNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.FactoryNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* FactoryNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.FactoryNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* FactoryNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.FactoryNotification.connection)
  return connection_;
}
inline void FactoryNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.FactoryNotification.connection)
}

// -------------------------------------------------------------------

// NetworkNotification

// .Kinova.Api.Base.NetworkEvent event = 1;
inline void NetworkNotification::clear_event() {
  event_ = 0;
}
inline ::Kinova::Api::Base::NetworkEvent NetworkNotification::event() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.NetworkNotification.event)
  return static_cast< ::Kinova::Api::Base::NetworkEvent >(event_);
}
inline void NetworkNotification::set_event(::Kinova::Api::Base::NetworkEvent value) {
  
  event_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.NetworkNotification.event)
}

// .Kinova.Api.Common.Timestamp timestamp = 2;
inline bool NetworkNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& NetworkNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.NetworkNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* NetworkNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.NetworkNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* NetworkNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.NetworkNotification.timestamp)
  return timestamp_;
}
inline void NetworkNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.NetworkNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 3;
inline bool NetworkNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& NetworkNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.NetworkNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* NetworkNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.NetworkNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* NetworkNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.NetworkNotification.user_handle)
  return user_handle_;
}
inline void NetworkNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.NetworkNotification.user_handle)
}

// .Kinova.Api.Common.Connection connection = 4;
inline bool NetworkNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& NetworkNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.NetworkNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* NetworkNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.NetworkNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* NetworkNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.NetworkNotification.connection)
  return connection_;
}
inline void NetworkNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.NetworkNotification.connection)
}

// -------------------------------------------------------------------

// ConfigurationChangeNotificationList

// repeated .Kinova.Api.Base.ConfigurationChangeNotification notifications = 1;
inline int ConfigurationChangeNotificationList::notifications_size() const {
  return notifications_.size();
}
inline void ConfigurationChangeNotificationList::clear_notifications() {
  notifications_.Clear();
}
inline const ::Kinova::Api::Base::ConfigurationChangeNotification& ConfigurationChangeNotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConfigurationChangeNotificationList.notifications)
  return notifications_.Get(index);
}
inline ::Kinova::Api::Base::ConfigurationChangeNotification* ConfigurationChangeNotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConfigurationChangeNotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::Kinova::Api::Base::ConfigurationChangeNotification* ConfigurationChangeNotificationList::add_notifications() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.ConfigurationChangeNotificationList.notifications)
  return notifications_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ConfigurationChangeNotification >*
ConfigurationChangeNotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.ConfigurationChangeNotificationList.notifications)
  return &notifications_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ConfigurationChangeNotification >&
ConfigurationChangeNotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.ConfigurationChangeNotificationList.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// MappingInfoNotificationList

// repeated .Kinova.Api.Base.MappingInfoNotification notifications = 1;
inline int MappingInfoNotificationList::notifications_size() const {
  return notifications_.size();
}
inline void MappingInfoNotificationList::clear_notifications() {
  notifications_.Clear();
}
inline const ::Kinova::Api::Base::MappingInfoNotification& MappingInfoNotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MappingInfoNotificationList.notifications)
  return notifications_.Get(index);
}
inline ::Kinova::Api::Base::MappingInfoNotification* MappingInfoNotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MappingInfoNotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::Kinova::Api::Base::MappingInfoNotification* MappingInfoNotificationList::add_notifications() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.MappingInfoNotificationList.notifications)
  return notifications_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MappingInfoNotification >*
MappingInfoNotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.MappingInfoNotificationList.notifications)
  return &notifications_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MappingInfoNotification >&
MappingInfoNotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.MappingInfoNotificationList.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// ControlModeNotificationList

// repeated .Kinova.Api.Base.ControlModeNotification notifications = 1;
inline int ControlModeNotificationList::notifications_size() const {
  return notifications_.size();
}
inline void ControlModeNotificationList::clear_notifications() {
  notifications_.Clear();
}
inline const ::Kinova::Api::Base::ControlModeNotification& ControlModeNotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControlModeNotificationList.notifications)
  return notifications_.Get(index);
}
inline ::Kinova::Api::Base::ControlModeNotification* ControlModeNotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControlModeNotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::Kinova::Api::Base::ControlModeNotification* ControlModeNotificationList::add_notifications() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.ControlModeNotificationList.notifications)
  return notifications_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControlModeNotification >*
ControlModeNotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.ControlModeNotificationList.notifications)
  return &notifications_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControlModeNotification >&
ControlModeNotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.ControlModeNotificationList.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// OperatingModeNotificationList

// repeated .Kinova.Api.Base.OperatingModeNotification notifications = 1;
inline int OperatingModeNotificationList::notifications_size() const {
  return notifications_.size();
}
inline void OperatingModeNotificationList::clear_notifications() {
  notifications_.Clear();
}
inline const ::Kinova::Api::Base::OperatingModeNotification& OperatingModeNotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.OperatingModeNotificationList.notifications)
  return notifications_.Get(index);
}
inline ::Kinova::Api::Base::OperatingModeNotification* OperatingModeNotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.OperatingModeNotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::Kinova::Api::Base::OperatingModeNotification* OperatingModeNotificationList::add_notifications() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.OperatingModeNotificationList.notifications)
  return notifications_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::OperatingModeNotification >*
OperatingModeNotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.OperatingModeNotificationList.notifications)
  return &notifications_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::OperatingModeNotification >&
OperatingModeNotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.OperatingModeNotificationList.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// ServoingModeNotificationList

// repeated .Kinova.Api.Base.ServoingModeNotification notifications = 1;
inline int ServoingModeNotificationList::notifications_size() const {
  return notifications_.size();
}
inline void ServoingModeNotificationList::clear_notifications() {
  notifications_.Clear();
}
inline const ::Kinova::Api::Base::ServoingModeNotification& ServoingModeNotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ServoingModeNotificationList.notifications)
  return notifications_.Get(index);
}
inline ::Kinova::Api::Base::ServoingModeNotification* ServoingModeNotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ServoingModeNotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::Kinova::Api::Base::ServoingModeNotification* ServoingModeNotificationList::add_notifications() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.ServoingModeNotificationList.notifications)
  return notifications_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ServoingModeNotification >*
ServoingModeNotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.ServoingModeNotificationList.notifications)
  return &notifications_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ServoingModeNotification >&
ServoingModeNotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.ServoingModeNotificationList.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// SequenceInfoNotificationList

// repeated .Kinova.Api.Base.SequenceInfoNotification notifications = 1;
inline int SequenceInfoNotificationList::notifications_size() const {
  return notifications_.size();
}
inline void SequenceInfoNotificationList::clear_notifications() {
  notifications_.Clear();
}
inline const ::Kinova::Api::Base::SequenceInfoNotification& SequenceInfoNotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SequenceInfoNotificationList.notifications)
  return notifications_.Get(index);
}
inline ::Kinova::Api::Base::SequenceInfoNotification* SequenceInfoNotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SequenceInfoNotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::Kinova::Api::Base::SequenceInfoNotification* SequenceInfoNotificationList::add_notifications() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.SequenceInfoNotificationList.notifications)
  return notifications_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceInfoNotification >*
SequenceInfoNotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.SequenceInfoNotificationList.notifications)
  return &notifications_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::SequenceInfoNotification >&
SequenceInfoNotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.SequenceInfoNotificationList.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// ProtectionZoneNotificationList

// repeated .Kinova.Api.Base.ProtectionZoneNotification notifications = 1;
inline int ProtectionZoneNotificationList::notifications_size() const {
  return notifications_.size();
}
inline void ProtectionZoneNotificationList::clear_notifications() {
  notifications_.Clear();
}
inline const ::Kinova::Api::Base::ProtectionZoneNotification& ProtectionZoneNotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ProtectionZoneNotificationList.notifications)
  return notifications_.Get(index);
}
inline ::Kinova::Api::Base::ProtectionZoneNotification* ProtectionZoneNotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ProtectionZoneNotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::Kinova::Api::Base::ProtectionZoneNotification* ProtectionZoneNotificationList::add_notifications() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.ProtectionZoneNotificationList.notifications)
  return notifications_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ProtectionZoneNotification >*
ProtectionZoneNotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.ProtectionZoneNotificationList.notifications)
  return &notifications_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ProtectionZoneNotification >&
ProtectionZoneNotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.ProtectionZoneNotificationList.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// UserNotificationList

// repeated .Kinova.Api.Base.UserNotification notifications = 1;
inline int UserNotificationList::notifications_size() const {
  return notifications_.size();
}
inline void UserNotificationList::clear_notifications() {
  notifications_.Clear();
}
inline const ::Kinova::Api::Base::UserNotification& UserNotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.UserNotificationList.notifications)
  return notifications_.Get(index);
}
inline ::Kinova::Api::Base::UserNotification* UserNotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.UserNotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::Kinova::Api::Base::UserNotification* UserNotificationList::add_notifications() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.UserNotificationList.notifications)
  return notifications_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::UserNotification >*
UserNotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.UserNotificationList.notifications)
  return &notifications_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::UserNotification >&
UserNotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.UserNotificationList.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// SafetyNotificationList

// repeated .Kinova.Api.Common.SafetyNotification notifications = 1;
inline int SafetyNotificationList::notifications_size() const {
  return notifications_.size();
}
inline const ::Kinova::Api::Common::SafetyNotification& SafetyNotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SafetyNotificationList.notifications)
  return notifications_.Get(index);
}
inline ::Kinova::Api::Common::SafetyNotification* SafetyNotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SafetyNotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::Kinova::Api::Common::SafetyNotification* SafetyNotificationList::add_notifications() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.SafetyNotificationList.notifications)
  return notifications_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Common::SafetyNotification >*
SafetyNotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.SafetyNotificationList.notifications)
  return &notifications_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Common::SafetyNotification >&
SafetyNotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.SafetyNotificationList.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// ControllerNotificationList

// repeated .Kinova.Api.Base.ControllerNotification notifications = 1;
inline int ControllerNotificationList::notifications_size() const {
  return notifications_.size();
}
inline void ControllerNotificationList::clear_notifications() {
  notifications_.Clear();
}
inline const ::Kinova::Api::Base::ControllerNotification& ControllerNotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerNotificationList.notifications)
  return notifications_.Get(index);
}
inline ::Kinova::Api::Base::ControllerNotification* ControllerNotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerNotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::Kinova::Api::Base::ControllerNotification* ControllerNotificationList::add_notifications() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.ControllerNotificationList.notifications)
  return notifications_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerNotification >*
ControllerNotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.ControllerNotificationList.notifications)
  return &notifications_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerNotification >&
ControllerNotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.ControllerNotificationList.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// ActionNotificationList

// repeated .Kinova.Api.Base.ActionNotification notifications = 1;
inline int ActionNotificationList::notifications_size() const {
  return notifications_.size();
}
inline void ActionNotificationList::clear_notifications() {
  notifications_.Clear();
}
inline const ::Kinova::Api::Base::ActionNotification& ActionNotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActionNotificationList.notifications)
  return notifications_.Get(index);
}
inline ::Kinova::Api::Base::ActionNotification* ActionNotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ActionNotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::Kinova::Api::Base::ActionNotification* ActionNotificationList::add_notifications() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.ActionNotificationList.notifications)
  return notifications_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ActionNotification >*
ActionNotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.ActionNotificationList.notifications)
  return &notifications_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ActionNotification >&
ActionNotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.ActionNotificationList.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// RobotEventNotificationList

// repeated .Kinova.Api.Base.RobotEventNotification notifications = 1;
inline int RobotEventNotificationList::notifications_size() const {
  return notifications_.size();
}
inline void RobotEventNotificationList::clear_notifications() {
  notifications_.Clear();
}
inline const ::Kinova::Api::Base::RobotEventNotification& RobotEventNotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.RobotEventNotificationList.notifications)
  return notifications_.Get(index);
}
inline ::Kinova::Api::Base::RobotEventNotification* RobotEventNotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.RobotEventNotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::Kinova::Api::Base::RobotEventNotification* RobotEventNotificationList::add_notifications() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.RobotEventNotificationList.notifications)
  return notifications_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::RobotEventNotification >*
RobotEventNotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.RobotEventNotificationList.notifications)
  return &notifications_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::RobotEventNotification >&
RobotEventNotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.RobotEventNotificationList.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// NetworkNotificationList

// repeated .Kinova.Api.Base.NetworkNotification notifications = 1;
inline int NetworkNotificationList::notifications_size() const {
  return notifications_.size();
}
inline void NetworkNotificationList::clear_notifications() {
  notifications_.Clear();
}
inline const ::Kinova::Api::Base::NetworkNotification& NetworkNotificationList::notifications(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.NetworkNotificationList.notifications)
  return notifications_.Get(index);
}
inline ::Kinova::Api::Base::NetworkNotification* NetworkNotificationList::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.NetworkNotificationList.notifications)
  return notifications_.Mutable(index);
}
inline ::Kinova::Api::Base::NetworkNotification* NetworkNotificationList::add_notifications() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.NetworkNotificationList.notifications)
  return notifications_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::NetworkNotification >*
NetworkNotificationList::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.NetworkNotificationList.notifications)
  return &notifications_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::NetworkNotification >&
NetworkNotificationList::notifications() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.NetworkNotificationList.notifications)
  return notifications_;
}

// -------------------------------------------------------------------

// MappingHandle

// uint32 identifier = 1;
inline void MappingHandle::clear_identifier() {
  identifier_ = 0u;
}
inline ::google::protobuf::uint32 MappingHandle::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MappingHandle.identifier)
  return identifier_;
}
inline void MappingHandle::set_identifier(::google::protobuf::uint32 value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.MappingHandle.identifier)
}

// fixed32 permission = 2;
inline void MappingHandle::clear_permission() {
  permission_ = 0u;
}
inline ::google::protobuf::uint32 MappingHandle::permission() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MappingHandle.permission)
  return permission_;
}
inline void MappingHandle::set_permission(::google::protobuf::uint32 value) {
  
  permission_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.MappingHandle.permission)
}

// -------------------------------------------------------------------

// SafetyEvent

// .Kinova.Api.Common.SafetyHandle safety_handle = 1;
inline bool SafetyEvent::has_safety_handle() const {
  return this != internal_default_instance() && safety_handle_ != NULL;
}
inline const ::Kinova::Api::Common::SafetyHandle& SafetyEvent::safety_handle() const {
  const ::Kinova::Api::Common::SafetyHandle* p = safety_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SafetyEvent.safety_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::SafetyHandle*>(
      &::Kinova::Api::Common::_SafetyHandle_default_instance_);
}
inline ::Kinova::Api::Common::SafetyHandle* SafetyEvent::release_safety_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.SafetyEvent.safety_handle)
  
  ::Kinova::Api::Common::SafetyHandle* temp = safety_handle_;
  safety_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::SafetyHandle* SafetyEvent::mutable_safety_handle() {
  
  if (safety_handle_ == NULL) {
    safety_handle_ = new ::Kinova::Api::Common::SafetyHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.SafetyEvent.safety_handle)
  return safety_handle_;
}
inline void SafetyEvent::set_allocated_safety_handle(::Kinova::Api::Common::SafetyHandle* safety_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(safety_handle_);
  }
  if (safety_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      safety_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, safety_handle, submessage_arena);
    }
    
  } else {
    
  }
  safety_handle_ = safety_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.SafetyEvent.safety_handle)
}

// -------------------------------------------------------------------

// ControllerEvent

// .Kinova.Api.Base.ControllerInputType input_type = 1;
inline void ControllerEvent::clear_input_type() {
  input_type_ = 0;
}
inline ::Kinova::Api::Base::ControllerInputType ControllerEvent::input_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerEvent.input_type)
  return static_cast< ::Kinova::Api::Base::ControllerInputType >(input_type_);
}
inline void ControllerEvent::set_input_type(::Kinova::Api::Base::ControllerInputType value) {
  
  input_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControllerEvent.input_type)
}

// .Kinova.Api.Base.ControllerBehavior behavior = 2;
inline void ControllerEvent::clear_behavior() {
  behavior_ = 0;
}
inline ::Kinova::Api::Base::ControllerBehavior ControllerEvent::behavior() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerEvent.behavior)
  return static_cast< ::Kinova::Api::Base::ControllerBehavior >(behavior_);
}
inline void ControllerEvent::set_behavior(::Kinova::Api::Base::ControllerBehavior value) {
  
  behavior_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControllerEvent.behavior)
}

// uint32 input_identifier = 3;
inline void ControllerEvent::clear_input_identifier() {
  input_identifier_ = 0u;
}
inline ::google::protobuf::uint32 ControllerEvent::input_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerEvent.input_identifier)
  return input_identifier_;
}
inline void ControllerEvent::set_input_identifier(::google::protobuf::uint32 value) {
  
  input_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControllerEvent.input_identifier)
}

// -------------------------------------------------------------------

// GpioEvent

// .Kinova.Api.Base.ControllerInputType input_type = 1;
inline void GpioEvent::clear_input_type() {
  input_type_ = 0;
}
inline ::Kinova::Api::Base::ControllerInputType GpioEvent::input_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GpioEvent.input_type)
  return static_cast< ::Kinova::Api::Base::ControllerInputType >(input_type_);
}
inline void GpioEvent::set_input_type(::Kinova::Api::Base::ControllerInputType value) {
  
  input_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GpioEvent.input_type)
}

// .Kinova.Api.Base.GpioBehavior behavior = 2;
inline void GpioEvent::clear_behavior() {
  behavior_ = 0;
}
inline ::Kinova::Api::Base::GpioBehavior GpioEvent::behavior() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GpioEvent.behavior)
  return static_cast< ::Kinova::Api::Base::GpioBehavior >(behavior_);
}
inline void GpioEvent::set_behavior(::Kinova::Api::Base::GpioBehavior value) {
  
  behavior_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GpioEvent.behavior)
}

// uint32 input_identifier = 3;
inline void GpioEvent::clear_input_identifier() {
  input_identifier_ = 0u;
}
inline ::google::protobuf::uint32 GpioEvent::input_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GpioEvent.input_identifier)
  return input_identifier_;
}
inline void GpioEvent::set_input_identifier(::google::protobuf::uint32 value) {
  
  input_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GpioEvent.input_identifier)
}

// -------------------------------------------------------------------

// MapEvent

// .Kinova.Api.Base.SafetyEvent safety_event = 1;
inline bool MapEvent::has_safety_event() const {
  return events_case() == kSafetyEvent;
}
inline void MapEvent::set_has_safety_event() {
  _oneof_case_[0] = kSafetyEvent;
}
inline void MapEvent::clear_safety_event() {
  if (has_safety_event()) {
    delete events_.safety_event_;
    clear_has_events();
  }
}
inline ::Kinova::Api::Base::SafetyEvent* MapEvent::release_safety_event() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MapEvent.safety_event)
  if (has_safety_event()) {
    clear_has_events();
      ::Kinova::Api::Base::SafetyEvent* temp = events_.safety_event_;
    events_.safety_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::SafetyEvent& MapEvent::safety_event() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapEvent.safety_event)
  return has_safety_event()
      ? *events_.safety_event_
      : *reinterpret_cast< ::Kinova::Api::Base::SafetyEvent*>(&::Kinova::Api::Base::_SafetyEvent_default_instance_);
}
inline ::Kinova::Api::Base::SafetyEvent* MapEvent::mutable_safety_event() {
  if (!has_safety_event()) {
    clear_events();
    set_has_safety_event();
    events_.safety_event_ = new ::Kinova::Api::Base::SafetyEvent;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapEvent.safety_event)
  return events_.safety_event_;
}

// .Kinova.Api.Base.GpioEvent gpio_event = 2;
inline bool MapEvent::has_gpio_event() const {
  return events_case() == kGpioEvent;
}
inline void MapEvent::set_has_gpio_event() {
  _oneof_case_[0] = kGpioEvent;
}
inline void MapEvent::clear_gpio_event() {
  if (has_gpio_event()) {
    delete events_.gpio_event_;
    clear_has_events();
  }
}
inline ::Kinova::Api::Base::GpioEvent* MapEvent::release_gpio_event() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MapEvent.gpio_event)
  if (has_gpio_event()) {
    clear_has_events();
      ::Kinova::Api::Base::GpioEvent* temp = events_.gpio_event_;
    events_.gpio_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::GpioEvent& MapEvent::gpio_event() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapEvent.gpio_event)
  return has_gpio_event()
      ? *events_.gpio_event_
      : *reinterpret_cast< ::Kinova::Api::Base::GpioEvent*>(&::Kinova::Api::Base::_GpioEvent_default_instance_);
}
inline ::Kinova::Api::Base::GpioEvent* MapEvent::mutable_gpio_event() {
  if (!has_gpio_event()) {
    clear_events();
    set_has_gpio_event();
    events_.gpio_event_ = new ::Kinova::Api::Base::GpioEvent;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapEvent.gpio_event)
  return events_.gpio_event_;
}

// .Kinova.Api.Base.ControllerEvent controller_event = 3;
inline bool MapEvent::has_controller_event() const {
  return events_case() == kControllerEvent;
}
inline void MapEvent::set_has_controller_event() {
  _oneof_case_[0] = kControllerEvent;
}
inline void MapEvent::clear_controller_event() {
  if (has_controller_event()) {
    delete events_.controller_event_;
    clear_has_events();
  }
}
inline ::Kinova::Api::Base::ControllerEvent* MapEvent::release_controller_event() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MapEvent.controller_event)
  if (has_controller_event()) {
    clear_has_events();
      ::Kinova::Api::Base::ControllerEvent* temp = events_.controller_event_;
    events_.controller_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::ControllerEvent& MapEvent::controller_event() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapEvent.controller_event)
  return has_controller_event()
      ? *events_.controller_event_
      : *reinterpret_cast< ::Kinova::Api::Base::ControllerEvent*>(&::Kinova::Api::Base::_ControllerEvent_default_instance_);
}
inline ::Kinova::Api::Base::ControllerEvent* MapEvent::mutable_controller_event() {
  if (!has_controller_event()) {
    clear_events();
    set_has_controller_event();
    events_.controller_event_ = new ::Kinova::Api::Base::ControllerEvent;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapEvent.controller_event)
  return events_.controller_event_;
}

// string name = 4;
inline void MapEvent::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapEvent::name() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapEvent.name)
  return name_.GetNoArena();
}
inline void MapEvent::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.MapEvent.name)
}
#if LANG_CXX11
inline void MapEvent::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.MapEvent.name)
}
#endif
inline void MapEvent::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.MapEvent.name)
}
inline void MapEvent::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.MapEvent.name)
}
inline ::std::string* MapEvent::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapEvent.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapEvent::release_name() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MapEvent.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapEvent::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.MapEvent.name)
}

inline bool MapEvent::has_events() const {
  return events_case() != EVENTS_NOT_SET;
}
inline void MapEvent::clear_has_events() {
  _oneof_case_[0] = EVENTS_NOT_SET;
}
inline MapEvent::EventsCase MapEvent::events_case() const {
  return MapEvent::EventsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MapElement

// .Kinova.Api.Base.MapEvent event = 1;
inline bool MapElement::has_event() const {
  return this != internal_default_instance() && event_ != NULL;
}
inline void MapElement::clear_event() {
  if (GetArenaNoVirtual() == NULL && event_ != NULL) {
    delete event_;
  }
  event_ = NULL;
}
inline const ::Kinova::Api::Base::MapEvent& MapElement::event() const {
  const ::Kinova::Api::Base::MapEvent* p = event_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapElement.event)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MapEvent*>(
      &::Kinova::Api::Base::_MapEvent_default_instance_);
}
inline ::Kinova::Api::Base::MapEvent* MapElement::release_event() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MapElement.event)
  
  ::Kinova::Api::Base::MapEvent* temp = event_;
  event_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MapEvent* MapElement::mutable_event() {
  
  if (event_ == NULL) {
    event_ = new ::Kinova::Api::Base::MapEvent;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapElement.event)
  return event_;
}
inline void MapElement::set_allocated_event(::Kinova::Api::Base::MapEvent* event) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_;
  }
  if (event) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.MapElement.event)
}

// .Kinova.Api.Base.Action action = 2;
inline bool MapElement::has_action() const {
  return this != internal_default_instance() && action_ != NULL;
}
inline void MapElement::clear_action() {
  if (GetArenaNoVirtual() == NULL && action_ != NULL) {
    delete action_;
  }
  action_ = NULL;
}
inline const ::Kinova::Api::Base::Action& MapElement::action() const {
  const ::Kinova::Api::Base::Action* p = action_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapElement.action)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::Action*>(
      &::Kinova::Api::Base::_Action_default_instance_);
}
inline ::Kinova::Api::Base::Action* MapElement::release_action() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MapElement.action)
  
  ::Kinova::Api::Base::Action* temp = action_;
  action_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::Action* MapElement::mutable_action() {
  
  if (action_ == NULL) {
    action_ = new ::Kinova::Api::Base::Action;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapElement.action)
  return action_;
}
inline void MapElement::set_allocated_action(::Kinova::Api::Base::Action* action) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete action_;
  }
  if (action) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      action = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.MapElement.action)
}

// string name = 3;
inline void MapElement::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapElement::name() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapElement.name)
  return name_.GetNoArena();
}
inline void MapElement::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.MapElement.name)
}
#if LANG_CXX11
inline void MapElement::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.MapElement.name)
}
#endif
inline void MapElement::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.MapElement.name)
}
inline void MapElement::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.MapElement.name)
}
inline ::std::string* MapElement::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapElement.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapElement::release_name() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MapElement.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapElement::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.MapElement.name)
}

// -------------------------------------------------------------------

// ActivateMapHandle

// .Kinova.Api.Base.MappingHandle mapping_handle = 1;
inline bool ActivateMapHandle::has_mapping_handle() const {
  return this != internal_default_instance() && mapping_handle_ != NULL;
}
inline void ActivateMapHandle::clear_mapping_handle() {
  if (GetArenaNoVirtual() == NULL && mapping_handle_ != NULL) {
    delete mapping_handle_;
  }
  mapping_handle_ = NULL;
}
inline const ::Kinova::Api::Base::MappingHandle& ActivateMapHandle::mapping_handle() const {
  const ::Kinova::Api::Base::MappingHandle* p = mapping_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActivateMapHandle.mapping_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MappingHandle*>(
      &::Kinova::Api::Base::_MappingHandle_default_instance_);
}
inline ::Kinova::Api::Base::MappingHandle* ActivateMapHandle::release_mapping_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ActivateMapHandle.mapping_handle)
  
  ::Kinova::Api::Base::MappingHandle* temp = mapping_handle_;
  mapping_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MappingHandle* ActivateMapHandle::mutable_mapping_handle() {
  
  if (mapping_handle_ == NULL) {
    mapping_handle_ = new ::Kinova::Api::Base::MappingHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ActivateMapHandle.mapping_handle)
  return mapping_handle_;
}
inline void ActivateMapHandle::set_allocated_mapping_handle(::Kinova::Api::Base::MappingHandle* mapping_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mapping_handle_;
  }
  if (mapping_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mapping_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mapping_handle, submessage_arena);
    }
    
  } else {
    
  }
  mapping_handle_ = mapping_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ActivateMapHandle.mapping_handle)
}

// .Kinova.Api.Base.MapGroupHandle map_group_handle = 2;
inline bool ActivateMapHandle::has_map_group_handle() const {
  return this != internal_default_instance() && map_group_handle_ != NULL;
}
inline void ActivateMapHandle::clear_map_group_handle() {
  if (GetArenaNoVirtual() == NULL && map_group_handle_ != NULL) {
    delete map_group_handle_;
  }
  map_group_handle_ = NULL;
}
inline const ::Kinova::Api::Base::MapGroupHandle& ActivateMapHandle::map_group_handle() const {
  const ::Kinova::Api::Base::MapGroupHandle* p = map_group_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActivateMapHandle.map_group_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MapGroupHandle*>(
      &::Kinova::Api::Base::_MapGroupHandle_default_instance_);
}
inline ::Kinova::Api::Base::MapGroupHandle* ActivateMapHandle::release_map_group_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ActivateMapHandle.map_group_handle)
  
  ::Kinova::Api::Base::MapGroupHandle* temp = map_group_handle_;
  map_group_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MapGroupHandle* ActivateMapHandle::mutable_map_group_handle() {
  
  if (map_group_handle_ == NULL) {
    map_group_handle_ = new ::Kinova::Api::Base::MapGroupHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ActivateMapHandle.map_group_handle)
  return map_group_handle_;
}
inline void ActivateMapHandle::set_allocated_map_group_handle(::Kinova::Api::Base::MapGroupHandle* map_group_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_group_handle_;
  }
  if (map_group_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_group_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_group_handle, submessage_arena);
    }
    
  } else {
    
  }
  map_group_handle_ = map_group_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ActivateMapHandle.map_group_handle)
}

// .Kinova.Api.Base.MapHandle map_handle = 3;
inline bool ActivateMapHandle::has_map_handle() const {
  return this != internal_default_instance() && map_handle_ != NULL;
}
inline void ActivateMapHandle::clear_map_handle() {
  if (GetArenaNoVirtual() == NULL && map_handle_ != NULL) {
    delete map_handle_;
  }
  map_handle_ = NULL;
}
inline const ::Kinova::Api::Base::MapHandle& ActivateMapHandle::map_handle() const {
  const ::Kinova::Api::Base::MapHandle* p = map_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActivateMapHandle.map_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MapHandle*>(
      &::Kinova::Api::Base::_MapHandle_default_instance_);
}
inline ::Kinova::Api::Base::MapHandle* ActivateMapHandle::release_map_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ActivateMapHandle.map_handle)
  
  ::Kinova::Api::Base::MapHandle* temp = map_handle_;
  map_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MapHandle* ActivateMapHandle::mutable_map_handle() {
  
  if (map_handle_ == NULL) {
    map_handle_ = new ::Kinova::Api::Base::MapHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ActivateMapHandle.map_handle)
  return map_handle_;
}
inline void ActivateMapHandle::set_allocated_map_handle(::Kinova::Api::Base::MapHandle* map_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_handle_;
  }
  if (map_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_handle, submessage_arena);
    }
    
  } else {
    
  }
  map_handle_ = map_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ActivateMapHandle.map_handle)
}

// -------------------------------------------------------------------

// Map

// .Kinova.Api.Base.MapHandle handle = 1;
inline bool Map::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline void Map::clear_handle() {
  if (GetArenaNoVirtual() == NULL && handle_ != NULL) {
    delete handle_;
  }
  handle_ = NULL;
}
inline const ::Kinova::Api::Base::MapHandle& Map::handle() const {
  const ::Kinova::Api::Base::MapHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Map.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MapHandle*>(
      &::Kinova::Api::Base::_MapHandle_default_instance_);
}
inline ::Kinova::Api::Base::MapHandle* Map::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Map.handle)
  
  ::Kinova::Api::Base::MapHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MapHandle* Map::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Base::MapHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Map.handle)
  return handle_;
}
inline void Map::set_allocated_handle(::Kinova::Api::Base::MapHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handle_;
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Map.handle)
}

// string name = 2;
inline void Map::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Map::name() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Map.name)
  return name_.GetNoArena();
}
inline void Map::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Map.name)
}
#if LANG_CXX11
inline void Map::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.Map.name)
}
#endif
inline void Map::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.Map.name)
}
inline void Map::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.Map.name)
}
inline ::std::string* Map::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Map.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Map::release_name() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Map.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Map::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Map.name)
}

// repeated .Kinova.Api.Base.MapElement elements = 3;
inline int Map::elements_size() const {
  return elements_.size();
}
inline void Map::clear_elements() {
  elements_.Clear();
}
inline const ::Kinova::Api::Base::MapElement& Map::elements(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Map.elements)
  return elements_.Get(index);
}
inline ::Kinova::Api::Base::MapElement* Map::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Map.elements)
  return elements_.Mutable(index);
}
inline ::Kinova::Api::Base::MapElement* Map::add_elements() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.Map.elements)
  return elements_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapElement >*
Map::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.Map.elements)
  return &elements_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapElement >&
Map::elements() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.Map.elements)
  return elements_;
}

// -------------------------------------------------------------------

// MapHandle

// uint32 identifier = 1;
inline void MapHandle::clear_identifier() {
  identifier_ = 0u;
}
inline ::google::protobuf::uint32 MapHandle::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapHandle.identifier)
  return identifier_;
}
inline void MapHandle::set_identifier(::google::protobuf::uint32 value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.MapHandle.identifier)
}

// fixed32 permission = 2;
inline void MapHandle::clear_permission() {
  permission_ = 0u;
}
inline ::google::protobuf::uint32 MapHandle::permission() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapHandle.permission)
  return permission_;
}
inline void MapHandle::set_permission(::google::protobuf::uint32 value) {
  
  permission_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.MapHandle.permission)
}

// -------------------------------------------------------------------

// MapList

// repeated .Kinova.Api.Base.Map map_list = 1;
inline int MapList::map_list_size() const {
  return map_list_.size();
}
inline void MapList::clear_map_list() {
  map_list_.Clear();
}
inline const ::Kinova::Api::Base::Map& MapList::map_list(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapList.map_list)
  return map_list_.Get(index);
}
inline ::Kinova::Api::Base::Map* MapList::mutable_map_list(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapList.map_list)
  return map_list_.Mutable(index);
}
inline ::Kinova::Api::Base::Map* MapList::add_map_list() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.MapList.map_list)
  return map_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Map >*
MapList::mutable_map_list() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.MapList.map_list)
  return &map_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Map >&
MapList::map_list() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.MapList.map_list)
  return map_list_;
}

// -------------------------------------------------------------------

// MapGroupHandle

// uint32 identifier = 1;
inline void MapGroupHandle::clear_identifier() {
  identifier_ = 0u;
}
inline ::google::protobuf::uint32 MapGroupHandle::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapGroupHandle.identifier)
  return identifier_;
}
inline void MapGroupHandle::set_identifier(::google::protobuf::uint32 value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.MapGroupHandle.identifier)
}

// fixed32 permission = 2;
inline void MapGroupHandle::clear_permission() {
  permission_ = 0u;
}
inline ::google::protobuf::uint32 MapGroupHandle::permission() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapGroupHandle.permission)
  return permission_;
}
inline void MapGroupHandle::set_permission(::google::protobuf::uint32 value) {
  
  permission_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.MapGroupHandle.permission)
}

// -------------------------------------------------------------------

// MapGroup

// .Kinova.Api.Base.MapGroupHandle group_handle = 1;
inline bool MapGroup::has_group_handle() const {
  return this != internal_default_instance() && group_handle_ != NULL;
}
inline void MapGroup::clear_group_handle() {
  if (GetArenaNoVirtual() == NULL && group_handle_ != NULL) {
    delete group_handle_;
  }
  group_handle_ = NULL;
}
inline const ::Kinova::Api::Base::MapGroupHandle& MapGroup::group_handle() const {
  const ::Kinova::Api::Base::MapGroupHandle* p = group_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapGroup.group_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MapGroupHandle*>(
      &::Kinova::Api::Base::_MapGroupHandle_default_instance_);
}
inline ::Kinova::Api::Base::MapGroupHandle* MapGroup::release_group_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MapGroup.group_handle)
  
  ::Kinova::Api::Base::MapGroupHandle* temp = group_handle_;
  group_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MapGroupHandle* MapGroup::mutable_group_handle() {
  
  if (group_handle_ == NULL) {
    group_handle_ = new ::Kinova::Api::Base::MapGroupHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapGroup.group_handle)
  return group_handle_;
}
inline void MapGroup::set_allocated_group_handle(::Kinova::Api::Base::MapGroupHandle* group_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete group_handle_;
  }
  if (group_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      group_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, group_handle, submessage_arena);
    }
    
  } else {
    
  }
  group_handle_ = group_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.MapGroup.group_handle)
}

// string name = 2;
inline void MapGroup::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapGroup::name() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapGroup.name)
  return name_.GetNoArena();
}
inline void MapGroup::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.MapGroup.name)
}
#if LANG_CXX11
inline void MapGroup::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.MapGroup.name)
}
#endif
inline void MapGroup::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.MapGroup.name)
}
inline void MapGroup::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.MapGroup.name)
}
inline ::std::string* MapGroup::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapGroup.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapGroup::release_name() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MapGroup.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapGroup::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.MapGroup.name)
}

// .Kinova.Api.Base.MappingHandle related_mapping_handle = 3;
inline bool MapGroup::has_related_mapping_handle() const {
  return this != internal_default_instance() && related_mapping_handle_ != NULL;
}
inline void MapGroup::clear_related_mapping_handle() {
  if (GetArenaNoVirtual() == NULL && related_mapping_handle_ != NULL) {
    delete related_mapping_handle_;
  }
  related_mapping_handle_ = NULL;
}
inline const ::Kinova::Api::Base::MappingHandle& MapGroup::related_mapping_handle() const {
  const ::Kinova::Api::Base::MappingHandle* p = related_mapping_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapGroup.related_mapping_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MappingHandle*>(
      &::Kinova::Api::Base::_MappingHandle_default_instance_);
}
inline ::Kinova::Api::Base::MappingHandle* MapGroup::release_related_mapping_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MapGroup.related_mapping_handle)
  
  ::Kinova::Api::Base::MappingHandle* temp = related_mapping_handle_;
  related_mapping_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MappingHandle* MapGroup::mutable_related_mapping_handle() {
  
  if (related_mapping_handle_ == NULL) {
    related_mapping_handle_ = new ::Kinova::Api::Base::MappingHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapGroup.related_mapping_handle)
  return related_mapping_handle_;
}
inline void MapGroup::set_allocated_related_mapping_handle(::Kinova::Api::Base::MappingHandle* related_mapping_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete related_mapping_handle_;
  }
  if (related_mapping_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      related_mapping_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, related_mapping_handle, submessage_arena);
    }
    
  } else {
    
  }
  related_mapping_handle_ = related_mapping_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.MapGroup.related_mapping_handle)
}

// .Kinova.Api.Base.MapGroupHandle parent_group_handle = 4;
inline bool MapGroup::has_parent_group_handle() const {
  return this != internal_default_instance() && parent_group_handle_ != NULL;
}
inline void MapGroup::clear_parent_group_handle() {
  if (GetArenaNoVirtual() == NULL && parent_group_handle_ != NULL) {
    delete parent_group_handle_;
  }
  parent_group_handle_ = NULL;
}
inline const ::Kinova::Api::Base::MapGroupHandle& MapGroup::parent_group_handle() const {
  const ::Kinova::Api::Base::MapGroupHandle* p = parent_group_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapGroup.parent_group_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MapGroupHandle*>(
      &::Kinova::Api::Base::_MapGroupHandle_default_instance_);
}
inline ::Kinova::Api::Base::MapGroupHandle* MapGroup::release_parent_group_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MapGroup.parent_group_handle)
  
  ::Kinova::Api::Base::MapGroupHandle* temp = parent_group_handle_;
  parent_group_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MapGroupHandle* MapGroup::mutable_parent_group_handle() {
  
  if (parent_group_handle_ == NULL) {
    parent_group_handle_ = new ::Kinova::Api::Base::MapGroupHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapGroup.parent_group_handle)
  return parent_group_handle_;
}
inline void MapGroup::set_allocated_parent_group_handle(::Kinova::Api::Base::MapGroupHandle* parent_group_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parent_group_handle_;
  }
  if (parent_group_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parent_group_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parent_group_handle, submessage_arena);
    }
    
  } else {
    
  }
  parent_group_handle_ = parent_group_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.MapGroup.parent_group_handle)
}

// repeated .Kinova.Api.Base.MapGroupHandle children_map_group_handles = 5;
inline int MapGroup::children_map_group_handles_size() const {
  return children_map_group_handles_.size();
}
inline void MapGroup::clear_children_map_group_handles() {
  children_map_group_handles_.Clear();
}
inline const ::Kinova::Api::Base::MapGroupHandle& MapGroup::children_map_group_handles(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapGroup.children_map_group_handles)
  return children_map_group_handles_.Get(index);
}
inline ::Kinova::Api::Base::MapGroupHandle* MapGroup::mutable_children_map_group_handles(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapGroup.children_map_group_handles)
  return children_map_group_handles_.Mutable(index);
}
inline ::Kinova::Api::Base::MapGroupHandle* MapGroup::add_children_map_group_handles() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.MapGroup.children_map_group_handles)
  return children_map_group_handles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroupHandle >*
MapGroup::mutable_children_map_group_handles() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.MapGroup.children_map_group_handles)
  return &children_map_group_handles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroupHandle >&
MapGroup::children_map_group_handles() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.MapGroup.children_map_group_handles)
  return children_map_group_handles_;
}

// repeated .Kinova.Api.Base.MapHandle map_handles = 6;
inline int MapGroup::map_handles_size() const {
  return map_handles_.size();
}
inline void MapGroup::clear_map_handles() {
  map_handles_.Clear();
}
inline const ::Kinova::Api::Base::MapHandle& MapGroup::map_handles(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapGroup.map_handles)
  return map_handles_.Get(index);
}
inline ::Kinova::Api::Base::MapHandle* MapGroup::mutable_map_handles(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapGroup.map_handles)
  return map_handles_.Mutable(index);
}
inline ::Kinova::Api::Base::MapHandle* MapGroup::add_map_handles() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.MapGroup.map_handles)
  return map_handles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapHandle >*
MapGroup::mutable_map_handles() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.MapGroup.map_handles)
  return &map_handles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapHandle >&
MapGroup::map_handles() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.MapGroup.map_handles)
  return map_handles_;
}

// string application_data = 7;
inline void MapGroup::clear_application_data() {
  application_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapGroup::application_data() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapGroup.application_data)
  return application_data_.GetNoArena();
}
inline void MapGroup::set_application_data(const ::std::string& value) {
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.MapGroup.application_data)
}
#if LANG_CXX11
inline void MapGroup::set_application_data(::std::string&& value) {
  
  application_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.MapGroup.application_data)
}
#endif
inline void MapGroup::set_application_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.MapGroup.application_data)
}
inline void MapGroup::set_application_data(const char* value, size_t size) {
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.MapGroup.application_data)
}
inline ::std::string* MapGroup::mutable_application_data() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapGroup.application_data)
  return application_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapGroup::release_application_data() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.MapGroup.application_data)
  
  return application_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapGroup::set_allocated_application_data(::std::string* application_data) {
  if (application_data != NULL) {
    
  } else {
    
  }
  application_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), application_data);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.MapGroup.application_data)
}

// -------------------------------------------------------------------

// MapGroupList

// repeated .Kinova.Api.Base.MapGroup map_groups = 1;
inline int MapGroupList::map_groups_size() const {
  return map_groups_.size();
}
inline void MapGroupList::clear_map_groups() {
  map_groups_.Clear();
}
inline const ::Kinova::Api::Base::MapGroup& MapGroupList::map_groups(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MapGroupList.map_groups)
  return map_groups_.Get(index);
}
inline ::Kinova::Api::Base::MapGroup* MapGroupList::mutable_map_groups(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MapGroupList.map_groups)
  return map_groups_.Mutable(index);
}
inline ::Kinova::Api::Base::MapGroup* MapGroupList::add_map_groups() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.MapGroupList.map_groups)
  return map_groups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroup >*
MapGroupList::mutable_map_groups() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.MapGroupList.map_groups)
  return &map_groups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroup >&
MapGroupList::map_groups() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.MapGroupList.map_groups)
  return map_groups_;
}

// -------------------------------------------------------------------

// Mapping

// .Kinova.Api.Base.MappingHandle handle = 1;
inline bool Mapping::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline void Mapping::clear_handle() {
  if (GetArenaNoVirtual() == NULL && handle_ != NULL) {
    delete handle_;
  }
  handle_ = NULL;
}
inline const ::Kinova::Api::Base::MappingHandle& Mapping::handle() const {
  const ::Kinova::Api::Base::MappingHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Mapping.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MappingHandle*>(
      &::Kinova::Api::Base::_MappingHandle_default_instance_);
}
inline ::Kinova::Api::Base::MappingHandle* Mapping::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Mapping.handle)
  
  ::Kinova::Api::Base::MappingHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MappingHandle* Mapping::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Base::MappingHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Mapping.handle)
  return handle_;
}
inline void Mapping::set_allocated_handle(::Kinova::Api::Base::MappingHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handle_;
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Mapping.handle)
}

// string name = 2;
inline void Mapping::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mapping::name() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Mapping.name)
  return name_.GetNoArena();
}
inline void Mapping::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Mapping.name)
}
#if LANG_CXX11
inline void Mapping::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.Mapping.name)
}
#endif
inline void Mapping::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.Mapping.name)
}
inline void Mapping::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.Mapping.name)
}
inline ::std::string* Mapping::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Mapping.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mapping::release_name() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Mapping.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mapping::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Mapping.name)
}

// uint32 controller_identifier = 3;
inline void Mapping::clear_controller_identifier() {
  controller_identifier_ = 0u;
}
inline ::google::protobuf::uint32 Mapping::controller_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Mapping.controller_identifier)
  return controller_identifier_;
}
inline void Mapping::set_controller_identifier(::google::protobuf::uint32 value) {
  
  controller_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Mapping.controller_identifier)
}

// .Kinova.Api.Base.MapGroupHandle active_map_group_handle = 4;
inline bool Mapping::has_active_map_group_handle() const {
  return this != internal_default_instance() && active_map_group_handle_ != NULL;
}
inline void Mapping::clear_active_map_group_handle() {
  if (GetArenaNoVirtual() == NULL && active_map_group_handle_ != NULL) {
    delete active_map_group_handle_;
  }
  active_map_group_handle_ = NULL;
}
inline const ::Kinova::Api::Base::MapGroupHandle& Mapping::active_map_group_handle() const {
  const ::Kinova::Api::Base::MapGroupHandle* p = active_map_group_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Mapping.active_map_group_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MapGroupHandle*>(
      &::Kinova::Api::Base::_MapGroupHandle_default_instance_);
}
inline ::Kinova::Api::Base::MapGroupHandle* Mapping::release_active_map_group_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Mapping.active_map_group_handle)
  
  ::Kinova::Api::Base::MapGroupHandle* temp = active_map_group_handle_;
  active_map_group_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MapGroupHandle* Mapping::mutable_active_map_group_handle() {
  
  if (active_map_group_handle_ == NULL) {
    active_map_group_handle_ = new ::Kinova::Api::Base::MapGroupHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Mapping.active_map_group_handle)
  return active_map_group_handle_;
}
inline void Mapping::set_allocated_active_map_group_handle(::Kinova::Api::Base::MapGroupHandle* active_map_group_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete active_map_group_handle_;
  }
  if (active_map_group_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      active_map_group_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, active_map_group_handle, submessage_arena);
    }
    
  } else {
    
  }
  active_map_group_handle_ = active_map_group_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Mapping.active_map_group_handle)
}

// repeated .Kinova.Api.Base.MapGroupHandle map_group_handles = 5;
inline int Mapping::map_group_handles_size() const {
  return map_group_handles_.size();
}
inline void Mapping::clear_map_group_handles() {
  map_group_handles_.Clear();
}
inline const ::Kinova::Api::Base::MapGroupHandle& Mapping::map_group_handles(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Mapping.map_group_handles)
  return map_group_handles_.Get(index);
}
inline ::Kinova::Api::Base::MapGroupHandle* Mapping::mutable_map_group_handles(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Mapping.map_group_handles)
  return map_group_handles_.Mutable(index);
}
inline ::Kinova::Api::Base::MapGroupHandle* Mapping::add_map_group_handles() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.Mapping.map_group_handles)
  return map_group_handles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroupHandle >*
Mapping::mutable_map_group_handles() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.Mapping.map_group_handles)
  return &map_group_handles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapGroupHandle >&
Mapping::map_group_handles() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.Mapping.map_group_handles)
  return map_group_handles_;
}

// .Kinova.Api.Base.MapHandle active_map_handle = 6;
inline bool Mapping::has_active_map_handle() const {
  return this != internal_default_instance() && active_map_handle_ != NULL;
}
inline void Mapping::clear_active_map_handle() {
  if (GetArenaNoVirtual() == NULL && active_map_handle_ != NULL) {
    delete active_map_handle_;
  }
  active_map_handle_ = NULL;
}
inline const ::Kinova::Api::Base::MapHandle& Mapping::active_map_handle() const {
  const ::Kinova::Api::Base::MapHandle* p = active_map_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Mapping.active_map_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MapHandle*>(
      &::Kinova::Api::Base::_MapHandle_default_instance_);
}
inline ::Kinova::Api::Base::MapHandle* Mapping::release_active_map_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Mapping.active_map_handle)
  
  ::Kinova::Api::Base::MapHandle* temp = active_map_handle_;
  active_map_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MapHandle* Mapping::mutable_active_map_handle() {
  
  if (active_map_handle_ == NULL) {
    active_map_handle_ = new ::Kinova::Api::Base::MapHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Mapping.active_map_handle)
  return active_map_handle_;
}
inline void Mapping::set_allocated_active_map_handle(::Kinova::Api::Base::MapHandle* active_map_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete active_map_handle_;
  }
  if (active_map_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      active_map_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, active_map_handle, submessage_arena);
    }
    
  } else {
    
  }
  active_map_handle_ = active_map_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Mapping.active_map_handle)
}

// repeated .Kinova.Api.Base.MapHandle map_handles = 7;
inline int Mapping::map_handles_size() const {
  return map_handles_.size();
}
inline void Mapping::clear_map_handles() {
  map_handles_.Clear();
}
inline const ::Kinova::Api::Base::MapHandle& Mapping::map_handles(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Mapping.map_handles)
  return map_handles_.Get(index);
}
inline ::Kinova::Api::Base::MapHandle* Mapping::mutable_map_handles(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Mapping.map_handles)
  return map_handles_.Mutable(index);
}
inline ::Kinova::Api::Base::MapHandle* Mapping::add_map_handles() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.Mapping.map_handles)
  return map_handles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapHandle >*
Mapping::mutable_map_handles() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.Mapping.map_handles)
  return &map_handles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::MapHandle >&
Mapping::map_handles() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.Mapping.map_handles)
  return map_handles_;
}

// string application_data = 8;
inline void Mapping::clear_application_data() {
  application_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mapping::application_data() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Mapping.application_data)
  return application_data_.GetNoArena();
}
inline void Mapping::set_application_data(const ::std::string& value) {
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Mapping.application_data)
}
#if LANG_CXX11
inline void Mapping::set_application_data(::std::string&& value) {
  
  application_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.Mapping.application_data)
}
#endif
inline void Mapping::set_application_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.Mapping.application_data)
}
inline void Mapping::set_application_data(const char* value, size_t size) {
  
  application_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.Mapping.application_data)
}
inline ::std::string* Mapping::mutable_application_data() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Mapping.application_data)
  return application_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mapping::release_application_data() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Mapping.application_data)
  
  return application_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mapping::set_allocated_application_data(::std::string* application_data) {
  if (application_data != NULL) {
    
  } else {
    
  }
  application_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), application_data);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Mapping.application_data)
}

// -------------------------------------------------------------------

// MappingList

// repeated .Kinova.Api.Base.Mapping mappings = 1;
inline int MappingList::mappings_size() const {
  return mappings_.size();
}
inline void MappingList::clear_mappings() {
  mappings_.Clear();
}
inline const ::Kinova::Api::Base::Mapping& MappingList::mappings(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.MappingList.mappings)
  return mappings_.Get(index);
}
inline ::Kinova::Api::Base::Mapping* MappingList::mutable_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.MappingList.mappings)
  return mappings_.Mutable(index);
}
inline ::Kinova::Api::Base::Mapping* MappingList::add_mappings() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.MappingList.mappings)
  return mappings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Mapping >*
MappingList::mutable_mappings() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.MappingList.mappings)
  return &mappings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Mapping >&
MappingList::mappings() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.MappingList.mappings)
  return mappings_;
}

// -------------------------------------------------------------------

// TransformationMatrix

// .Kinova.Api.Base.TransformationRow r0 = 1;
inline bool TransformationMatrix::has_r0() const {
  return this != internal_default_instance() && r0_ != NULL;
}
inline void TransformationMatrix::clear_r0() {
  if (GetArenaNoVirtual() == NULL && r0_ != NULL) {
    delete r0_;
  }
  r0_ = NULL;
}
inline const ::Kinova::Api::Base::TransformationRow& TransformationMatrix::r0() const {
  const ::Kinova::Api::Base::TransformationRow* p = r0_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TransformationMatrix.r0)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::TransformationRow*>(
      &::Kinova::Api::Base::_TransformationRow_default_instance_);
}
inline ::Kinova::Api::Base::TransformationRow* TransformationMatrix::release_r0() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.TransformationMatrix.r0)
  
  ::Kinova::Api::Base::TransformationRow* temp = r0_;
  r0_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::TransformationRow* TransformationMatrix::mutable_r0() {
  
  if (r0_ == NULL) {
    r0_ = new ::Kinova::Api::Base::TransformationRow;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.TransformationMatrix.r0)
  return r0_;
}
inline void TransformationMatrix::set_allocated_r0(::Kinova::Api::Base::TransformationRow* r0) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete r0_;
  }
  if (r0) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      r0 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, r0, submessage_arena);
    }
    
  } else {
    
  }
  r0_ = r0;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.TransformationMatrix.r0)
}

// .Kinova.Api.Base.TransformationRow r1 = 2;
inline bool TransformationMatrix::has_r1() const {
  return this != internal_default_instance() && r1_ != NULL;
}
inline void TransformationMatrix::clear_r1() {
  if (GetArenaNoVirtual() == NULL && r1_ != NULL) {
    delete r1_;
  }
  r1_ = NULL;
}
inline const ::Kinova::Api::Base::TransformationRow& TransformationMatrix::r1() const {
  const ::Kinova::Api::Base::TransformationRow* p = r1_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TransformationMatrix.r1)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::TransformationRow*>(
      &::Kinova::Api::Base::_TransformationRow_default_instance_);
}
inline ::Kinova::Api::Base::TransformationRow* TransformationMatrix::release_r1() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.TransformationMatrix.r1)
  
  ::Kinova::Api::Base::TransformationRow* temp = r1_;
  r1_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::TransformationRow* TransformationMatrix::mutable_r1() {
  
  if (r1_ == NULL) {
    r1_ = new ::Kinova::Api::Base::TransformationRow;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.TransformationMatrix.r1)
  return r1_;
}
inline void TransformationMatrix::set_allocated_r1(::Kinova::Api::Base::TransformationRow* r1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete r1_;
  }
  if (r1) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      r1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, r1, submessage_arena);
    }
    
  } else {
    
  }
  r1_ = r1;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.TransformationMatrix.r1)
}

// .Kinova.Api.Base.TransformationRow r2 = 3;
inline bool TransformationMatrix::has_r2() const {
  return this != internal_default_instance() && r2_ != NULL;
}
inline void TransformationMatrix::clear_r2() {
  if (GetArenaNoVirtual() == NULL && r2_ != NULL) {
    delete r2_;
  }
  r2_ = NULL;
}
inline const ::Kinova::Api::Base::TransformationRow& TransformationMatrix::r2() const {
  const ::Kinova::Api::Base::TransformationRow* p = r2_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TransformationMatrix.r2)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::TransformationRow*>(
      &::Kinova::Api::Base::_TransformationRow_default_instance_);
}
inline ::Kinova::Api::Base::TransformationRow* TransformationMatrix::release_r2() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.TransformationMatrix.r2)
  
  ::Kinova::Api::Base::TransformationRow* temp = r2_;
  r2_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::TransformationRow* TransformationMatrix::mutable_r2() {
  
  if (r2_ == NULL) {
    r2_ = new ::Kinova::Api::Base::TransformationRow;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.TransformationMatrix.r2)
  return r2_;
}
inline void TransformationMatrix::set_allocated_r2(::Kinova::Api::Base::TransformationRow* r2) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete r2_;
  }
  if (r2) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      r2 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, r2, submessage_arena);
    }
    
  } else {
    
  }
  r2_ = r2;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.TransformationMatrix.r2)
}

// .Kinova.Api.Base.TransformationRow r3 = 4;
inline bool TransformationMatrix::has_r3() const {
  return this != internal_default_instance() && r3_ != NULL;
}
inline void TransformationMatrix::clear_r3() {
  if (GetArenaNoVirtual() == NULL && r3_ != NULL) {
    delete r3_;
  }
  r3_ = NULL;
}
inline const ::Kinova::Api::Base::TransformationRow& TransformationMatrix::r3() const {
  const ::Kinova::Api::Base::TransformationRow* p = r3_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TransformationMatrix.r3)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::TransformationRow*>(
      &::Kinova::Api::Base::_TransformationRow_default_instance_);
}
inline ::Kinova::Api::Base::TransformationRow* TransformationMatrix::release_r3() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.TransformationMatrix.r3)
  
  ::Kinova::Api::Base::TransformationRow* temp = r3_;
  r3_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::TransformationRow* TransformationMatrix::mutable_r3() {
  
  if (r3_ == NULL) {
    r3_ = new ::Kinova::Api::Base::TransformationRow;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.TransformationMatrix.r3)
  return r3_;
}
inline void TransformationMatrix::set_allocated_r3(::Kinova::Api::Base::TransformationRow* r3) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete r3_;
  }
  if (r3) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      r3 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, r3, submessage_arena);
    }
    
  } else {
    
  }
  r3_ = r3;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.TransformationMatrix.r3)
}

// -------------------------------------------------------------------

// TransformationRow

// float c0 = 1;
inline void TransformationRow::clear_c0() {
  c0_ = 0;
}
inline float TransformationRow::c0() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TransformationRow.c0)
  return c0_;
}
inline void TransformationRow::set_c0(float value) {
  
  c0_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TransformationRow.c0)
}

// float c1 = 2;
inline void TransformationRow::clear_c1() {
  c1_ = 0;
}
inline float TransformationRow::c1() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TransformationRow.c1)
  return c1_;
}
inline void TransformationRow::set_c1(float value) {
  
  c1_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TransformationRow.c1)
}

// float c2 = 3;
inline void TransformationRow::clear_c2() {
  c2_ = 0;
}
inline float TransformationRow::c2() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TransformationRow.c2)
  return c2_;
}
inline void TransformationRow::set_c2(float value) {
  
  c2_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TransformationRow.c2)
}

// float c3 = 4;
inline void TransformationRow::clear_c3() {
  c3_ = 0;
}
inline float TransformationRow::c3() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TransformationRow.c3)
  return c3_;
}
inline void TransformationRow::set_c3(float value) {
  
  c3_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TransformationRow.c3)
}

// -------------------------------------------------------------------

// Pose

// float x = 1;
inline void Pose::clear_x() {
  x_ = 0;
}
inline float Pose::x() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Pose.x)
  return x_;
}
inline void Pose::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Pose.x)
}

// float y = 2;
inline void Pose::clear_y() {
  y_ = 0;
}
inline float Pose::y() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Pose.y)
  return y_;
}
inline void Pose::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Pose.y)
}

// float z = 3;
inline void Pose::clear_z() {
  z_ = 0;
}
inline float Pose::z() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Pose.z)
  return z_;
}
inline void Pose::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Pose.z)
}

// float theta_x = 4;
inline void Pose::clear_theta_x() {
  theta_x_ = 0;
}
inline float Pose::theta_x() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Pose.theta_x)
  return theta_x_;
}
inline void Pose::set_theta_x(float value) {
  
  theta_x_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Pose.theta_x)
}

// float theta_y = 5;
inline void Pose::clear_theta_y() {
  theta_y_ = 0;
}
inline float Pose::theta_y() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Pose.theta_y)
  return theta_y_;
}
inline void Pose::set_theta_y(float value) {
  
  theta_y_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Pose.theta_y)
}

// float theta_z = 6;
inline void Pose::clear_theta_z() {
  theta_z_ = 0;
}
inline float Pose::theta_z() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Pose.theta_z)
  return theta_z_;
}
inline void Pose::set_theta_z(float value) {
  
  theta_z_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Pose.theta_z)
}

// -------------------------------------------------------------------

// Position

// float x = 1;
inline void Position::clear_x() {
  x_ = 0;
}
inline float Position::x() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Position.x)
  return x_;
}
inline void Position::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Position.x)
}

// float y = 2;
inline void Position::clear_y() {
  y_ = 0;
}
inline float Position::y() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Position.y)
  return y_;
}
inline void Position::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Position.y)
}

// float z = 3;
inline void Position::clear_z() {
  z_ = 0;
}
inline float Position::z() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Position.z)
  return z_;
}
inline void Position::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Position.z)
}

// -------------------------------------------------------------------

// Orientation

// float theta_x = 1;
inline void Orientation::clear_theta_x() {
  theta_x_ = 0;
}
inline float Orientation::theta_x() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Orientation.theta_x)
  return theta_x_;
}
inline void Orientation::set_theta_x(float value) {
  
  theta_x_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Orientation.theta_x)
}

// float theta_y = 2;
inline void Orientation::clear_theta_y() {
  theta_y_ = 0;
}
inline float Orientation::theta_y() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Orientation.theta_y)
  return theta_y_;
}
inline void Orientation::set_theta_y(float value) {
  
  theta_y_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Orientation.theta_y)
}

// float theta_z = 3;
inline void Orientation::clear_theta_z() {
  theta_z_ = 0;
}
inline float Orientation::theta_z() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Orientation.theta_z)
  return theta_z_;
}
inline void Orientation::set_theta_z(float value) {
  
  theta_z_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Orientation.theta_z)
}

// -------------------------------------------------------------------

// CartesianSpeed

// float translation = 1;
inline void CartesianSpeed::clear_translation() {
  translation_ = 0;
}
inline float CartesianSpeed::translation() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CartesianSpeed.translation)
  return translation_;
}
inline void CartesianSpeed::set_translation(float value) {
  
  translation_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CartesianSpeed.translation)
}

// float orientation = 2;
inline void CartesianSpeed::clear_orientation() {
  orientation_ = 0;
}
inline float CartesianSpeed::orientation() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CartesianSpeed.orientation)
  return orientation_;
}
inline void CartesianSpeed::set_orientation(float value) {
  
  orientation_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CartesianSpeed.orientation)
}

// -------------------------------------------------------------------

// CartesianTrajectoryConstraint

// .Kinova.Api.Base.CartesianSpeed speed = 1;
inline bool CartesianTrajectoryConstraint::has_speed() const {
  return type_case() == kSpeed;
}
inline void CartesianTrajectoryConstraint::set_has_speed() {
  _oneof_case_[0] = kSpeed;
}
inline void CartesianTrajectoryConstraint::clear_speed() {
  if (has_speed()) {
    delete type_.speed_;
    clear_has_type();
  }
}
inline ::Kinova::Api::Base::CartesianSpeed* CartesianTrajectoryConstraint::release_speed() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.CartesianTrajectoryConstraint.speed)
  if (has_speed()) {
    clear_has_type();
      ::Kinova::Api::Base::CartesianSpeed* temp = type_.speed_;
    type_.speed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::CartesianSpeed& CartesianTrajectoryConstraint::speed() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CartesianTrajectoryConstraint.speed)
  return has_speed()
      ? *type_.speed_
      : *reinterpret_cast< ::Kinova::Api::Base::CartesianSpeed*>(&::Kinova::Api::Base::_CartesianSpeed_default_instance_);
}
inline ::Kinova::Api::Base::CartesianSpeed* CartesianTrajectoryConstraint::mutable_speed() {
  if (!has_speed()) {
    clear_type();
    set_has_speed();
    type_.speed_ = new ::Kinova::Api::Base::CartesianSpeed;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.CartesianTrajectoryConstraint.speed)
  return type_.speed_;
}

// float duration = 2;
inline bool CartesianTrajectoryConstraint::has_duration() const {
  return type_case() == kDuration;
}
inline void CartesianTrajectoryConstraint::set_has_duration() {
  _oneof_case_[0] = kDuration;
}
inline void CartesianTrajectoryConstraint::clear_duration() {
  if (has_duration()) {
    type_.duration_ = 0;
    clear_has_type();
  }
}
inline float CartesianTrajectoryConstraint::duration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CartesianTrajectoryConstraint.duration)
  if (has_duration()) {
    return type_.duration_;
  }
  return 0;
}
inline void CartesianTrajectoryConstraint::set_duration(float value) {
  if (!has_duration()) {
    clear_type();
    set_has_duration();
  }
  type_.duration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CartesianTrajectoryConstraint.duration)
}

inline bool CartesianTrajectoryConstraint::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void CartesianTrajectoryConstraint::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline CartesianTrajectoryConstraint::TypeCase CartesianTrajectoryConstraint::type_case() const {
  return CartesianTrajectoryConstraint::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// JointTrajectoryConstraint

// .Kinova.Api.Base.JointTrajectoryConstraintType type = 1;
inline void JointTrajectoryConstraint::clear_type() {
  type_ = 0;
}
inline ::Kinova::Api::Base::JointTrajectoryConstraintType JointTrajectoryConstraint::type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointTrajectoryConstraint.type)
  return static_cast< ::Kinova::Api::Base::JointTrajectoryConstraintType >(type_);
}
inline void JointTrajectoryConstraint::set_type(::Kinova::Api::Base::JointTrajectoryConstraintType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointTrajectoryConstraint.type)
}

// float value = 2;
inline void JointTrajectoryConstraint::clear_value() {
  value_ = 0;
}
inline float JointTrajectoryConstraint::value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointTrajectoryConstraint.value)
  return value_;
}
inline void JointTrajectoryConstraint::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointTrajectoryConstraint.value)
}

// -------------------------------------------------------------------

// Wrench

// float force_x = 1;
inline void Wrench::clear_force_x() {
  force_x_ = 0;
}
inline float Wrench::force_x() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Wrench.force_x)
  return force_x_;
}
inline void Wrench::set_force_x(float value) {
  
  force_x_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Wrench.force_x)
}

// float force_y = 2;
inline void Wrench::clear_force_y() {
  force_y_ = 0;
}
inline float Wrench::force_y() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Wrench.force_y)
  return force_y_;
}
inline void Wrench::set_force_y(float value) {
  
  force_y_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Wrench.force_y)
}

// float force_z = 3;
inline void Wrench::clear_force_z() {
  force_z_ = 0;
}
inline float Wrench::force_z() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Wrench.force_z)
  return force_z_;
}
inline void Wrench::set_force_z(float value) {
  
  force_z_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Wrench.force_z)
}

// float torque_x = 4;
inline void Wrench::clear_torque_x() {
  torque_x_ = 0;
}
inline float Wrench::torque_x() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Wrench.torque_x)
  return torque_x_;
}
inline void Wrench::set_torque_x(float value) {
  
  torque_x_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Wrench.torque_x)
}

// float torque_y = 5;
inline void Wrench::clear_torque_y() {
  torque_y_ = 0;
}
inline float Wrench::torque_y() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Wrench.torque_y)
  return torque_y_;
}
inline void Wrench::set_torque_y(float value) {
  
  torque_y_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Wrench.torque_y)
}

// float torque_z = 6;
inline void Wrench::clear_torque_z() {
  torque_z_ = 0;
}
inline float Wrench::torque_z() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Wrench.torque_z)
  return torque_z_;
}
inline void Wrench::set_torque_z(float value) {
  
  torque_z_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Wrench.torque_z)
}

// -------------------------------------------------------------------

// Twist

// float linear_x = 1;
inline void Twist::clear_linear_x() {
  linear_x_ = 0;
}
inline float Twist::linear_x() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Twist.linear_x)
  return linear_x_;
}
inline void Twist::set_linear_x(float value) {
  
  linear_x_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Twist.linear_x)
}

// float linear_y = 2;
inline void Twist::clear_linear_y() {
  linear_y_ = 0;
}
inline float Twist::linear_y() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Twist.linear_y)
  return linear_y_;
}
inline void Twist::set_linear_y(float value) {
  
  linear_y_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Twist.linear_y)
}

// float linear_z = 3;
inline void Twist::clear_linear_z() {
  linear_z_ = 0;
}
inline float Twist::linear_z() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Twist.linear_z)
  return linear_z_;
}
inline void Twist::set_linear_z(float value) {
  
  linear_z_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Twist.linear_z)
}

// float angular_x = 4;
inline void Twist::clear_angular_x() {
  angular_x_ = 0;
}
inline float Twist::angular_x() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Twist.angular_x)
  return angular_x_;
}
inline void Twist::set_angular_x(float value) {
  
  angular_x_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Twist.angular_x)
}

// float angular_y = 5;
inline void Twist::clear_angular_y() {
  angular_y_ = 0;
}
inline float Twist::angular_y() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Twist.angular_y)
  return angular_y_;
}
inline void Twist::set_angular_y(float value) {
  
  angular_y_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Twist.angular_y)
}

// float angular_z = 6;
inline void Twist::clear_angular_z() {
  angular_z_ = 0;
}
inline float Twist::angular_z() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Twist.angular_z)
  return angular_z_;
}
inline void Twist::set_angular_z(float value) {
  
  angular_z_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Twist.angular_z)
}

// -------------------------------------------------------------------

// Admittance

// .Kinova.Api.Base.AdmittanceMode admittance_mode = 1;
inline void Admittance::clear_admittance_mode() {
  admittance_mode_ = 0;
}
inline ::Kinova::Api::Base::AdmittanceMode Admittance::admittance_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Admittance.admittance_mode)
  return static_cast< ::Kinova::Api::Base::AdmittanceMode >(admittance_mode_);
}
inline void Admittance::set_admittance_mode(::Kinova::Api::Base::AdmittanceMode value) {
  
  admittance_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Admittance.admittance_mode)
}

// -------------------------------------------------------------------

// ConstrainedPose

// .Kinova.Api.Base.Pose target_pose = 1;
inline bool ConstrainedPose::has_target_pose() const {
  return this != internal_default_instance() && target_pose_ != NULL;
}
inline void ConstrainedPose::clear_target_pose() {
  if (GetArenaNoVirtual() == NULL && target_pose_ != NULL) {
    delete target_pose_;
  }
  target_pose_ = NULL;
}
inline const ::Kinova::Api::Base::Pose& ConstrainedPose::target_pose() const {
  const ::Kinova::Api::Base::Pose* p = target_pose_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConstrainedPose.target_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::Pose*>(
      &::Kinova::Api::Base::_Pose_default_instance_);
}
inline ::Kinova::Api::Base::Pose* ConstrainedPose::release_target_pose() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConstrainedPose.target_pose)
  
  ::Kinova::Api::Base::Pose* temp = target_pose_;
  target_pose_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::Pose* ConstrainedPose::mutable_target_pose() {
  
  if (target_pose_ == NULL) {
    target_pose_ = new ::Kinova::Api::Base::Pose;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConstrainedPose.target_pose)
  return target_pose_;
}
inline void ConstrainedPose::set_allocated_target_pose(::Kinova::Api::Base::Pose* target_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete target_pose_;
  }
  if (target_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      target_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, target_pose, submessage_arena);
    }
    
  } else {
    
  }
  target_pose_ = target_pose;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ConstrainedPose.target_pose)
}

// .Kinova.Api.Base.CartesianTrajectoryConstraint constraint = 2;
inline bool ConstrainedPose::has_constraint() const {
  return this != internal_default_instance() && constraint_ != NULL;
}
inline void ConstrainedPose::clear_constraint() {
  if (GetArenaNoVirtual() == NULL && constraint_ != NULL) {
    delete constraint_;
  }
  constraint_ = NULL;
}
inline const ::Kinova::Api::Base::CartesianTrajectoryConstraint& ConstrainedPose::constraint() const {
  const ::Kinova::Api::Base::CartesianTrajectoryConstraint* p = constraint_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConstrainedPose.constraint)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::CartesianTrajectoryConstraint*>(
      &::Kinova::Api::Base::_CartesianTrajectoryConstraint_default_instance_);
}
inline ::Kinova::Api::Base::CartesianTrajectoryConstraint* ConstrainedPose::release_constraint() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConstrainedPose.constraint)
  
  ::Kinova::Api::Base::CartesianTrajectoryConstraint* temp = constraint_;
  constraint_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::CartesianTrajectoryConstraint* ConstrainedPose::mutable_constraint() {
  
  if (constraint_ == NULL) {
    constraint_ = new ::Kinova::Api::Base::CartesianTrajectoryConstraint;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConstrainedPose.constraint)
  return constraint_;
}
inline void ConstrainedPose::set_allocated_constraint(::Kinova::Api::Base::CartesianTrajectoryConstraint* constraint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete constraint_;
  }
  if (constraint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      constraint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, constraint, submessage_arena);
    }
    
  } else {
    
  }
  constraint_ = constraint;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ConstrainedPose.constraint)
}

// -------------------------------------------------------------------

// ConstrainedPosition

// .Kinova.Api.Base.Position target_position = 1;
inline bool ConstrainedPosition::has_target_position() const {
  return this != internal_default_instance() && target_position_ != NULL;
}
inline void ConstrainedPosition::clear_target_position() {
  if (GetArenaNoVirtual() == NULL && target_position_ != NULL) {
    delete target_position_;
  }
  target_position_ = NULL;
}
inline const ::Kinova::Api::Base::Position& ConstrainedPosition::target_position() const {
  const ::Kinova::Api::Base::Position* p = target_position_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConstrainedPosition.target_position)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::Position*>(
      &::Kinova::Api::Base::_Position_default_instance_);
}
inline ::Kinova::Api::Base::Position* ConstrainedPosition::release_target_position() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConstrainedPosition.target_position)
  
  ::Kinova::Api::Base::Position* temp = target_position_;
  target_position_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::Position* ConstrainedPosition::mutable_target_position() {
  
  if (target_position_ == NULL) {
    target_position_ = new ::Kinova::Api::Base::Position;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConstrainedPosition.target_position)
  return target_position_;
}
inline void ConstrainedPosition::set_allocated_target_position(::Kinova::Api::Base::Position* target_position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete target_position_;
  }
  if (target_position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      target_position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, target_position, submessage_arena);
    }
    
  } else {
    
  }
  target_position_ = target_position;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ConstrainedPosition.target_position)
}

// .Kinova.Api.Base.CartesianTrajectoryConstraint constraint = 2;
inline bool ConstrainedPosition::has_constraint() const {
  return this != internal_default_instance() && constraint_ != NULL;
}
inline void ConstrainedPosition::clear_constraint() {
  if (GetArenaNoVirtual() == NULL && constraint_ != NULL) {
    delete constraint_;
  }
  constraint_ = NULL;
}
inline const ::Kinova::Api::Base::CartesianTrajectoryConstraint& ConstrainedPosition::constraint() const {
  const ::Kinova::Api::Base::CartesianTrajectoryConstraint* p = constraint_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConstrainedPosition.constraint)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::CartesianTrajectoryConstraint*>(
      &::Kinova::Api::Base::_CartesianTrajectoryConstraint_default_instance_);
}
inline ::Kinova::Api::Base::CartesianTrajectoryConstraint* ConstrainedPosition::release_constraint() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConstrainedPosition.constraint)
  
  ::Kinova::Api::Base::CartesianTrajectoryConstraint* temp = constraint_;
  constraint_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::CartesianTrajectoryConstraint* ConstrainedPosition::mutable_constraint() {
  
  if (constraint_ == NULL) {
    constraint_ = new ::Kinova::Api::Base::CartesianTrajectoryConstraint;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConstrainedPosition.constraint)
  return constraint_;
}
inline void ConstrainedPosition::set_allocated_constraint(::Kinova::Api::Base::CartesianTrajectoryConstraint* constraint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete constraint_;
  }
  if (constraint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      constraint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, constraint, submessage_arena);
    }
    
  } else {
    
  }
  constraint_ = constraint;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ConstrainedPosition.constraint)
}

// -------------------------------------------------------------------

// ConstrainedOrientation

// .Kinova.Api.Base.Orientation target_orientation = 1;
inline bool ConstrainedOrientation::has_target_orientation() const {
  return this != internal_default_instance() && target_orientation_ != NULL;
}
inline void ConstrainedOrientation::clear_target_orientation() {
  if (GetArenaNoVirtual() == NULL && target_orientation_ != NULL) {
    delete target_orientation_;
  }
  target_orientation_ = NULL;
}
inline const ::Kinova::Api::Base::Orientation& ConstrainedOrientation::target_orientation() const {
  const ::Kinova::Api::Base::Orientation* p = target_orientation_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConstrainedOrientation.target_orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::Orientation*>(
      &::Kinova::Api::Base::_Orientation_default_instance_);
}
inline ::Kinova::Api::Base::Orientation* ConstrainedOrientation::release_target_orientation() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConstrainedOrientation.target_orientation)
  
  ::Kinova::Api::Base::Orientation* temp = target_orientation_;
  target_orientation_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::Orientation* ConstrainedOrientation::mutable_target_orientation() {
  
  if (target_orientation_ == NULL) {
    target_orientation_ = new ::Kinova::Api::Base::Orientation;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConstrainedOrientation.target_orientation)
  return target_orientation_;
}
inline void ConstrainedOrientation::set_allocated_target_orientation(::Kinova::Api::Base::Orientation* target_orientation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete target_orientation_;
  }
  if (target_orientation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      target_orientation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, target_orientation, submessage_arena);
    }
    
  } else {
    
  }
  target_orientation_ = target_orientation;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ConstrainedOrientation.target_orientation)
}

// .Kinova.Api.Base.CartesianTrajectoryConstraint constraint = 2;
inline bool ConstrainedOrientation::has_constraint() const {
  return this != internal_default_instance() && constraint_ != NULL;
}
inline void ConstrainedOrientation::clear_constraint() {
  if (GetArenaNoVirtual() == NULL && constraint_ != NULL) {
    delete constraint_;
  }
  constraint_ = NULL;
}
inline const ::Kinova::Api::Base::CartesianTrajectoryConstraint& ConstrainedOrientation::constraint() const {
  const ::Kinova::Api::Base::CartesianTrajectoryConstraint* p = constraint_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConstrainedOrientation.constraint)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::CartesianTrajectoryConstraint*>(
      &::Kinova::Api::Base::_CartesianTrajectoryConstraint_default_instance_);
}
inline ::Kinova::Api::Base::CartesianTrajectoryConstraint* ConstrainedOrientation::release_constraint() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConstrainedOrientation.constraint)
  
  ::Kinova::Api::Base::CartesianTrajectoryConstraint* temp = constraint_;
  constraint_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::CartesianTrajectoryConstraint* ConstrainedOrientation::mutable_constraint() {
  
  if (constraint_ == NULL) {
    constraint_ = new ::Kinova::Api::Base::CartesianTrajectoryConstraint;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConstrainedOrientation.constraint)
  return constraint_;
}
inline void ConstrainedOrientation::set_allocated_constraint(::Kinova::Api::Base::CartesianTrajectoryConstraint* constraint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete constraint_;
  }
  if (constraint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      constraint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, constraint, submessage_arena);
    }
    
  } else {
    
  }
  constraint_ = constraint;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ConstrainedOrientation.constraint)
}

// -------------------------------------------------------------------

// WrenchCommand

// .Kinova.Api.Common.CartesianReferenceFrame reference_frame = 1;
inline void WrenchCommand::clear_reference_frame() {
  reference_frame_ = 0;
}
inline ::Kinova::Api::Common::CartesianReferenceFrame WrenchCommand::reference_frame() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WrenchCommand.reference_frame)
  return static_cast< ::Kinova::Api::Common::CartesianReferenceFrame >(reference_frame_);
}
inline void WrenchCommand::set_reference_frame(::Kinova::Api::Common::CartesianReferenceFrame value) {
  
  reference_frame_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WrenchCommand.reference_frame)
}

// .Kinova.Api.Base.WrenchMode mode = 2;
inline void WrenchCommand::clear_mode() {
  mode_ = 0;
}
inline ::Kinova::Api::Base::WrenchMode WrenchCommand::mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WrenchCommand.mode)
  return static_cast< ::Kinova::Api::Base::WrenchMode >(mode_);
}
inline void WrenchCommand::set_mode(::Kinova::Api::Base::WrenchMode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WrenchCommand.mode)
}

// .Kinova.Api.Base.Wrench wrench = 3;
inline bool WrenchCommand::has_wrench() const {
  return this != internal_default_instance() && wrench_ != NULL;
}
inline void WrenchCommand::clear_wrench() {
  if (GetArenaNoVirtual() == NULL && wrench_ != NULL) {
    delete wrench_;
  }
  wrench_ = NULL;
}
inline const ::Kinova::Api::Base::Wrench& WrenchCommand::wrench() const {
  const ::Kinova::Api::Base::Wrench* p = wrench_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WrenchCommand.wrench)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::Wrench*>(
      &::Kinova::Api::Base::_Wrench_default_instance_);
}
inline ::Kinova::Api::Base::Wrench* WrenchCommand::release_wrench() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.WrenchCommand.wrench)
  
  ::Kinova::Api::Base::Wrench* temp = wrench_;
  wrench_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::Wrench* WrenchCommand::mutable_wrench() {
  
  if (wrench_ == NULL) {
    wrench_ = new ::Kinova::Api::Base::Wrench;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.WrenchCommand.wrench)
  return wrench_;
}
inline void WrenchCommand::set_allocated_wrench(::Kinova::Api::Base::Wrench* wrench) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete wrench_;
  }
  if (wrench) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wrench = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wrench, submessage_arena);
    }
    
  } else {
    
  }
  wrench_ = wrench;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.WrenchCommand.wrench)
}

// uint32 duration = 4;
inline void WrenchCommand::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 WrenchCommand::duration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WrenchCommand.duration)
  return duration_;
}
inline void WrenchCommand::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WrenchCommand.duration)
}

// -------------------------------------------------------------------

// TwistCommand

// .Kinova.Api.Common.CartesianReferenceFrame reference_frame = 1;
inline void TwistCommand::clear_reference_frame() {
  reference_frame_ = 0;
}
inline ::Kinova::Api::Common::CartesianReferenceFrame TwistCommand::reference_frame() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TwistCommand.reference_frame)
  return static_cast< ::Kinova::Api::Common::CartesianReferenceFrame >(reference_frame_);
}
inline void TwistCommand::set_reference_frame(::Kinova::Api::Common::CartesianReferenceFrame value) {
  
  reference_frame_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TwistCommand.reference_frame)
}

// .Kinova.Api.Base.Twist twist = 2;
inline bool TwistCommand::has_twist() const {
  return this != internal_default_instance() && twist_ != NULL;
}
inline void TwistCommand::clear_twist() {
  if (GetArenaNoVirtual() == NULL && twist_ != NULL) {
    delete twist_;
  }
  twist_ = NULL;
}
inline const ::Kinova::Api::Base::Twist& TwistCommand::twist() const {
  const ::Kinova::Api::Base::Twist* p = twist_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TwistCommand.twist)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::Twist*>(
      &::Kinova::Api::Base::_Twist_default_instance_);
}
inline ::Kinova::Api::Base::Twist* TwistCommand::release_twist() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.TwistCommand.twist)
  
  ::Kinova::Api::Base::Twist* temp = twist_;
  twist_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::Twist* TwistCommand::mutable_twist() {
  
  if (twist_ == NULL) {
    twist_ = new ::Kinova::Api::Base::Twist;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.TwistCommand.twist)
  return twist_;
}
inline void TwistCommand::set_allocated_twist(::Kinova::Api::Base::Twist* twist) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete twist_;
  }
  if (twist) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      twist = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, twist, submessage_arena);
    }
    
  } else {
    
  }
  twist_ = twist;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.TwistCommand.twist)
}

// uint32 duration = 3;
inline void TwistCommand::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 TwistCommand::duration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TwistCommand.duration)
  return duration_;
}
inline void TwistCommand::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TwistCommand.duration)
}

// -------------------------------------------------------------------

// ConstrainedJointAngles

// .Kinova.Api.Base.JointAngles joint_angles = 1;
inline bool ConstrainedJointAngles::has_joint_angles() const {
  return this != internal_default_instance() && joint_angles_ != NULL;
}
inline void ConstrainedJointAngles::clear_joint_angles() {
  if (GetArenaNoVirtual() == NULL && joint_angles_ != NULL) {
    delete joint_angles_;
  }
  joint_angles_ = NULL;
}
inline const ::Kinova::Api::Base::JointAngles& ConstrainedJointAngles::joint_angles() const {
  const ::Kinova::Api::Base::JointAngles* p = joint_angles_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConstrainedJointAngles.joint_angles)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::JointAngles*>(
      &::Kinova::Api::Base::_JointAngles_default_instance_);
}
inline ::Kinova::Api::Base::JointAngles* ConstrainedJointAngles::release_joint_angles() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConstrainedJointAngles.joint_angles)
  
  ::Kinova::Api::Base::JointAngles* temp = joint_angles_;
  joint_angles_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::JointAngles* ConstrainedJointAngles::mutable_joint_angles() {
  
  if (joint_angles_ == NULL) {
    joint_angles_ = new ::Kinova::Api::Base::JointAngles;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConstrainedJointAngles.joint_angles)
  return joint_angles_;
}
inline void ConstrainedJointAngles::set_allocated_joint_angles(::Kinova::Api::Base::JointAngles* joint_angles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete joint_angles_;
  }
  if (joint_angles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      joint_angles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, joint_angles, submessage_arena);
    }
    
  } else {
    
  }
  joint_angles_ = joint_angles;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ConstrainedJointAngles.joint_angles)
}

// .Kinova.Api.Base.JointTrajectoryConstraint constraint = 2;
inline bool ConstrainedJointAngles::has_constraint() const {
  return this != internal_default_instance() && constraint_ != NULL;
}
inline void ConstrainedJointAngles::clear_constraint() {
  if (GetArenaNoVirtual() == NULL && constraint_ != NULL) {
    delete constraint_;
  }
  constraint_ = NULL;
}
inline const ::Kinova::Api::Base::JointTrajectoryConstraint& ConstrainedJointAngles::constraint() const {
  const ::Kinova::Api::Base::JointTrajectoryConstraint* p = constraint_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConstrainedJointAngles.constraint)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::JointTrajectoryConstraint*>(
      &::Kinova::Api::Base::_JointTrajectoryConstraint_default_instance_);
}
inline ::Kinova::Api::Base::JointTrajectoryConstraint* ConstrainedJointAngles::release_constraint() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConstrainedJointAngles.constraint)
  
  ::Kinova::Api::Base::JointTrajectoryConstraint* temp = constraint_;
  constraint_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::JointTrajectoryConstraint* ConstrainedJointAngles::mutable_constraint() {
  
  if (constraint_ == NULL) {
    constraint_ = new ::Kinova::Api::Base::JointTrajectoryConstraint;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConstrainedJointAngles.constraint)
  return constraint_;
}
inline void ConstrainedJointAngles::set_allocated_constraint(::Kinova::Api::Base::JointTrajectoryConstraint* constraint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete constraint_;
  }
  if (constraint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      constraint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, constraint, submessage_arena);
    }
    
  } else {
    
  }
  constraint_ = constraint;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ConstrainedJointAngles.constraint)
}

// -------------------------------------------------------------------

// ConstrainedJointAngle

// uint32 joint_identifier = 1;
inline void ConstrainedJointAngle::clear_joint_identifier() {
  joint_identifier_ = 0u;
}
inline ::google::protobuf::uint32 ConstrainedJointAngle::joint_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConstrainedJointAngle.joint_identifier)
  return joint_identifier_;
}
inline void ConstrainedJointAngle::set_joint_identifier(::google::protobuf::uint32 value) {
  
  joint_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ConstrainedJointAngle.joint_identifier)
}

// float value = 2;
inline void ConstrainedJointAngle::clear_value() {
  value_ = 0;
}
inline float ConstrainedJointAngle::value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConstrainedJointAngle.value)
  return value_;
}
inline void ConstrainedJointAngle::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ConstrainedJointAngle.value)
}

// .Kinova.Api.Base.JointTrajectoryConstraint constraint = 3;
inline bool ConstrainedJointAngle::has_constraint() const {
  return this != internal_default_instance() && constraint_ != NULL;
}
inline void ConstrainedJointAngle::clear_constraint() {
  if (GetArenaNoVirtual() == NULL && constraint_ != NULL) {
    delete constraint_;
  }
  constraint_ = NULL;
}
inline const ::Kinova::Api::Base::JointTrajectoryConstraint& ConstrainedJointAngle::constraint() const {
  const ::Kinova::Api::Base::JointTrajectoryConstraint* p = constraint_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ConstrainedJointAngle.constraint)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::JointTrajectoryConstraint*>(
      &::Kinova::Api::Base::_JointTrajectoryConstraint_default_instance_);
}
inline ::Kinova::Api::Base::JointTrajectoryConstraint* ConstrainedJointAngle::release_constraint() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ConstrainedJointAngle.constraint)
  
  ::Kinova::Api::Base::JointTrajectoryConstraint* temp = constraint_;
  constraint_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::JointTrajectoryConstraint* ConstrainedJointAngle::mutable_constraint() {
  
  if (constraint_ == NULL) {
    constraint_ = new ::Kinova::Api::Base::JointTrajectoryConstraint;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ConstrainedJointAngle.constraint)
  return constraint_;
}
inline void ConstrainedJointAngle::set_allocated_constraint(::Kinova::Api::Base::JointTrajectoryConstraint* constraint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete constraint_;
  }
  if (constraint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      constraint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, constraint, submessage_arena);
    }
    
  } else {
    
  }
  constraint_ = constraint;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ConstrainedJointAngle.constraint)
}

// -------------------------------------------------------------------

// JointAngles

// repeated .Kinova.Api.Base.JointAngle joint_angles = 1;
inline int JointAngles::joint_angles_size() const {
  return joint_angles_.size();
}
inline void JointAngles::clear_joint_angles() {
  joint_angles_.Clear();
}
inline const ::Kinova::Api::Base::JointAngle& JointAngles::joint_angles(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointAngles.joint_angles)
  return joint_angles_.Get(index);
}
inline ::Kinova::Api::Base::JointAngle* JointAngles::mutable_joint_angles(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.JointAngles.joint_angles)
  return joint_angles_.Mutable(index);
}
inline ::Kinova::Api::Base::JointAngle* JointAngles::add_joint_angles() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.JointAngles.joint_angles)
  return joint_angles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointAngle >*
JointAngles::mutable_joint_angles() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.JointAngles.joint_angles)
  return &joint_angles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointAngle >&
JointAngles::joint_angles() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.JointAngles.joint_angles)
  return joint_angles_;
}

// -------------------------------------------------------------------

// JointAngle

// uint32 joint_identifier = 1;
inline void JointAngle::clear_joint_identifier() {
  joint_identifier_ = 0u;
}
inline ::google::protobuf::uint32 JointAngle::joint_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointAngle.joint_identifier)
  return joint_identifier_;
}
inline void JointAngle::set_joint_identifier(::google::protobuf::uint32 value) {
  
  joint_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointAngle.joint_identifier)
}

// float value = 2;
inline void JointAngle::clear_value() {
  value_ = 0;
}
inline float JointAngle::value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointAngle.value)
  return value_;
}
inline void JointAngle::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointAngle.value)
}

// -------------------------------------------------------------------

// JointSpeeds

// repeated .Kinova.Api.Base.JointSpeed joint_speeds = 1;
inline int JointSpeeds::joint_speeds_size() const {
  return joint_speeds_.size();
}
inline void JointSpeeds::clear_joint_speeds() {
  joint_speeds_.Clear();
}
inline const ::Kinova::Api::Base::JointSpeed& JointSpeeds::joint_speeds(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointSpeeds.joint_speeds)
  return joint_speeds_.Get(index);
}
inline ::Kinova::Api::Base::JointSpeed* JointSpeeds::mutable_joint_speeds(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.JointSpeeds.joint_speeds)
  return joint_speeds_.Mutable(index);
}
inline ::Kinova::Api::Base::JointSpeed* JointSpeeds::add_joint_speeds() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.JointSpeeds.joint_speeds)
  return joint_speeds_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointSpeed >*
JointSpeeds::mutable_joint_speeds() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.JointSpeeds.joint_speeds)
  return &joint_speeds_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointSpeed >&
JointSpeeds::joint_speeds() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.JointSpeeds.joint_speeds)
  return joint_speeds_;
}

// uint32 duration = 2;
inline void JointSpeeds::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 JointSpeeds::duration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointSpeeds.duration)
  return duration_;
}
inline void JointSpeeds::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointSpeeds.duration)
}

// -------------------------------------------------------------------

// JointSpeed

// uint32 joint_identifier = 1;
inline void JointSpeed::clear_joint_identifier() {
  joint_identifier_ = 0u;
}
inline ::google::protobuf::uint32 JointSpeed::joint_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointSpeed.joint_identifier)
  return joint_identifier_;
}
inline void JointSpeed::set_joint_identifier(::google::protobuf::uint32 value) {
  
  joint_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointSpeed.joint_identifier)
}

// float value = 2;
inline void JointSpeed::clear_value() {
  value_ = 0;
}
inline float JointSpeed::value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointSpeed.value)
  return value_;
}
inline void JointSpeed::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointSpeed.value)
}

// uint32 duration = 3;
inline void JointSpeed::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 JointSpeed::duration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointSpeed.duration)
  return duration_;
}
inline void JointSpeed::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointSpeed.duration)
}

// -------------------------------------------------------------------

// JointTorques

// repeated .Kinova.Api.Base.JointTorque joint_torques = 1;
inline int JointTorques::joint_torques_size() const {
  return joint_torques_.size();
}
inline void JointTorques::clear_joint_torques() {
  joint_torques_.Clear();
}
inline const ::Kinova::Api::Base::JointTorque& JointTorques::joint_torques(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointTorques.joint_torques)
  return joint_torques_.Get(index);
}
inline ::Kinova::Api::Base::JointTorque* JointTorques::mutable_joint_torques(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.JointTorques.joint_torques)
  return joint_torques_.Mutable(index);
}
inline ::Kinova::Api::Base::JointTorque* JointTorques::add_joint_torques() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.JointTorques.joint_torques)
  return joint_torques_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointTorque >*
JointTorques::mutable_joint_torques() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.JointTorques.joint_torques)
  return &joint_torques_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::JointTorque >&
JointTorques::joint_torques() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.JointTorques.joint_torques)
  return joint_torques_;
}

// uint32 duration = 2;
inline void JointTorques::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 JointTorques::duration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointTorques.duration)
  return duration_;
}
inline void JointTorques::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointTorques.duration)
}

// -------------------------------------------------------------------

// JointTorque

// uint32 joint_identifier = 1;
inline void JointTorque::clear_joint_identifier() {
  joint_identifier_ = 0u;
}
inline ::google::protobuf::uint32 JointTorque::joint_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointTorque.joint_identifier)
  return joint_identifier_;
}
inline void JointTorque::set_joint_identifier(::google::protobuf::uint32 value) {
  
  joint_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointTorque.joint_identifier)
}

// float value = 2;
inline void JointTorque::clear_value() {
  value_ = 0;
}
inline float JointTorque::value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointTorque.value)
  return value_;
}
inline void JointTorque::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointTorque.value)
}

// uint32 duration = 3;
inline void JointTorque::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 JointTorque::duration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.JointTorque.duration)
  return duration_;
}
inline void JointTorque::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.JointTorque.duration)
}

// -------------------------------------------------------------------

// GripperCommand

// .Kinova.Api.Base.GripperMode mode = 1;
inline void GripperCommand::clear_mode() {
  mode_ = 0;
}
inline ::Kinova::Api::Base::GripperMode GripperCommand::mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GripperCommand.mode)
  return static_cast< ::Kinova::Api::Base::GripperMode >(mode_);
}
inline void GripperCommand::set_mode(::Kinova::Api::Base::GripperMode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GripperCommand.mode)
}

// .Kinova.Api.Base.Gripper gripper = 2;
inline bool GripperCommand::has_gripper() const {
  return this != internal_default_instance() && gripper_ != NULL;
}
inline void GripperCommand::clear_gripper() {
  if (GetArenaNoVirtual() == NULL && gripper_ != NULL) {
    delete gripper_;
  }
  gripper_ = NULL;
}
inline const ::Kinova::Api::Base::Gripper& GripperCommand::gripper() const {
  const ::Kinova::Api::Base::Gripper* p = gripper_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GripperCommand.gripper)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::Gripper*>(
      &::Kinova::Api::Base::_Gripper_default_instance_);
}
inline ::Kinova::Api::Base::Gripper* GripperCommand::release_gripper() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.GripperCommand.gripper)
  
  ::Kinova::Api::Base::Gripper* temp = gripper_;
  gripper_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::Gripper* GripperCommand::mutable_gripper() {
  
  if (gripper_ == NULL) {
    gripper_ = new ::Kinova::Api::Base::Gripper;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.GripperCommand.gripper)
  return gripper_;
}
inline void GripperCommand::set_allocated_gripper(::Kinova::Api::Base::Gripper* gripper) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gripper_;
  }
  if (gripper) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gripper = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gripper, submessage_arena);
    }
    
  } else {
    
  }
  gripper_ = gripper;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.GripperCommand.gripper)
}

// uint32 duration = 3;
inline void GripperCommand::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 GripperCommand::duration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GripperCommand.duration)
  return duration_;
}
inline void GripperCommand::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GripperCommand.duration)
}

// -------------------------------------------------------------------

// GripperRequest

// .Kinova.Api.Base.GripperMode mode = 1;
inline void GripperRequest::clear_mode() {
  mode_ = 0;
}
inline ::Kinova::Api::Base::GripperMode GripperRequest::mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GripperRequest.mode)
  return static_cast< ::Kinova::Api::Base::GripperMode >(mode_);
}
inline void GripperRequest::set_mode(::Kinova::Api::Base::GripperMode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GripperRequest.mode)
}

// -------------------------------------------------------------------

// Gripper

// repeated .Kinova.Api.Base.Finger finger = 1;
inline int Gripper::finger_size() const {
  return finger_.size();
}
inline void Gripper::clear_finger() {
  finger_.Clear();
}
inline const ::Kinova::Api::Base::Finger& Gripper::finger(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Gripper.finger)
  return finger_.Get(index);
}
inline ::Kinova::Api::Base::Finger* Gripper::mutable_finger(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Gripper.finger)
  return finger_.Mutable(index);
}
inline ::Kinova::Api::Base::Finger* Gripper::add_finger() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.Gripper.finger)
  return finger_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Finger >*
Gripper::mutable_finger() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.Gripper.finger)
  return &finger_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Finger >&
Gripper::finger() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.Gripper.finger)
  return finger_;
}

// -------------------------------------------------------------------

// Finger

// uint32 finger_identifier = 1;
inline void Finger::clear_finger_identifier() {
  finger_identifier_ = 0u;
}
inline ::google::protobuf::uint32 Finger::finger_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Finger.finger_identifier)
  return finger_identifier_;
}
inline void Finger::set_finger_identifier(::google::protobuf::uint32 value) {
  
  finger_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Finger.finger_identifier)
}

// float value = 2;
inline void Finger::clear_value() {
  value_ = 0;
}
inline float Finger::value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Finger.value)
  return value_;
}
inline void Finger::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Finger.value)
}

// -------------------------------------------------------------------

// GpioCommand

// uint32 port_identifier = 1;
inline void GpioCommand::clear_port_identifier() {
  port_identifier_ = 0u;
}
inline ::google::protobuf::uint32 GpioCommand::port_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GpioCommand.port_identifier)
  return port_identifier_;
}
inline void GpioCommand::set_port_identifier(::google::protobuf::uint32 value) {
  
  port_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GpioCommand.port_identifier)
}

// uint32 pin_identifier = 2;
inline void GpioCommand::clear_pin_identifier() {
  pin_identifier_ = 0u;
}
inline ::google::protobuf::uint32 GpioCommand::pin_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GpioCommand.pin_identifier)
  return pin_identifier_;
}
inline void GpioCommand::set_pin_identifier(::google::protobuf::uint32 value) {
  
  pin_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GpioCommand.pin_identifier)
}

// .Kinova.Api.Base.GpioAction action = 3;
inline void GpioCommand::clear_action() {
  action_ = 0;
}
inline ::Kinova::Api::Base::GpioAction GpioCommand::action() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GpioCommand.action)
  return static_cast< ::Kinova::Api::Base::GpioAction >(action_);
}
inline void GpioCommand::set_action(::Kinova::Api::Base::GpioAction value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GpioCommand.action)
}

// uint32 period = 4;
inline void GpioCommand::clear_period() {
  period_ = 0u;
}
inline ::google::protobuf::uint32 GpioCommand::period() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.GpioCommand.period)
  return period_;
}
inline void GpioCommand::set_period(::google::protobuf::uint32 value) {
  
  period_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.GpioCommand.period)
}

// -------------------------------------------------------------------

// SystemTime

// uint32 sec = 1;
inline void SystemTime::clear_sec() {
  sec_ = 0u;
}
inline ::google::protobuf::uint32 SystemTime::sec() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SystemTime.sec)
  return sec_;
}
inline void SystemTime::set_sec(::google::protobuf::uint32 value) {
  
  sec_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SystemTime.sec)
}

// uint32 min = 2;
inline void SystemTime::clear_min() {
  min_ = 0u;
}
inline ::google::protobuf::uint32 SystemTime::min() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SystemTime.min)
  return min_;
}
inline void SystemTime::set_min(::google::protobuf::uint32 value) {
  
  min_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SystemTime.min)
}

// uint32 hour = 3;
inline void SystemTime::clear_hour() {
  hour_ = 0u;
}
inline ::google::protobuf::uint32 SystemTime::hour() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SystemTime.hour)
  return hour_;
}
inline void SystemTime::set_hour(::google::protobuf::uint32 value) {
  
  hour_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SystemTime.hour)
}

// uint32 mday = 4;
inline void SystemTime::clear_mday() {
  mday_ = 0u;
}
inline ::google::protobuf::uint32 SystemTime::mday() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SystemTime.mday)
  return mday_;
}
inline void SystemTime::set_mday(::google::protobuf::uint32 value) {
  
  mday_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SystemTime.mday)
}

// uint32 mon = 5;
inline void SystemTime::clear_mon() {
  mon_ = 0u;
}
inline ::google::protobuf::uint32 SystemTime::mon() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SystemTime.mon)
  return mon_;
}
inline void SystemTime::set_mon(::google::protobuf::uint32 value) {
  
  mon_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SystemTime.mon)
}

// uint32 year = 6;
inline void SystemTime::clear_year() {
  year_ = 0u;
}
inline ::google::protobuf::uint32 SystemTime::year() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.SystemTime.year)
  return year_;
}
inline void SystemTime::set_year(::google::protobuf::uint32 value) {
  
  year_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.SystemTime.year)
}

// -------------------------------------------------------------------

// ControllerConfigurationMode

// bool enable = 1;
inline void ControllerConfigurationMode::clear_enable() {
  enable_ = false;
}
inline bool ControllerConfigurationMode::enable() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerConfigurationMode.enable)
  return enable_;
}
inline void ControllerConfigurationMode::set_enable(bool value) {
  
  enable_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControllerConfigurationMode.enable)
}

// -------------------------------------------------------------------

// ControllerConfiguration

// .Kinova.Api.Base.ControllerHandle handle = 1;
inline bool ControllerConfiguration::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline void ControllerConfiguration::clear_handle() {
  if (GetArenaNoVirtual() == NULL && handle_ != NULL) {
    delete handle_;
  }
  handle_ = NULL;
}
inline const ::Kinova::Api::Base::ControllerHandle& ControllerConfiguration::handle() const {
  const ::Kinova::Api::Base::ControllerHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerConfiguration.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::ControllerHandle*>(
      &::Kinova::Api::Base::_ControllerHandle_default_instance_);
}
inline ::Kinova::Api::Base::ControllerHandle* ControllerConfiguration::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControllerConfiguration.handle)
  
  ::Kinova::Api::Base::ControllerHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::ControllerHandle* ControllerConfiguration::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Base::ControllerHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerConfiguration.handle)
  return handle_;
}
inline void ControllerConfiguration::set_allocated_handle(::Kinova::Api::Base::ControllerHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handle_;
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ControllerConfiguration.handle)
}

// string name = 2;
inline void ControllerConfiguration::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ControllerConfiguration::name() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerConfiguration.name)
  return name_.GetNoArena();
}
inline void ControllerConfiguration::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControllerConfiguration.name)
}
#if LANG_CXX11
inline void ControllerConfiguration::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.ControllerConfiguration.name)
}
#endif
inline void ControllerConfiguration::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.ControllerConfiguration.name)
}
inline void ControllerConfiguration::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.ControllerConfiguration.name)
}
inline ::std::string* ControllerConfiguration::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerConfiguration.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ControllerConfiguration::release_name() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControllerConfiguration.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ControllerConfiguration::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ControllerConfiguration.name)
}

// .Kinova.Api.Base.MappingHandle active_mapping_handle = 3;
inline bool ControllerConfiguration::has_active_mapping_handle() const {
  return this != internal_default_instance() && active_mapping_handle_ != NULL;
}
inline void ControllerConfiguration::clear_active_mapping_handle() {
  if (GetArenaNoVirtual() == NULL && active_mapping_handle_ != NULL) {
    delete active_mapping_handle_;
  }
  active_mapping_handle_ = NULL;
}
inline const ::Kinova::Api::Base::MappingHandle& ControllerConfiguration::active_mapping_handle() const {
  const ::Kinova::Api::Base::MappingHandle* p = active_mapping_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerConfiguration.active_mapping_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::MappingHandle*>(
      &::Kinova::Api::Base::_MappingHandle_default_instance_);
}
inline ::Kinova::Api::Base::MappingHandle* ControllerConfiguration::release_active_mapping_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControllerConfiguration.active_mapping_handle)
  
  ::Kinova::Api::Base::MappingHandle* temp = active_mapping_handle_;
  active_mapping_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::MappingHandle* ControllerConfiguration::mutable_active_mapping_handle() {
  
  if (active_mapping_handle_ == NULL) {
    active_mapping_handle_ = new ::Kinova::Api::Base::MappingHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerConfiguration.active_mapping_handle)
  return active_mapping_handle_;
}
inline void ControllerConfiguration::set_allocated_active_mapping_handle(::Kinova::Api::Base::MappingHandle* active_mapping_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete active_mapping_handle_;
  }
  if (active_mapping_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      active_mapping_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, active_mapping_handle, submessage_arena);
    }
    
  } else {
    
  }
  active_mapping_handle_ = active_mapping_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ControllerConfiguration.active_mapping_handle)
}

// string analog_input_identifier_enum = 4;
inline void ControllerConfiguration::clear_analog_input_identifier_enum() {
  analog_input_identifier_enum_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ControllerConfiguration::analog_input_identifier_enum() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerConfiguration.analog_input_identifier_enum)
  return analog_input_identifier_enum_.GetNoArena();
}
inline void ControllerConfiguration::set_analog_input_identifier_enum(const ::std::string& value) {
  
  analog_input_identifier_enum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControllerConfiguration.analog_input_identifier_enum)
}
#if LANG_CXX11
inline void ControllerConfiguration::set_analog_input_identifier_enum(::std::string&& value) {
  
  analog_input_identifier_enum_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.ControllerConfiguration.analog_input_identifier_enum)
}
#endif
inline void ControllerConfiguration::set_analog_input_identifier_enum(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  analog_input_identifier_enum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.ControllerConfiguration.analog_input_identifier_enum)
}
inline void ControllerConfiguration::set_analog_input_identifier_enum(const char* value, size_t size) {
  
  analog_input_identifier_enum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.ControllerConfiguration.analog_input_identifier_enum)
}
inline ::std::string* ControllerConfiguration::mutable_analog_input_identifier_enum() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerConfiguration.analog_input_identifier_enum)
  return analog_input_identifier_enum_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ControllerConfiguration::release_analog_input_identifier_enum() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControllerConfiguration.analog_input_identifier_enum)
  
  return analog_input_identifier_enum_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ControllerConfiguration::set_allocated_analog_input_identifier_enum(::std::string* analog_input_identifier_enum) {
  if (analog_input_identifier_enum != NULL) {
    
  } else {
    
  }
  analog_input_identifier_enum_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), analog_input_identifier_enum);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ControllerConfiguration.analog_input_identifier_enum)
}

// string digital_input_identifier_enum = 5;
inline void ControllerConfiguration::clear_digital_input_identifier_enum() {
  digital_input_identifier_enum_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ControllerConfiguration::digital_input_identifier_enum() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerConfiguration.digital_input_identifier_enum)
  return digital_input_identifier_enum_.GetNoArena();
}
inline void ControllerConfiguration::set_digital_input_identifier_enum(const ::std::string& value) {
  
  digital_input_identifier_enum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ControllerConfiguration.digital_input_identifier_enum)
}
#if LANG_CXX11
inline void ControllerConfiguration::set_digital_input_identifier_enum(::std::string&& value) {
  
  digital_input_identifier_enum_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.ControllerConfiguration.digital_input_identifier_enum)
}
#endif
inline void ControllerConfiguration::set_digital_input_identifier_enum(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  digital_input_identifier_enum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.ControllerConfiguration.digital_input_identifier_enum)
}
inline void ControllerConfiguration::set_digital_input_identifier_enum(const char* value, size_t size) {
  
  digital_input_identifier_enum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.ControllerConfiguration.digital_input_identifier_enum)
}
inline ::std::string* ControllerConfiguration::mutable_digital_input_identifier_enum() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerConfiguration.digital_input_identifier_enum)
  return digital_input_identifier_enum_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ControllerConfiguration::release_digital_input_identifier_enum() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ControllerConfiguration.digital_input_identifier_enum)
  
  return digital_input_identifier_enum_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ControllerConfiguration::set_allocated_digital_input_identifier_enum(::std::string* digital_input_identifier_enum) {
  if (digital_input_identifier_enum != NULL) {
    
  } else {
    
  }
  digital_input_identifier_enum_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), digital_input_identifier_enum);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ControllerConfiguration.digital_input_identifier_enum)
}

// -------------------------------------------------------------------

// ControllerConfigurationList

// repeated .Kinova.Api.Base.ControllerConfiguration controller_configurations = 1;
inline int ControllerConfigurationList::controller_configurations_size() const {
  return controller_configurations_.size();
}
inline void ControllerConfigurationList::clear_controller_configurations() {
  controller_configurations_.Clear();
}
inline const ::Kinova::Api::Base::ControllerConfiguration& ControllerConfigurationList::controller_configurations(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ControllerConfigurationList.controller_configurations)
  return controller_configurations_.Get(index);
}
inline ::Kinova::Api::Base::ControllerConfiguration* ControllerConfigurationList::mutable_controller_configurations(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ControllerConfigurationList.controller_configurations)
  return controller_configurations_.Mutable(index);
}
inline ::Kinova::Api::Base::ControllerConfiguration* ControllerConfigurationList::add_controller_configurations() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.ControllerConfigurationList.controller_configurations)
  return controller_configurations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerConfiguration >*
ControllerConfigurationList::mutable_controller_configurations() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.ControllerConfigurationList.controller_configurations)
  return &controller_configurations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::ControllerConfiguration >&
ControllerConfigurationList::controller_configurations() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.ControllerConfigurationList.controller_configurations)
  return controller_configurations_;
}

// -------------------------------------------------------------------

// ActuatorInformation

// uint32 count = 1;
inline void ActuatorInformation::clear_count() {
  count_ = 0u;
}
inline ::google::protobuf::uint32 ActuatorInformation::count() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ActuatorInformation.count)
  return count_;
}
inline void ActuatorInformation::set_count(::google::protobuf::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ActuatorInformation.count)
}

// -------------------------------------------------------------------

// ArmStateInformation

// .Kinova.Api.Common.ArmState active_state = 1;
inline void ArmStateInformation::clear_active_state() {
  active_state_ = 0;
}
inline ::Kinova::Api::Common::ArmState ArmStateInformation::active_state() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ArmStateInformation.active_state)
  return static_cast< ::Kinova::Api::Common::ArmState >(active_state_);
}
inline void ArmStateInformation::set_active_state(::Kinova::Api::Common::ArmState value) {
  
  active_state_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ArmStateInformation.active_state)
}

// .Kinova.Api.Common.Connection connection = 2;
inline bool ArmStateInformation::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& ArmStateInformation::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ArmStateInformation.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* ArmStateInformation::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ArmStateInformation.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* ArmStateInformation::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ArmStateInformation.connection)
  return connection_;
}
inline void ArmStateInformation::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ArmStateInformation.connection)
}

// -------------------------------------------------------------------

// ArmStateNotification

// .Kinova.Api.Common.ArmState active_state = 1;
inline void ArmStateNotification::clear_active_state() {
  active_state_ = 0;
}
inline ::Kinova::Api::Common::ArmState ArmStateNotification::active_state() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ArmStateNotification.active_state)
  return static_cast< ::Kinova::Api::Common::ArmState >(active_state_);
}
inline void ArmStateNotification::set_active_state(::Kinova::Api::Common::ArmState value) {
  
  active_state_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.ArmStateNotification.active_state)
}

// .Kinova.Api.Common.Timestamp timestamp = 2;
inline bool ArmStateNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& ArmStateNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ArmStateNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* ArmStateNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ArmStateNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* ArmStateNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ArmStateNotification.timestamp)
  return timestamp_;
}
inline void ArmStateNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ArmStateNotification.timestamp)
}

// .Kinova.Api.Common.Connection connection = 3;
inline bool ArmStateNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& ArmStateNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.ArmStateNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* ArmStateNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.ArmStateNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* ArmStateNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.ArmStateNotification.connection)
  return connection_;
}
inline void ArmStateNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.ArmStateNotification.connection)
}

// -------------------------------------------------------------------

// CapSenseConfig

// uint32 identifier = 1;
inline void CapSenseConfig::clear_identifier() {
  identifier_ = 0u;
}
inline ::google::protobuf::uint32 CapSenseConfig::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CapSenseConfig.identifier)
  return identifier_;
}
inline void CapSenseConfig::set_identifier(::google::protobuf::uint32 value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CapSenseConfig.identifier)
}

// .Kinova.Api.Base.CapSenseMode mode = 2;
inline void CapSenseConfig::clear_mode() {
  mode_ = 0;
}
inline ::Kinova::Api::Base::CapSenseMode CapSenseConfig::mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CapSenseConfig.mode)
  return static_cast< ::Kinova::Api::Base::CapSenseMode >(mode_);
}
inline void CapSenseConfig::set_mode(::Kinova::Api::Base::CapSenseMode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CapSenseConfig.mode)
}

// float threshold_a = 3;
inline void CapSenseConfig::clear_threshold_a() {
  threshold_a_ = 0;
}
inline float CapSenseConfig::threshold_a() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CapSenseConfig.threshold_a)
  return threshold_a_;
}
inline void CapSenseConfig::set_threshold_a(float value) {
  
  threshold_a_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CapSenseConfig.threshold_a)
}

// float threshold_b = 4;
inline void CapSenseConfig::clear_threshold_b() {
  threshold_b_ = 0;
}
inline float CapSenseConfig::threshold_b() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CapSenseConfig.threshold_b)
  return threshold_b_;
}
inline void CapSenseConfig::set_threshold_b(float value) {
  
  threshold_b_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CapSenseConfig.threshold_b)
}

// float sensitivity_a = 5;
inline void CapSenseConfig::clear_sensitivity_a() {
  sensitivity_a_ = 0;
}
inline float CapSenseConfig::sensitivity_a() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CapSenseConfig.sensitivity_a)
  return sensitivity_a_;
}
inline void CapSenseConfig::set_sensitivity_a(float value) {
  
  sensitivity_a_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CapSenseConfig.sensitivity_a)
}

// float sensitivity_b = 6;
inline void CapSenseConfig::clear_sensitivity_b() {
  sensitivity_b_ = 0;
}
inline float CapSenseConfig::sensitivity_b() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CapSenseConfig.sensitivity_b)
  return sensitivity_b_;
}
inline void CapSenseConfig::set_sensitivity_b(float value) {
  
  sensitivity_b_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CapSenseConfig.sensitivity_b)
}

// -------------------------------------------------------------------

// BridgeList

// repeated .Kinova.Api.Base.BridgeConfig bridgeConfig = 1;
inline int BridgeList::bridgeconfig_size() const {
  return bridgeconfig_.size();
}
inline void BridgeList::clear_bridgeconfig() {
  bridgeconfig_.Clear();
}
inline const ::Kinova::Api::Base::BridgeConfig& BridgeList::bridgeconfig(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.BridgeList.bridgeConfig)
  return bridgeconfig_.Get(index);
}
inline ::Kinova::Api::Base::BridgeConfig* BridgeList::mutable_bridgeconfig(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.BridgeList.bridgeConfig)
  return bridgeconfig_.Mutable(index);
}
inline ::Kinova::Api::Base::BridgeConfig* BridgeList::add_bridgeconfig() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.BridgeList.bridgeConfig)
  return bridgeconfig_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::BridgeConfig >*
BridgeList::mutable_bridgeconfig() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.BridgeList.bridgeConfig)
  return &bridgeconfig_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::BridgeConfig >&
BridgeList::bridgeconfig() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.BridgeList.bridgeConfig)
  return bridgeconfig_;
}

// -------------------------------------------------------------------

// BridgeResult

// .Kinova.Api.Base.BridgeIdentifier bridge_id = 1;
inline bool BridgeResult::has_bridge_id() const {
  return this != internal_default_instance() && bridge_id_ != NULL;
}
inline void BridgeResult::clear_bridge_id() {
  if (GetArenaNoVirtual() == NULL && bridge_id_ != NULL) {
    delete bridge_id_;
  }
  bridge_id_ = NULL;
}
inline const ::Kinova::Api::Base::BridgeIdentifier& BridgeResult::bridge_id() const {
  const ::Kinova::Api::Base::BridgeIdentifier* p = bridge_id_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.BridgeResult.bridge_id)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::BridgeIdentifier*>(
      &::Kinova::Api::Base::_BridgeIdentifier_default_instance_);
}
inline ::Kinova::Api::Base::BridgeIdentifier* BridgeResult::release_bridge_id() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.BridgeResult.bridge_id)
  
  ::Kinova::Api::Base::BridgeIdentifier* temp = bridge_id_;
  bridge_id_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::BridgeIdentifier* BridgeResult::mutable_bridge_id() {
  
  if (bridge_id_ == NULL) {
    bridge_id_ = new ::Kinova::Api::Base::BridgeIdentifier;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.BridgeResult.bridge_id)
  return bridge_id_;
}
inline void BridgeResult::set_allocated_bridge_id(::Kinova::Api::Base::BridgeIdentifier* bridge_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bridge_id_;
  }
  if (bridge_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bridge_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bridge_id, submessage_arena);
    }
    
  } else {
    
  }
  bridge_id_ = bridge_id;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.BridgeResult.bridge_id)
}

// .Kinova.Api.Base.BridgeStatus status = 2;
inline void BridgeResult::clear_status() {
  status_ = 0;
}
inline ::Kinova::Api::Base::BridgeStatus BridgeResult::status() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.BridgeResult.status)
  return static_cast< ::Kinova::Api::Base::BridgeStatus >(status_);
}
inline void BridgeResult::set_status(::Kinova::Api::Base::BridgeStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.BridgeResult.status)
}

// -------------------------------------------------------------------

// BridgeIdentifier

// uint32 bridge_id = 1;
inline void BridgeIdentifier::clear_bridge_id() {
  bridge_id_ = 0u;
}
inline ::google::protobuf::uint32 BridgeIdentifier::bridge_id() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.BridgeIdentifier.bridge_id)
  return bridge_id_;
}
inline void BridgeIdentifier::set_bridge_id(::google::protobuf::uint32 value) {
  
  bridge_id_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.BridgeIdentifier.bridge_id)
}

// -------------------------------------------------------------------

// BridgeConfig

// uint32 device_identifier = 1;
inline void BridgeConfig::clear_device_identifier() {
  device_identifier_ = 0u;
}
inline ::google::protobuf::uint32 BridgeConfig::device_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.BridgeConfig.device_identifier)
  return device_identifier_;
}
inline void BridgeConfig::set_device_identifier(::google::protobuf::uint32 value) {
  
  device_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.BridgeConfig.device_identifier)
}

// .Kinova.Api.Base.BridgeType bridgetype = 2;
inline void BridgeConfig::clear_bridgetype() {
  bridgetype_ = 0;
}
inline ::Kinova::Api::Base::BridgeType BridgeConfig::bridgetype() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.BridgeConfig.bridgetype)
  return static_cast< ::Kinova::Api::Base::BridgeType >(bridgetype_);
}
inline void BridgeConfig::set_bridgetype(::Kinova::Api::Base::BridgeType value) {
  
  bridgetype_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.BridgeConfig.bridgetype)
}

// .Kinova.Api.Base.BridgePortConfig port_config = 3;
inline bool BridgeConfig::has_port_config() const {
  return this != internal_default_instance() && port_config_ != NULL;
}
inline void BridgeConfig::clear_port_config() {
  if (GetArenaNoVirtual() == NULL && port_config_ != NULL) {
    delete port_config_;
  }
  port_config_ = NULL;
}
inline const ::Kinova::Api::Base::BridgePortConfig& BridgeConfig::port_config() const {
  const ::Kinova::Api::Base::BridgePortConfig* p = port_config_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.BridgeConfig.port_config)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::BridgePortConfig*>(
      &::Kinova::Api::Base::_BridgePortConfig_default_instance_);
}
inline ::Kinova::Api::Base::BridgePortConfig* BridgeConfig::release_port_config() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.BridgeConfig.port_config)
  
  ::Kinova::Api::Base::BridgePortConfig* temp = port_config_;
  port_config_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::BridgePortConfig* BridgeConfig::mutable_port_config() {
  
  if (port_config_ == NULL) {
    port_config_ = new ::Kinova::Api::Base::BridgePortConfig;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.BridgeConfig.port_config)
  return port_config_;
}
inline void BridgeConfig::set_allocated_port_config(::Kinova::Api::Base::BridgePortConfig* port_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete port_config_;
  }
  if (port_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      port_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, port_config, submessage_arena);
    }
    
  } else {
    
  }
  port_config_ = port_config;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.BridgeConfig.port_config)
}

// .Kinova.Api.Base.BridgeIdentifier bridge_id = 4;
inline bool BridgeConfig::has_bridge_id() const {
  return this != internal_default_instance() && bridge_id_ != NULL;
}
inline void BridgeConfig::clear_bridge_id() {
  if (GetArenaNoVirtual() == NULL && bridge_id_ != NULL) {
    delete bridge_id_;
  }
  bridge_id_ = NULL;
}
inline const ::Kinova::Api::Base::BridgeIdentifier& BridgeConfig::bridge_id() const {
  const ::Kinova::Api::Base::BridgeIdentifier* p = bridge_id_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.BridgeConfig.bridge_id)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::BridgeIdentifier*>(
      &::Kinova::Api::Base::_BridgeIdentifier_default_instance_);
}
inline ::Kinova::Api::Base::BridgeIdentifier* BridgeConfig::release_bridge_id() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.BridgeConfig.bridge_id)
  
  ::Kinova::Api::Base::BridgeIdentifier* temp = bridge_id_;
  bridge_id_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::BridgeIdentifier* BridgeConfig::mutable_bridge_id() {
  
  if (bridge_id_ == NULL) {
    bridge_id_ = new ::Kinova::Api::Base::BridgeIdentifier;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.BridgeConfig.bridge_id)
  return bridge_id_;
}
inline void BridgeConfig::set_allocated_bridge_id(::Kinova::Api::Base::BridgeIdentifier* bridge_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bridge_id_;
  }
  if (bridge_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bridge_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bridge_id, submessage_arena);
    }
    
  } else {
    
  }
  bridge_id_ = bridge_id;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.BridgeConfig.bridge_id)
}

// -------------------------------------------------------------------

// BridgePortConfig

// uint32 target_port = 1;
inline void BridgePortConfig::clear_target_port() {
  target_port_ = 0u;
}
inline ::google::protobuf::uint32 BridgePortConfig::target_port() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.BridgePortConfig.target_port)
  return target_port_;
}
inline void BridgePortConfig::set_target_port(::google::protobuf::uint32 value) {
  
  target_port_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.BridgePortConfig.target_port)
}

// uint32 out_port = 2;
inline void BridgePortConfig::clear_out_port() {
  out_port_ = 0u;
}
inline ::google::protobuf::uint32 BridgePortConfig::out_port() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.BridgePortConfig.out_port)
  return out_port_;
}
inline void BridgePortConfig::set_out_port(::google::protobuf::uint32 value) {
  
  out_port_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.BridgePortConfig.out_port)
}

// -------------------------------------------------------------------

// PreComputedJointTrajectory

// .Kinova.Api.Base.TrajectoryContinuityMode mode = 1;
inline void PreComputedJointTrajectory::clear_mode() {
  mode_ = 0;
}
inline ::Kinova::Api::Base::TrajectoryContinuityMode PreComputedJointTrajectory::mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.PreComputedJointTrajectory.mode)
  return static_cast< ::Kinova::Api::Base::TrajectoryContinuityMode >(mode_);
}
inline void PreComputedJointTrajectory::set_mode(::Kinova::Api::Base::TrajectoryContinuityMode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.PreComputedJointTrajectory.mode)
}

// repeated .Kinova.Api.Base.PreComputedJointTrajectoryElement trajectory_elements = 2;
inline int PreComputedJointTrajectory::trajectory_elements_size() const {
  return trajectory_elements_.size();
}
inline void PreComputedJointTrajectory::clear_trajectory_elements() {
  trajectory_elements_.Clear();
}
inline const ::Kinova::Api::Base::PreComputedJointTrajectoryElement& PreComputedJointTrajectory::trajectory_elements(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.PreComputedJointTrajectory.trajectory_elements)
  return trajectory_elements_.Get(index);
}
inline ::Kinova::Api::Base::PreComputedJointTrajectoryElement* PreComputedJointTrajectory::mutable_trajectory_elements(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.PreComputedJointTrajectory.trajectory_elements)
  return trajectory_elements_.Mutable(index);
}
inline ::Kinova::Api::Base::PreComputedJointTrajectoryElement* PreComputedJointTrajectory::add_trajectory_elements() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.PreComputedJointTrajectory.trajectory_elements)
  return trajectory_elements_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::PreComputedJointTrajectoryElement >*
PreComputedJointTrajectory::mutable_trajectory_elements() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.PreComputedJointTrajectory.trajectory_elements)
  return &trajectory_elements_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::PreComputedJointTrajectoryElement >&
PreComputedJointTrajectory::trajectory_elements() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.PreComputedJointTrajectory.trajectory_elements)
  return trajectory_elements_;
}

// -------------------------------------------------------------------

// PreComputedJointTrajectoryElement

// repeated float joint_angles = 1;
inline int PreComputedJointTrajectoryElement::joint_angles_size() const {
  return joint_angles_.size();
}
inline void PreComputedJointTrajectoryElement::clear_joint_angles() {
  joint_angles_.Clear();
}
inline float PreComputedJointTrajectoryElement::joint_angles(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_angles)
  return joint_angles_.Get(index);
}
inline void PreComputedJointTrajectoryElement::set_joint_angles(int index, float value) {
  joint_angles_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_angles)
}
inline void PreComputedJointTrajectoryElement::add_joint_angles(float value) {
  joint_angles_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_angles)
}
inline const ::google::protobuf::RepeatedField< float >&
PreComputedJointTrajectoryElement::joint_angles() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_angles)
  return joint_angles_;
}
inline ::google::protobuf::RepeatedField< float >*
PreComputedJointTrajectoryElement::mutable_joint_angles() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_angles)
  return &joint_angles_;
}

// repeated float joint_speeds = 2;
inline int PreComputedJointTrajectoryElement::joint_speeds_size() const {
  return joint_speeds_.size();
}
inline void PreComputedJointTrajectoryElement::clear_joint_speeds() {
  joint_speeds_.Clear();
}
inline float PreComputedJointTrajectoryElement::joint_speeds(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_speeds)
  return joint_speeds_.Get(index);
}
inline void PreComputedJointTrajectoryElement::set_joint_speeds(int index, float value) {
  joint_speeds_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_speeds)
}
inline void PreComputedJointTrajectoryElement::add_joint_speeds(float value) {
  joint_speeds_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_speeds)
}
inline const ::google::protobuf::RepeatedField< float >&
PreComputedJointTrajectoryElement::joint_speeds() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_speeds)
  return joint_speeds_;
}
inline ::google::protobuf::RepeatedField< float >*
PreComputedJointTrajectoryElement::mutable_joint_speeds() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_speeds)
  return &joint_speeds_;
}

// repeated float joint_accelerations = 3;
inline int PreComputedJointTrajectoryElement::joint_accelerations_size() const {
  return joint_accelerations_.size();
}
inline void PreComputedJointTrajectoryElement::clear_joint_accelerations() {
  joint_accelerations_.Clear();
}
inline float PreComputedJointTrajectoryElement::joint_accelerations(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_accelerations)
  return joint_accelerations_.Get(index);
}
inline void PreComputedJointTrajectoryElement::set_joint_accelerations(int index, float value) {
  joint_accelerations_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_accelerations)
}
inline void PreComputedJointTrajectoryElement::add_joint_accelerations(float value) {
  joint_accelerations_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_accelerations)
}
inline const ::google::protobuf::RepeatedField< float >&
PreComputedJointTrajectoryElement::joint_accelerations() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_accelerations)
  return joint_accelerations_;
}
inline ::google::protobuf::RepeatedField< float >*
PreComputedJointTrajectoryElement::mutable_joint_accelerations() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.PreComputedJointTrajectoryElement.joint_accelerations)
  return &joint_accelerations_;
}

// float time_from_start = 4;
inline void PreComputedJointTrajectoryElement::clear_time_from_start() {
  time_from_start_ = 0;
}
inline float PreComputedJointTrajectoryElement::time_from_start() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.PreComputedJointTrajectoryElement.time_from_start)
  return time_from_start_;
}
inline void PreComputedJointTrajectoryElement::set_time_from_start(float value) {
  
  time_from_start_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.PreComputedJointTrajectoryElement.time_from_start)
}

// -------------------------------------------------------------------

// TrajectoryErrorElement

// .Kinova.Api.Base.TrajectoryErrorType error_type = 1;
inline void TrajectoryErrorElement::clear_error_type() {
  error_type_ = 0;
}
inline ::Kinova::Api::Base::TrajectoryErrorType TrajectoryErrorElement::error_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TrajectoryErrorElement.error_type)
  return static_cast< ::Kinova::Api::Base::TrajectoryErrorType >(error_type_);
}
inline void TrajectoryErrorElement::set_error_type(::Kinova::Api::Base::TrajectoryErrorType value) {
  
  error_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TrajectoryErrorElement.error_type)
}

// .Kinova.Api.Base.TrajectoryErrorIdentifier error_identifier = 2 [deprecated = true];
inline void TrajectoryErrorElement::clear_error_identifier() {
  error_identifier_ = 0;
}
inline ::Kinova::Api::Base::TrajectoryErrorIdentifier TrajectoryErrorElement::error_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TrajectoryErrorElement.error_identifier)
  return static_cast< ::Kinova::Api::Base::TrajectoryErrorIdentifier >(error_identifier_);
}
inline void TrajectoryErrorElement::set_error_identifier(::Kinova::Api::Base::TrajectoryErrorIdentifier value) {
  
  error_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TrajectoryErrorElement.error_identifier)
}

// float error_value = 3;
inline void TrajectoryErrorElement::clear_error_value() {
  error_value_ = 0;
}
inline float TrajectoryErrorElement::error_value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TrajectoryErrorElement.error_value)
  return error_value_;
}
inline void TrajectoryErrorElement::set_error_value(float value) {
  
  error_value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TrajectoryErrorElement.error_value)
}

// float min_value = 4;
inline void TrajectoryErrorElement::clear_min_value() {
  min_value_ = 0;
}
inline float TrajectoryErrorElement::min_value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TrajectoryErrorElement.min_value)
  return min_value_;
}
inline void TrajectoryErrorElement::set_min_value(float value) {
  
  min_value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TrajectoryErrorElement.min_value)
}

// float max_value = 5;
inline void TrajectoryErrorElement::clear_max_value() {
  max_value_ = 0;
}
inline float TrajectoryErrorElement::max_value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TrajectoryErrorElement.max_value)
  return max_value_;
}
inline void TrajectoryErrorElement::set_max_value(float value) {
  
  max_value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TrajectoryErrorElement.max_value)
}

// uint32 index = 6;
inline void TrajectoryErrorElement::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 TrajectoryErrorElement::index() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TrajectoryErrorElement.index)
  return index_;
}
inline void TrajectoryErrorElement::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TrajectoryErrorElement.index)
}

// string message = 7;
inline void TrajectoryErrorElement::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TrajectoryErrorElement::message() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TrajectoryErrorElement.message)
  return message_.GetNoArena();
}
inline void TrajectoryErrorElement::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TrajectoryErrorElement.message)
}
#if LANG_CXX11
inline void TrajectoryErrorElement::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.TrajectoryErrorElement.message)
}
#endif
inline void TrajectoryErrorElement::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.TrajectoryErrorElement.message)
}
inline void TrajectoryErrorElement::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.TrajectoryErrorElement.message)
}
inline ::std::string* TrajectoryErrorElement::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.TrajectoryErrorElement.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrajectoryErrorElement::release_message() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.TrajectoryErrorElement.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrajectoryErrorElement::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.TrajectoryErrorElement.message)
}

// uint32 waypoint_index = 8;
inline void TrajectoryErrorElement::clear_waypoint_index() {
  waypoint_index_ = 0u;
}
inline ::google::protobuf::uint32 TrajectoryErrorElement::waypoint_index() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TrajectoryErrorElement.waypoint_index)
  return waypoint_index_;
}
inline void TrajectoryErrorElement::set_waypoint_index(::google::protobuf::uint32 value) {
  
  waypoint_index_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.TrajectoryErrorElement.waypoint_index)
}

// -------------------------------------------------------------------

// TrajectoryErrorReport

// repeated .Kinova.Api.Base.TrajectoryErrorElement trajectory_error_elements = 1;
inline int TrajectoryErrorReport::trajectory_error_elements_size() const {
  return trajectory_error_elements_.size();
}
inline void TrajectoryErrorReport::clear_trajectory_error_elements() {
  trajectory_error_elements_.Clear();
}
inline const ::Kinova::Api::Base::TrajectoryErrorElement& TrajectoryErrorReport::trajectory_error_elements(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.TrajectoryErrorReport.trajectory_error_elements)
  return trajectory_error_elements_.Get(index);
}
inline ::Kinova::Api::Base::TrajectoryErrorElement* TrajectoryErrorReport::mutable_trajectory_error_elements(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.TrajectoryErrorReport.trajectory_error_elements)
  return trajectory_error_elements_.Mutable(index);
}
inline ::Kinova::Api::Base::TrajectoryErrorElement* TrajectoryErrorReport::add_trajectory_error_elements() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.TrajectoryErrorReport.trajectory_error_elements)
  return trajectory_error_elements_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::TrajectoryErrorElement >*
TrajectoryErrorReport::mutable_trajectory_error_elements() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.TrajectoryErrorReport.trajectory_error_elements)
  return &trajectory_error_elements_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::TrajectoryErrorElement >&
TrajectoryErrorReport::trajectory_error_elements() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.TrajectoryErrorReport.trajectory_error_elements)
  return trajectory_error_elements_;
}

// -------------------------------------------------------------------

// WaypointValidationReport

// .Kinova.Api.Base.TrajectoryErrorReport trajectory_error_report = 1;
inline bool WaypointValidationReport::has_trajectory_error_report() const {
  return this != internal_default_instance() && trajectory_error_report_ != NULL;
}
inline void WaypointValidationReport::clear_trajectory_error_report() {
  if (GetArenaNoVirtual() == NULL && trajectory_error_report_ != NULL) {
    delete trajectory_error_report_;
  }
  trajectory_error_report_ = NULL;
}
inline const ::Kinova::Api::Base::TrajectoryErrorReport& WaypointValidationReport::trajectory_error_report() const {
  const ::Kinova::Api::Base::TrajectoryErrorReport* p = trajectory_error_report_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WaypointValidationReport.trajectory_error_report)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::TrajectoryErrorReport*>(
      &::Kinova::Api::Base::_TrajectoryErrorReport_default_instance_);
}
inline ::Kinova::Api::Base::TrajectoryErrorReport* WaypointValidationReport::release_trajectory_error_report() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.WaypointValidationReport.trajectory_error_report)
  
  ::Kinova::Api::Base::TrajectoryErrorReport* temp = trajectory_error_report_;
  trajectory_error_report_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::TrajectoryErrorReport* WaypointValidationReport::mutable_trajectory_error_report() {
  
  if (trajectory_error_report_ == NULL) {
    trajectory_error_report_ = new ::Kinova::Api::Base::TrajectoryErrorReport;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.WaypointValidationReport.trajectory_error_report)
  return trajectory_error_report_;
}
inline void WaypointValidationReport::set_allocated_trajectory_error_report(::Kinova::Api::Base::TrajectoryErrorReport* trajectory_error_report) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trajectory_error_report_;
  }
  if (trajectory_error_report) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trajectory_error_report = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trajectory_error_report, submessage_arena);
    }
    
  } else {
    
  }
  trajectory_error_report_ = trajectory_error_report;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.WaypointValidationReport.trajectory_error_report)
}

// .Kinova.Api.Base.WaypointList optimal_waypoint_list = 2;
inline bool WaypointValidationReport::has_optimal_waypoint_list() const {
  return this != internal_default_instance() && optimal_waypoint_list_ != NULL;
}
inline void WaypointValidationReport::clear_optimal_waypoint_list() {
  if (GetArenaNoVirtual() == NULL && optimal_waypoint_list_ != NULL) {
    delete optimal_waypoint_list_;
  }
  optimal_waypoint_list_ = NULL;
}
inline const ::Kinova::Api::Base::WaypointList& WaypointValidationReport::optimal_waypoint_list() const {
  const ::Kinova::Api::Base::WaypointList* p = optimal_waypoint_list_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WaypointValidationReport.optimal_waypoint_list)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::WaypointList*>(
      &::Kinova::Api::Base::_WaypointList_default_instance_);
}
inline ::Kinova::Api::Base::WaypointList* WaypointValidationReport::release_optimal_waypoint_list() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.WaypointValidationReport.optimal_waypoint_list)
  
  ::Kinova::Api::Base::WaypointList* temp = optimal_waypoint_list_;
  optimal_waypoint_list_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::WaypointList* WaypointValidationReport::mutable_optimal_waypoint_list() {
  
  if (optimal_waypoint_list_ == NULL) {
    optimal_waypoint_list_ = new ::Kinova::Api::Base::WaypointList;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.WaypointValidationReport.optimal_waypoint_list)
  return optimal_waypoint_list_;
}
inline void WaypointValidationReport::set_allocated_optimal_waypoint_list(::Kinova::Api::Base::WaypointList* optimal_waypoint_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete optimal_waypoint_list_;
  }
  if (optimal_waypoint_list) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      optimal_waypoint_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, optimal_waypoint_list, submessage_arena);
    }
    
  } else {
    
  }
  optimal_waypoint_list_ = optimal_waypoint_list;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.WaypointValidationReport.optimal_waypoint_list)
}

// -------------------------------------------------------------------

// Waypoint

// string name = 1;
inline void Waypoint::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Waypoint::name() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Waypoint.name)
  return name_.GetNoArena();
}
inline void Waypoint::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.Waypoint.name)
}
#if LANG_CXX11
inline void Waypoint::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.Waypoint.name)
}
#endif
inline void Waypoint::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.Waypoint.name)
}
inline void Waypoint::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.Waypoint.name)
}
inline ::std::string* Waypoint::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Waypoint.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Waypoint::release_name() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Waypoint.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Waypoint::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.Waypoint.name)
}

// .Kinova.Api.Base.AngularWaypoint angular_waypoint = 2;
inline bool Waypoint::has_angular_waypoint() const {
  return type_of_waypoint_case() == kAngularWaypoint;
}
inline void Waypoint::set_has_angular_waypoint() {
  _oneof_case_[0] = kAngularWaypoint;
}
inline void Waypoint::clear_angular_waypoint() {
  if (has_angular_waypoint()) {
    delete type_of_waypoint_.angular_waypoint_;
    clear_has_type_of_waypoint();
  }
}
inline ::Kinova::Api::Base::AngularWaypoint* Waypoint::release_angular_waypoint() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Waypoint.angular_waypoint)
  if (has_angular_waypoint()) {
    clear_has_type_of_waypoint();
      ::Kinova::Api::Base::AngularWaypoint* temp = type_of_waypoint_.angular_waypoint_;
    type_of_waypoint_.angular_waypoint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::AngularWaypoint& Waypoint::angular_waypoint() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Waypoint.angular_waypoint)
  return has_angular_waypoint()
      ? *type_of_waypoint_.angular_waypoint_
      : *reinterpret_cast< ::Kinova::Api::Base::AngularWaypoint*>(&::Kinova::Api::Base::_AngularWaypoint_default_instance_);
}
inline ::Kinova::Api::Base::AngularWaypoint* Waypoint::mutable_angular_waypoint() {
  if (!has_angular_waypoint()) {
    clear_type_of_waypoint();
    set_has_angular_waypoint();
    type_of_waypoint_.angular_waypoint_ = new ::Kinova::Api::Base::AngularWaypoint;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Waypoint.angular_waypoint)
  return type_of_waypoint_.angular_waypoint_;
}

// .Kinova.Api.Base.CartesianWaypoint cartesian_waypoint = 3;
inline bool Waypoint::has_cartesian_waypoint() const {
  return type_of_waypoint_case() == kCartesianWaypoint;
}
inline void Waypoint::set_has_cartesian_waypoint() {
  _oneof_case_[0] = kCartesianWaypoint;
}
inline void Waypoint::clear_cartesian_waypoint() {
  if (has_cartesian_waypoint()) {
    delete type_of_waypoint_.cartesian_waypoint_;
    clear_has_type_of_waypoint();
  }
}
inline ::Kinova::Api::Base::CartesianWaypoint* Waypoint::release_cartesian_waypoint() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.Waypoint.cartesian_waypoint)
  if (has_cartesian_waypoint()) {
    clear_has_type_of_waypoint();
      ::Kinova::Api::Base::CartesianWaypoint* temp = type_of_waypoint_.cartesian_waypoint_;
    type_of_waypoint_.cartesian_waypoint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Kinova::Api::Base::CartesianWaypoint& Waypoint::cartesian_waypoint() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.Waypoint.cartesian_waypoint)
  return has_cartesian_waypoint()
      ? *type_of_waypoint_.cartesian_waypoint_
      : *reinterpret_cast< ::Kinova::Api::Base::CartesianWaypoint*>(&::Kinova::Api::Base::_CartesianWaypoint_default_instance_);
}
inline ::Kinova::Api::Base::CartesianWaypoint* Waypoint::mutable_cartesian_waypoint() {
  if (!has_cartesian_waypoint()) {
    clear_type_of_waypoint();
    set_has_cartesian_waypoint();
    type_of_waypoint_.cartesian_waypoint_ = new ::Kinova::Api::Base::CartesianWaypoint;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.Waypoint.cartesian_waypoint)
  return type_of_waypoint_.cartesian_waypoint_;
}

inline bool Waypoint::has_type_of_waypoint() const {
  return type_of_waypoint_case() != TYPE_OF_WAYPOINT_NOT_SET;
}
inline void Waypoint::clear_has_type_of_waypoint() {
  _oneof_case_[0] = TYPE_OF_WAYPOINT_NOT_SET;
}
inline Waypoint::TypeOfWaypointCase Waypoint::type_of_waypoint_case() const {
  return Waypoint::TypeOfWaypointCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AngularWaypoint

// repeated float angles = 1;
inline int AngularWaypoint::angles_size() const {
  return angles_.size();
}
inline void AngularWaypoint::clear_angles() {
  angles_.Clear();
}
inline float AngularWaypoint::angles(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.AngularWaypoint.angles)
  return angles_.Get(index);
}
inline void AngularWaypoint::set_angles(int index, float value) {
  angles_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.AngularWaypoint.angles)
}
inline void AngularWaypoint::add_angles(float value) {
  angles_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.AngularWaypoint.angles)
}
inline const ::google::protobuf::RepeatedField< float >&
AngularWaypoint::angles() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.AngularWaypoint.angles)
  return angles_;
}
inline ::google::protobuf::RepeatedField< float >*
AngularWaypoint::mutable_angles() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.AngularWaypoint.angles)
  return &angles_;
}

// repeated float maximum_velocities = 2;
inline int AngularWaypoint::maximum_velocities_size() const {
  return maximum_velocities_.size();
}
inline void AngularWaypoint::clear_maximum_velocities() {
  maximum_velocities_.Clear();
}
inline float AngularWaypoint::maximum_velocities(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.AngularWaypoint.maximum_velocities)
  return maximum_velocities_.Get(index);
}
inline void AngularWaypoint::set_maximum_velocities(int index, float value) {
  maximum_velocities_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.AngularWaypoint.maximum_velocities)
}
inline void AngularWaypoint::add_maximum_velocities(float value) {
  maximum_velocities_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.AngularWaypoint.maximum_velocities)
}
inline const ::google::protobuf::RepeatedField< float >&
AngularWaypoint::maximum_velocities() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.AngularWaypoint.maximum_velocities)
  return maximum_velocities_;
}
inline ::google::protobuf::RepeatedField< float >*
AngularWaypoint::mutable_maximum_velocities() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.AngularWaypoint.maximum_velocities)
  return &maximum_velocities_;
}

// float duration = 3;
inline void AngularWaypoint::clear_duration() {
  duration_ = 0;
}
inline float AngularWaypoint::duration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.AngularWaypoint.duration)
  return duration_;
}
inline void AngularWaypoint::set_duration(float value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.AngularWaypoint.duration)
}

// -------------------------------------------------------------------

// CartesianWaypoint

// .Kinova.Api.Base.Pose pose = 1;
inline bool CartesianWaypoint::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
inline void CartesianWaypoint::clear_pose() {
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) {
    delete pose_;
  }
  pose_ = NULL;
}
inline const ::Kinova::Api::Base::Pose& CartesianWaypoint::pose() const {
  const ::Kinova::Api::Base::Pose* p = pose_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CartesianWaypoint.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::Pose*>(
      &::Kinova::Api::Base::_Pose_default_instance_);
}
inline ::Kinova::Api::Base::Pose* CartesianWaypoint::release_pose() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.CartesianWaypoint.pose)
  
  ::Kinova::Api::Base::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::Pose* CartesianWaypoint::mutable_pose() {
  
  if (pose_ == NULL) {
    pose_ = new ::Kinova::Api::Base::Pose;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.CartesianWaypoint.pose)
  return pose_;
}
inline void CartesianWaypoint::set_allocated_pose(::Kinova::Api::Base::Pose* pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pose_;
  }
  if (pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.CartesianWaypoint.pose)
}

// .Kinova.Api.Common.CartesianReferenceFrame reference_frame = 2;
inline void CartesianWaypoint::clear_reference_frame() {
  reference_frame_ = 0;
}
inline ::Kinova::Api::Common::CartesianReferenceFrame CartesianWaypoint::reference_frame() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CartesianWaypoint.reference_frame)
  return static_cast< ::Kinova::Api::Common::CartesianReferenceFrame >(reference_frame_);
}
inline void CartesianWaypoint::set_reference_frame(::Kinova::Api::Common::CartesianReferenceFrame value) {
  
  reference_frame_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CartesianWaypoint.reference_frame)
}

// float maximum_linear_velocity = 3;
inline void CartesianWaypoint::clear_maximum_linear_velocity() {
  maximum_linear_velocity_ = 0;
}
inline float CartesianWaypoint::maximum_linear_velocity() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CartesianWaypoint.maximum_linear_velocity)
  return maximum_linear_velocity_;
}
inline void CartesianWaypoint::set_maximum_linear_velocity(float value) {
  
  maximum_linear_velocity_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CartesianWaypoint.maximum_linear_velocity)
}

// float maximum_angular_velocity = 4;
inline void CartesianWaypoint::clear_maximum_angular_velocity() {
  maximum_angular_velocity_ = 0;
}
inline float CartesianWaypoint::maximum_angular_velocity() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CartesianWaypoint.maximum_angular_velocity)
  return maximum_angular_velocity_;
}
inline void CartesianWaypoint::set_maximum_angular_velocity(float value) {
  
  maximum_angular_velocity_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CartesianWaypoint.maximum_angular_velocity)
}

// float blending_radius = 5;
inline void CartesianWaypoint::clear_blending_radius() {
  blending_radius_ = 0;
}
inline float CartesianWaypoint::blending_radius() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.CartesianWaypoint.blending_radius)
  return blending_radius_;
}
inline void CartesianWaypoint::set_blending_radius(float value) {
  
  blending_radius_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.CartesianWaypoint.blending_radius)
}

// -------------------------------------------------------------------

// WaypointList

// repeated .Kinova.Api.Base.Waypoint waypoints = 1;
inline int WaypointList::waypoints_size() const {
  return waypoints_.size();
}
inline void WaypointList::clear_waypoints() {
  waypoints_.Clear();
}
inline const ::Kinova::Api::Base::Waypoint& WaypointList::waypoints(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WaypointList.waypoints)
  return waypoints_.Get(index);
}
inline ::Kinova::Api::Base::Waypoint* WaypointList::mutable_waypoints(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.WaypointList.waypoints)
  return waypoints_.Mutable(index);
}
inline ::Kinova::Api::Base::Waypoint* WaypointList::add_waypoints() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.WaypointList.waypoints)
  return waypoints_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Waypoint >*
WaypointList::mutable_waypoints() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.WaypointList.waypoints)
  return &waypoints_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::Waypoint >&
WaypointList::waypoints() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.WaypointList.waypoints)
  return waypoints_;
}

// float duration = 2;
inline void WaypointList::clear_duration() {
  duration_ = 0;
}
inline float WaypointList::duration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WaypointList.duration)
  return duration_;
}
inline void WaypointList::set_duration(float value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WaypointList.duration)
}

// bool use_optimal_blending = 3;
inline void WaypointList::clear_use_optimal_blending() {
  use_optimal_blending_ = false;
}
inline bool WaypointList::use_optimal_blending() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.WaypointList.use_optimal_blending)
  return use_optimal_blending_;
}
inline void WaypointList::set_use_optimal_blending(bool value) {
  
  use_optimal_blending_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.WaypointList.use_optimal_blending)
}

// -------------------------------------------------------------------

// KinematicTrajectoryConstraints

// repeated float angular_velocities = 1;
inline int KinematicTrajectoryConstraints::angular_velocities_size() const {
  return angular_velocities_.size();
}
inline void KinematicTrajectoryConstraints::clear_angular_velocities() {
  angular_velocities_.Clear();
}
inline float KinematicTrajectoryConstraints::angular_velocities(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.KinematicTrajectoryConstraints.angular_velocities)
  return angular_velocities_.Get(index);
}
inline void KinematicTrajectoryConstraints::set_angular_velocities(int index, float value) {
  angular_velocities_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.KinematicTrajectoryConstraints.angular_velocities)
}
inline void KinematicTrajectoryConstraints::add_angular_velocities(float value) {
  angular_velocities_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.KinematicTrajectoryConstraints.angular_velocities)
}
inline const ::google::protobuf::RepeatedField< float >&
KinematicTrajectoryConstraints::angular_velocities() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.KinematicTrajectoryConstraints.angular_velocities)
  return angular_velocities_;
}
inline ::google::protobuf::RepeatedField< float >*
KinematicTrajectoryConstraints::mutable_angular_velocities() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.KinematicTrajectoryConstraints.angular_velocities)
  return &angular_velocities_;
}

// float linear_velocity = 2;
inline void KinematicTrajectoryConstraints::clear_linear_velocity() {
  linear_velocity_ = 0;
}
inline float KinematicTrajectoryConstraints::linear_velocity() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.KinematicTrajectoryConstraints.linear_velocity)
  return linear_velocity_;
}
inline void KinematicTrajectoryConstraints::set_linear_velocity(float value) {
  
  linear_velocity_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.KinematicTrajectoryConstraints.linear_velocity)
}

// float angular_velocity = 3;
inline void KinematicTrajectoryConstraints::clear_angular_velocity() {
  angular_velocity_ = 0;
}
inline float KinematicTrajectoryConstraints::angular_velocity() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.KinematicTrajectoryConstraints.angular_velocity)
  return angular_velocity_;
}
inline void KinematicTrajectoryConstraints::set_angular_velocity(float value) {
  
  angular_velocity_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.KinematicTrajectoryConstraints.angular_velocity)
}

// -------------------------------------------------------------------

// FirmwareBundleVersions

// string main_bundle_version = 1;
inline void FirmwareBundleVersions::clear_main_bundle_version() {
  main_bundle_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FirmwareBundleVersions::main_bundle_version() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.FirmwareBundleVersions.main_bundle_version)
  return main_bundle_version_.GetNoArena();
}
inline void FirmwareBundleVersions::set_main_bundle_version(const ::std::string& value) {
  
  main_bundle_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.FirmwareBundleVersions.main_bundle_version)
}
#if LANG_CXX11
inline void FirmwareBundleVersions::set_main_bundle_version(::std::string&& value) {
  
  main_bundle_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.FirmwareBundleVersions.main_bundle_version)
}
#endif
inline void FirmwareBundleVersions::set_main_bundle_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  main_bundle_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.FirmwareBundleVersions.main_bundle_version)
}
inline void FirmwareBundleVersions::set_main_bundle_version(const char* value, size_t size) {
  
  main_bundle_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.FirmwareBundleVersions.main_bundle_version)
}
inline ::std::string* FirmwareBundleVersions::mutable_main_bundle_version() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.FirmwareBundleVersions.main_bundle_version)
  return main_bundle_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FirmwareBundleVersions::release_main_bundle_version() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.FirmwareBundleVersions.main_bundle_version)
  
  return main_bundle_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FirmwareBundleVersions::set_allocated_main_bundle_version(::std::string* main_bundle_version) {
  if (main_bundle_version != NULL) {
    
  } else {
    
  }
  main_bundle_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), main_bundle_version);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.FirmwareBundleVersions.main_bundle_version)
}

// repeated .Kinova.Api.Base.FirmwareComponentVersion components_versions = 2;
inline int FirmwareBundleVersions::components_versions_size() const {
  return components_versions_.size();
}
inline void FirmwareBundleVersions::clear_components_versions() {
  components_versions_.Clear();
}
inline const ::Kinova::Api::Base::FirmwareComponentVersion& FirmwareBundleVersions::components_versions(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.FirmwareBundleVersions.components_versions)
  return components_versions_.Get(index);
}
inline ::Kinova::Api::Base::FirmwareComponentVersion* FirmwareBundleVersions::mutable_components_versions(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.FirmwareBundleVersions.components_versions)
  return components_versions_.Mutable(index);
}
inline ::Kinova::Api::Base::FirmwareComponentVersion* FirmwareBundleVersions::add_components_versions() {
  // @@protoc_insertion_point(field_add:Kinova.Api.Base.FirmwareBundleVersions.components_versions)
  return components_versions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::FirmwareComponentVersion >*
FirmwareBundleVersions::mutable_components_versions() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.Base.FirmwareBundleVersions.components_versions)
  return &components_versions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::Base::FirmwareComponentVersion >&
FirmwareBundleVersions::components_versions() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.Base.FirmwareBundleVersions.components_versions)
  return components_versions_;
}

// -------------------------------------------------------------------

// FirmwareComponentVersion

// string name = 1;
inline void FirmwareComponentVersion::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FirmwareComponentVersion::name() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.FirmwareComponentVersion.name)
  return name_.GetNoArena();
}
inline void FirmwareComponentVersion::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.FirmwareComponentVersion.name)
}
#if LANG_CXX11
inline void FirmwareComponentVersion::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.FirmwareComponentVersion.name)
}
#endif
inline void FirmwareComponentVersion::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.FirmwareComponentVersion.name)
}
inline void FirmwareComponentVersion::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.FirmwareComponentVersion.name)
}
inline ::std::string* FirmwareComponentVersion::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.FirmwareComponentVersion.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FirmwareComponentVersion::release_name() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.FirmwareComponentVersion.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FirmwareComponentVersion::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.FirmwareComponentVersion.name)
}

// string version = 2;
inline void FirmwareComponentVersion::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FirmwareComponentVersion::version() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.FirmwareComponentVersion.version)
  return version_.GetNoArena();
}
inline void FirmwareComponentVersion::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.FirmwareComponentVersion.version)
}
#if LANG_CXX11
inline void FirmwareComponentVersion::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Base.FirmwareComponentVersion.version)
}
#endif
inline void FirmwareComponentVersion::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Base.FirmwareComponentVersion.version)
}
inline void FirmwareComponentVersion::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Base.FirmwareComponentVersion.version)
}
inline ::std::string* FirmwareComponentVersion::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.FirmwareComponentVersion.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FirmwareComponentVersion::release_version() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.FirmwareComponentVersion.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FirmwareComponentVersion::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.FirmwareComponentVersion.version)
}

// uint32 device_id = 3;
inline void FirmwareComponentVersion::clear_device_id() {
  device_id_ = 0u;
}
inline ::google::protobuf::uint32 FirmwareComponentVersion::device_id() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.FirmwareComponentVersion.device_id)
  return device_id_;
}
inline void FirmwareComponentVersion::set_device_id(::google::protobuf::uint32 value) {
  
  device_id_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Base.FirmwareComponentVersion.device_id)
}

// -------------------------------------------------------------------

// IKData

// .Kinova.Api.Base.Pose cartesian_pose = 1;
inline bool IKData::has_cartesian_pose() const {
  return this != internal_default_instance() && cartesian_pose_ != NULL;
}
inline void IKData::clear_cartesian_pose() {
  if (GetArenaNoVirtual() == NULL && cartesian_pose_ != NULL) {
    delete cartesian_pose_;
  }
  cartesian_pose_ = NULL;
}
inline const ::Kinova::Api::Base::Pose& IKData::cartesian_pose() const {
  const ::Kinova::Api::Base::Pose* p = cartesian_pose_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.IKData.cartesian_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::Pose*>(
      &::Kinova::Api::Base::_Pose_default_instance_);
}
inline ::Kinova::Api::Base::Pose* IKData::release_cartesian_pose() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.IKData.cartesian_pose)
  
  ::Kinova::Api::Base::Pose* temp = cartesian_pose_;
  cartesian_pose_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::Pose* IKData::mutable_cartesian_pose() {
  
  if (cartesian_pose_ == NULL) {
    cartesian_pose_ = new ::Kinova::Api::Base::Pose;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.IKData.cartesian_pose)
  return cartesian_pose_;
}
inline void IKData::set_allocated_cartesian_pose(::Kinova::Api::Base::Pose* cartesian_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cartesian_pose_;
  }
  if (cartesian_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cartesian_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cartesian_pose, submessage_arena);
    }
    
  } else {
    
  }
  cartesian_pose_ = cartesian_pose;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.IKData.cartesian_pose)
}

// .Kinova.Api.Base.JointAngles guess = 2;
inline bool IKData::has_guess() const {
  return this != internal_default_instance() && guess_ != NULL;
}
inline void IKData::clear_guess() {
  if (GetArenaNoVirtual() == NULL && guess_ != NULL) {
    delete guess_;
  }
  guess_ = NULL;
}
inline const ::Kinova::Api::Base::JointAngles& IKData::guess() const {
  const ::Kinova::Api::Base::JointAngles* p = guess_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Base.IKData.guess)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Base::JointAngles*>(
      &::Kinova::Api::Base::_JointAngles_default_instance_);
}
inline ::Kinova::Api::Base::JointAngles* IKData::release_guess() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Base.IKData.guess)
  
  ::Kinova::Api::Base::JointAngles* temp = guess_;
  guess_ = NULL;
  return temp;
}
inline ::Kinova::Api::Base::JointAngles* IKData::mutable_guess() {
  
  if (guess_ == NULL) {
    guess_ = new ::Kinova::Api::Base::JointAngles;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Base.IKData.guess)
  return guess_;
}
inline void IKData::set_allocated_guess(::Kinova::Api::Base::JointAngles* guess) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete guess_;
  }
  if (guess) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      guess = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, guess, submessage_arena);
    }
    
  } else {
    
  }
  guess_ = guess;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Base.IKData.guess)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Base
}  // namespace Api
}  // namespace Kinova

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Kinova::Api::Base::GpioPinPropertyFlags> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::GpioPinPropertyFlags>() {
  return ::Kinova::Api::Base::GpioPinPropertyFlags_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::ServiceVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::ServiceVersion>() {
  return ::Kinova::Api::Base::ServiceVersion_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::ActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::ActionType>() {
  return ::Kinova::Api::Base::ActionType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::SnapshotType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::SnapshotType>() {
  return ::Kinova::Api::Base::SnapshotType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::NetworkType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::NetworkType>() {
  return ::Kinova::Api::Base::NetworkType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::WifiSecurityType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::WifiSecurityType>() {
  return ::Kinova::Api::Base::WifiSecurityType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::WifiEncryptionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::WifiEncryptionType>() {
  return ::Kinova::Api::Base::WifiEncryptionType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::SignalQuality> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::SignalQuality>() {
  return ::Kinova::Api::Base::SignalQuality_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::ShapeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::ShapeType>() {
  return ::Kinova::Api::Base::ShapeType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::LimitationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::LimitationType>() {
  return ::Kinova::Api::Base::LimitationType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::ConfigurationNotificationEvent> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::ConfigurationNotificationEvent>() {
  return ::Kinova::Api::Base::ConfigurationNotificationEvent_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::ControlMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::ControlMode>() {
  return ::Kinova::Api::Base::ControlMode_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::OperatingMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::OperatingMode>() {
  return ::Kinova::Api::Base::OperatingMode_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::ServoingMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::ServoingMode>() {
  return ::Kinova::Api::Base::ServoingMode_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::EventIdSequenceInfoNotification> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::EventIdSequenceInfoNotification>() {
  return ::Kinova::Api::Base::EventIdSequenceInfoNotification_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::ProtectionZoneEvent> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::ProtectionZoneEvent>() {
  return ::Kinova::Api::Base::ProtectionZoneEvent_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::UserEvent> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::UserEvent>() {
  return ::Kinova::Api::Base::UserEvent_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::ControllerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::ControllerType>() {
  return ::Kinova::Api::Base::ControllerType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::ControllerEventType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::ControllerEventType>() {
  return ::Kinova::Api::Base::ControllerEventType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::ControllerElementEventType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::ControllerElementEventType>() {
  return ::Kinova::Api::Base::ControllerElementEventType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::ActionEvent> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::ActionEvent>() {
  return ::Kinova::Api::Base::ActionEvent_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::RobotEvent> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::RobotEvent>() {
  return ::Kinova::Api::Base::RobotEvent_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::BackupEvent> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::BackupEvent>() {
  return ::Kinova::Api::Base::BackupEvent_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::FactoryEvent> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::FactoryEvent>() {
  return ::Kinova::Api::Base::FactoryEvent_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::NetworkEvent> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::NetworkEvent>() {
  return ::Kinova::Api::Base::NetworkEvent_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::ControllerInputType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::ControllerInputType>() {
  return ::Kinova::Api::Base::ControllerInputType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::ControllerBehavior> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::ControllerBehavior>() {
  return ::Kinova::Api::Base::ControllerBehavior_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::SafetyIdentifier> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::SafetyIdentifier>() {
  return ::Kinova::Api::Base::SafetyIdentifier_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::JointTrajectoryConstraintType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::JointTrajectoryConstraintType>() {
  return ::Kinova::Api::Base::JointTrajectoryConstraintType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::WrenchMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::WrenchMode>() {
  return ::Kinova::Api::Base::WrenchMode_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::AdmittanceMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::AdmittanceMode>() {
  return ::Kinova::Api::Base::AdmittanceMode_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::GripperMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::GripperMode>() {
  return ::Kinova::Api::Base::GripperMode_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::GpioAction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::GpioAction>() {
  return ::Kinova::Api::Base::GpioAction_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::NavigationDirection> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::NavigationDirection>() {
  return ::Kinova::Api::Base::NavigationDirection_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::JointNavigationDirection> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::JointNavigationDirection>() {
  return ::Kinova::Api::Base::JointNavigationDirection_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::SoundType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::SoundType>() {
  return ::Kinova::Api::Base::SoundType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::LedState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::LedState>() {
  return ::Kinova::Api::Base::LedState_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::GpioBehavior> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::GpioBehavior>() {
  return ::Kinova::Api::Base::GpioBehavior_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::Gen3GpioPinId> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::Gen3GpioPinId>() {
  return ::Kinova::Api::Base::Gen3GpioPinId_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::Xbox360DigitalInputIdentifier> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::Xbox360DigitalInputIdentifier>() {
  return ::Kinova::Api::Base::Xbox360DigitalInputIdentifier_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::Xbox360AnalogInputIdentifier> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::Xbox360AnalogInputIdentifier>() {
  return ::Kinova::Api::Base::Xbox360AnalogInputIdentifier_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::WristDigitalInputIdentifier> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::WristDigitalInputIdentifier>() {
  return ::Kinova::Api::Base::WristDigitalInputIdentifier_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::CapSenseMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::CapSenseMode>() {
  return ::Kinova::Api::Base::CapSenseMode_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::BridgeStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::BridgeStatus>() {
  return ::Kinova::Api::Base::BridgeStatus_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::BridgeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::BridgeType>() {
  return ::Kinova::Api::Base::BridgeType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::TrajectoryContinuityMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::TrajectoryContinuityMode>() {
  return ::Kinova::Api::Base::TrajectoryContinuityMode_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::TrajectoryErrorType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::TrajectoryErrorType>() {
  return ::Kinova::Api::Base::TrajectoryErrorType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::TrajectoryErrorIdentifier> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::TrajectoryErrorIdentifier>() {
  return ::Kinova::Api::Base::TrajectoryErrorIdentifier_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Base::TrajectoryInfoType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Base::TrajectoryInfoType>() {
  return ::Kinova::Api::Base::TrajectoryInfoType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Base_2eproto__INCLUDED
