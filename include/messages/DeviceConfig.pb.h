// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DeviceConfig.proto

#ifndef PROTOBUF_DeviceConfig_2eproto__INCLUDED
#define PROTOBUF_DeviceConfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Common.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace protobuf_DeviceConfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[25];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsDeviceTypeImpl();
void InitDefaultsDeviceType();
void InitDefaultsRunModeImpl();
void InitDefaultsRunMode();
void InitDefaultsFirmwareVersionImpl();
void InitDefaultsFirmwareVersion();
void InitDefaultsBootloaderVersionImpl();
void InitDefaultsBootloaderVersion();
void InitDefaultsModelNumberImpl();
void InitDefaultsModelNumber();
void InitDefaultsPartNumberImpl();
void InitDefaultsPartNumber();
void InitDefaultsSerialNumberImpl();
void InitDefaultsSerialNumber();
void InitDefaultsMACAddressImpl();
void InitDefaultsMACAddress();
void InitDefaultsIPv4SettingsImpl();
void InitDefaultsIPv4Settings();
void InitDefaultsPartNumberRevisionImpl();
void InitDefaultsPartNumberRevision();
void InitDefaultsPowerOnSelfTestResultImpl();
void InitDefaultsPowerOnSelfTestResult();
void InitDefaultsRebootRqstImpl();
void InitDefaultsRebootRqst();
void InitDefaultsSafetyInformationImpl();
void InitDefaultsSafetyInformation();
void InitDefaultsSafetyInformationListImpl();
void InitDefaultsSafetyInformationList();
void InitDefaultsSafetyEnableImpl();
void InitDefaultsSafetyEnable();
void InitDefaultsSafetyThresholdImpl();
void InitDefaultsSafetyThreshold();
void InitDefaultsSafetyConfigurationImpl();
void InitDefaultsSafetyConfiguration();
void InitDefaultsSafetyConfigurationListImpl();
void InitDefaultsSafetyConfigurationList();
void InitDefaultsSafetyStatusImpl();
void InitDefaultsSafetyStatus();
void InitDefaultsCalibrationParameterImpl();
void InitDefaultsCalibrationParameter();
void InitDefaultsCalibrationImpl();
void InitDefaultsCalibration();
void InitDefaultsCalibrationElementImpl();
void InitDefaultsCalibrationElement();
void InitDefaultsCalibrationResultImpl();
void InitDefaultsCalibrationResult();
void InitDefaultsCapSenseConfigImpl();
void InitDefaultsCapSenseConfig();
void InitDefaultsCapSenseRegisterImpl();
void InitDefaultsCapSenseRegister();
inline void InitDefaults() {
  InitDefaultsDeviceType();
  InitDefaultsRunMode();
  InitDefaultsFirmwareVersion();
  InitDefaultsBootloaderVersion();
  InitDefaultsModelNumber();
  InitDefaultsPartNumber();
  InitDefaultsSerialNumber();
  InitDefaultsMACAddress();
  InitDefaultsIPv4Settings();
  InitDefaultsPartNumberRevision();
  InitDefaultsPowerOnSelfTestResult();
  InitDefaultsRebootRqst();
  InitDefaultsSafetyInformation();
  InitDefaultsSafetyInformationList();
  InitDefaultsSafetyEnable();
  InitDefaultsSafetyThreshold();
  InitDefaultsSafetyConfiguration();
  InitDefaultsSafetyConfigurationList();
  InitDefaultsSafetyStatus();
  InitDefaultsCalibrationParameter();
  InitDefaultsCalibration();
  InitDefaultsCalibrationElement();
  InitDefaultsCalibrationResult();
  InitDefaultsCapSenseConfig();
  InitDefaultsCapSenseRegister();
}
}  // namespace protobuf_DeviceConfig_2eproto
namespace Kinova {
namespace Api {
namespace DeviceConfig {
class BootloaderVersion;
class BootloaderVersionDefaultTypeInternal;
extern BootloaderVersionDefaultTypeInternal _BootloaderVersion_default_instance_;
class Calibration;
class CalibrationDefaultTypeInternal;
extern CalibrationDefaultTypeInternal _Calibration_default_instance_;
class CalibrationElement;
class CalibrationElementDefaultTypeInternal;
extern CalibrationElementDefaultTypeInternal _CalibrationElement_default_instance_;
class CalibrationParameter;
class CalibrationParameterDefaultTypeInternal;
extern CalibrationParameterDefaultTypeInternal _CalibrationParameter_default_instance_;
class CalibrationResult;
class CalibrationResultDefaultTypeInternal;
extern CalibrationResultDefaultTypeInternal _CalibrationResult_default_instance_;
class CapSenseConfig;
class CapSenseConfigDefaultTypeInternal;
extern CapSenseConfigDefaultTypeInternal _CapSenseConfig_default_instance_;
class CapSenseRegister;
class CapSenseRegisterDefaultTypeInternal;
extern CapSenseRegisterDefaultTypeInternal _CapSenseRegister_default_instance_;
class DeviceType;
class DeviceTypeDefaultTypeInternal;
extern DeviceTypeDefaultTypeInternal _DeviceType_default_instance_;
class FirmwareVersion;
class FirmwareVersionDefaultTypeInternal;
extern FirmwareVersionDefaultTypeInternal _FirmwareVersion_default_instance_;
class IPv4Settings;
class IPv4SettingsDefaultTypeInternal;
extern IPv4SettingsDefaultTypeInternal _IPv4Settings_default_instance_;
class MACAddress;
class MACAddressDefaultTypeInternal;
extern MACAddressDefaultTypeInternal _MACAddress_default_instance_;
class ModelNumber;
class ModelNumberDefaultTypeInternal;
extern ModelNumberDefaultTypeInternal _ModelNumber_default_instance_;
class PartNumber;
class PartNumberDefaultTypeInternal;
extern PartNumberDefaultTypeInternal _PartNumber_default_instance_;
class PartNumberRevision;
class PartNumberRevisionDefaultTypeInternal;
extern PartNumberRevisionDefaultTypeInternal _PartNumberRevision_default_instance_;
class PowerOnSelfTestResult;
class PowerOnSelfTestResultDefaultTypeInternal;
extern PowerOnSelfTestResultDefaultTypeInternal _PowerOnSelfTestResult_default_instance_;
class RebootRqst;
class RebootRqstDefaultTypeInternal;
extern RebootRqstDefaultTypeInternal _RebootRqst_default_instance_;
class RunMode;
class RunModeDefaultTypeInternal;
extern RunModeDefaultTypeInternal _RunMode_default_instance_;
class SafetyConfiguration;
class SafetyConfigurationDefaultTypeInternal;
extern SafetyConfigurationDefaultTypeInternal _SafetyConfiguration_default_instance_;
class SafetyConfigurationList;
class SafetyConfigurationListDefaultTypeInternal;
extern SafetyConfigurationListDefaultTypeInternal _SafetyConfigurationList_default_instance_;
class SafetyEnable;
class SafetyEnableDefaultTypeInternal;
extern SafetyEnableDefaultTypeInternal _SafetyEnable_default_instance_;
class SafetyInformation;
class SafetyInformationDefaultTypeInternal;
extern SafetyInformationDefaultTypeInternal _SafetyInformation_default_instance_;
class SafetyInformationList;
class SafetyInformationListDefaultTypeInternal;
extern SafetyInformationListDefaultTypeInternal _SafetyInformationList_default_instance_;
class SafetyStatus;
class SafetyStatusDefaultTypeInternal;
extern SafetyStatusDefaultTypeInternal _SafetyStatus_default_instance_;
class SafetyThreshold;
class SafetyThresholdDefaultTypeInternal;
extern SafetyThresholdDefaultTypeInternal _SafetyThreshold_default_instance_;
class SerialNumber;
class SerialNumberDefaultTypeInternal;
extern SerialNumberDefaultTypeInternal _SerialNumber_default_instance_;
}  // namespace DeviceConfig
}  // namespace Api
}  // namespace Kinova
namespace Kinova {
namespace Api {
namespace DeviceConfig {

enum ServiceVersion {
  RESERVED_0 = 0,
  CURRENT_VERSION = 1,
  ServiceVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ServiceVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ServiceVersion_IsValid(int value);
const ServiceVersion ServiceVersion_MIN = RESERVED_0;
const ServiceVersion ServiceVersion_MAX = CURRENT_VERSION;
const int ServiceVersion_ARRAYSIZE = ServiceVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceVersion_descriptor();
inline const ::std::string& ServiceVersion_Name(ServiceVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceVersion_descriptor(), value);
}
inline bool ServiceVersion_Parse(
    const ::std::string& name, ServiceVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceVersion>(
    ServiceVersion_descriptor(), name, value);
}
enum RunModes {
  RUN_MODE = 0,
  CALIBRATION_MODE = 1,
  CONFIGURATION_MODE = 2,
  DEBUG_MODE = 3,
  TUNING_MODE = 4,
  RunModes_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RunModes_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RunModes_IsValid(int value);
const RunModes RunModes_MIN = RUN_MODE;
const RunModes RunModes_MAX = TUNING_MODE;
const int RunModes_ARRAYSIZE = RunModes_MAX + 1;

const ::google::protobuf::EnumDescriptor* RunModes_descriptor();
inline const ::std::string& RunModes_Name(RunModes value) {
  return ::google::protobuf::internal::NameOfEnum(
    RunModes_descriptor(), value);
}
inline bool RunModes_Parse(
    const ::std::string& name, RunModes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RunModes>(
    RunModes_descriptor(), name, value);
}
enum CalibrationItem {
  UNSPECIFIED_CALIBRATION_ITEM = 0,
  COGGING = 1,
  MAGNETIC = 2,
  MOTOR = 3,
  POSITION_RANGE = 4,
  CalibrationItem_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CalibrationItem_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CalibrationItem_IsValid(int value);
const CalibrationItem CalibrationItem_MIN = UNSPECIFIED_CALIBRATION_ITEM;
const CalibrationItem CalibrationItem_MAX = POSITION_RANGE;
const int CalibrationItem_ARRAYSIZE = CalibrationItem_MAX + 1;

const ::google::protobuf::EnumDescriptor* CalibrationItem_descriptor();
inline const ::std::string& CalibrationItem_Name(CalibrationItem value) {
  return ::google::protobuf::internal::NameOfEnum(
    CalibrationItem_descriptor(), value);
}
inline bool CalibrationItem_Parse(
    const ::std::string& name, CalibrationItem* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CalibrationItem>(
    CalibrationItem_descriptor(), name, value);
}
enum CalibrationStatus {
  UNSPECIFIED_CALIBRATION_STATUS = 0,
  NOT_CALIBRATED = 1,
  IN_PROGRESS = 2,
  CALIBRATED = 3,
  IN_FAULT = 4,
  CalibrationStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CalibrationStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CalibrationStatus_IsValid(int value);
const CalibrationStatus CalibrationStatus_MIN = UNSPECIFIED_CALIBRATION_STATUS;
const CalibrationStatus CalibrationStatus_MAX = IN_FAULT;
const int CalibrationStatus_ARRAYSIZE = CalibrationStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* CalibrationStatus_descriptor();
inline const ::std::string& CalibrationStatus_Name(CalibrationStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    CalibrationStatus_descriptor(), value);
}
inline bool CalibrationStatus_Parse(
    const ::std::string& name, CalibrationStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CalibrationStatus>(
    CalibrationStatus_descriptor(), name, value);
}
enum SafetyLimitType {
  UNSPECIFIED_SAFETY_LIMIT_TYPE = 0,
  MINIMAL_LIMIT = 1,
  MAXIMAL_LIMIT = 2,
  EVENT_LIMIT = 3,
  SafetyLimitType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SafetyLimitType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SafetyLimitType_IsValid(int value);
const SafetyLimitType SafetyLimitType_MIN = UNSPECIFIED_SAFETY_LIMIT_TYPE;
const SafetyLimitType SafetyLimitType_MAX = EVENT_LIMIT;
const int SafetyLimitType_ARRAYSIZE = SafetyLimitType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SafetyLimitType_descriptor();
inline const ::std::string& SafetyLimitType_Name(SafetyLimitType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SafetyLimitType_descriptor(), value);
}
inline bool SafetyLimitType_Parse(
    const ::std::string& name, SafetyLimitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SafetyLimitType>(
    SafetyLimitType_descriptor(), name, value);
}
enum CapSenseMode {
  RESERVED = 0,
  INACTIVE = 1,
  ACTIVE_AUTO_THRESHOLD = 2,
  ACTIVE_NOISE_ATT = 4,
  ACTIVE_NORMAL = 5,
  CONFIGURATION = 6,
  CapSenseMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CapSenseMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CapSenseMode_IsValid(int value);
const CapSenseMode CapSenseMode_MIN = RESERVED;
const CapSenseMode CapSenseMode_MAX = CONFIGURATION;
const int CapSenseMode_ARRAYSIZE = CapSenseMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CapSenseMode_descriptor();
inline const ::std::string& CapSenseMode_Name(CapSenseMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CapSenseMode_descriptor(), value);
}
inline bool CapSenseMode_Parse(
    const ::std::string& name, CapSenseMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CapSenseMode>(
    CapSenseMode_descriptor(), name, value);
}
// ===================================================================

class DeviceType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.DeviceType) */ {
 public:
  DeviceType();
  virtual ~DeviceType();

  DeviceType(const DeviceType& from);

  inline DeviceType& operator=(const DeviceType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceType(DeviceType&& from) noexcept
    : DeviceType() {
    *this = ::std::move(from);
  }

  inline DeviceType& operator=(DeviceType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceType* internal_default_instance() {
    return reinterpret_cast<const DeviceType*>(
               &_DeviceType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DeviceType* other);
  friend void swap(DeviceType& a, DeviceType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceType* New() const PROTOBUF_FINAL { return New(NULL); }

  DeviceType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeviceType& from);
  void MergeFrom(const DeviceType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeviceType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.DeviceTypes device_type = 1;
  void clear_device_type();
  static const int kDeviceTypeFieldNumber = 1;
  ::Kinova::Api::Common::DeviceTypes device_type() const;
  void set_device_type(::Kinova::Api::Common::DeviceTypes value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.DeviceType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int device_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsDeviceTypeImpl();
};
// -------------------------------------------------------------------

class RunMode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.RunMode) */ {
 public:
  RunMode();
  virtual ~RunMode();

  RunMode(const RunMode& from);

  inline RunMode& operator=(const RunMode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RunMode(RunMode&& from) noexcept
    : RunMode() {
    *this = ::std::move(from);
  }

  inline RunMode& operator=(RunMode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RunMode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunMode* internal_default_instance() {
    return reinterpret_cast<const RunMode*>(
               &_RunMode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RunMode* other);
  friend void swap(RunMode& a, RunMode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RunMode* New() const PROTOBUF_FINAL { return New(NULL); }

  RunMode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RunMode& from);
  void MergeFrom(const RunMode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RunMode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.DeviceConfig.RunModes run_mode = 1;
  void clear_run_mode();
  static const int kRunModeFieldNumber = 1;
  ::Kinova::Api::DeviceConfig::RunModes run_mode() const;
  void set_run_mode(::Kinova::Api::DeviceConfig::RunModes value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.RunMode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int run_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsRunModeImpl();
};
// -------------------------------------------------------------------

class FirmwareVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.FirmwareVersion) */ {
 public:
  FirmwareVersion();
  virtual ~FirmwareVersion();

  FirmwareVersion(const FirmwareVersion& from);

  inline FirmwareVersion& operator=(const FirmwareVersion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FirmwareVersion(FirmwareVersion&& from) noexcept
    : FirmwareVersion() {
    *this = ::std::move(from);
  }

  inline FirmwareVersion& operator=(FirmwareVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FirmwareVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FirmwareVersion* internal_default_instance() {
    return reinterpret_cast<const FirmwareVersion*>(
               &_FirmwareVersion_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(FirmwareVersion* other);
  friend void swap(FirmwareVersion& a, FirmwareVersion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FirmwareVersion* New() const PROTOBUF_FINAL { return New(NULL); }

  FirmwareVersion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FirmwareVersion& from);
  void MergeFrom(const FirmwareVersion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FirmwareVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 firmware_version = 1;
  void clear_firmware_version();
  static const int kFirmwareVersionFieldNumber = 1;
  ::google::protobuf::uint32 firmware_version() const;
  void set_firmware_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.FirmwareVersion)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 firmware_version_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsFirmwareVersionImpl();
};
// -------------------------------------------------------------------

class BootloaderVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.BootloaderVersion) */ {
 public:
  BootloaderVersion();
  virtual ~BootloaderVersion();

  BootloaderVersion(const BootloaderVersion& from);

  inline BootloaderVersion& operator=(const BootloaderVersion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BootloaderVersion(BootloaderVersion&& from) noexcept
    : BootloaderVersion() {
    *this = ::std::move(from);
  }

  inline BootloaderVersion& operator=(BootloaderVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BootloaderVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BootloaderVersion* internal_default_instance() {
    return reinterpret_cast<const BootloaderVersion*>(
               &_BootloaderVersion_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(BootloaderVersion* other);
  friend void swap(BootloaderVersion& a, BootloaderVersion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BootloaderVersion* New() const PROTOBUF_FINAL { return New(NULL); }

  BootloaderVersion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BootloaderVersion& from);
  void MergeFrom(const BootloaderVersion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BootloaderVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 bootloader_version = 1;
  void clear_bootloader_version();
  static const int kBootloaderVersionFieldNumber = 1;
  ::google::protobuf::uint32 bootloader_version() const;
  void set_bootloader_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.BootloaderVersion)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 bootloader_version_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsBootloaderVersionImpl();
};
// -------------------------------------------------------------------

class ModelNumber : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.ModelNumber) */ {
 public:
  ModelNumber();
  virtual ~ModelNumber();

  ModelNumber(const ModelNumber& from);

  inline ModelNumber& operator=(const ModelNumber& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModelNumber(ModelNumber&& from) noexcept
    : ModelNumber() {
    *this = ::std::move(from);
  }

  inline ModelNumber& operator=(ModelNumber&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelNumber& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelNumber* internal_default_instance() {
    return reinterpret_cast<const ModelNumber*>(
               &_ModelNumber_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ModelNumber* other);
  friend void swap(ModelNumber& a, ModelNumber& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModelNumber* New() const PROTOBUF_FINAL { return New(NULL); }

  ModelNumber* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ModelNumber& from);
  void MergeFrom(const ModelNumber& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ModelNumber* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string model_number = 1;
  void clear_model_number();
  static const int kModelNumberFieldNumber = 1;
  const ::std::string& model_number() const;
  void set_model_number(const ::std::string& value);
  #if LANG_CXX11
  void set_model_number(::std::string&& value);
  #endif
  void set_model_number(const char* value);
  void set_model_number(const char* value, size_t size);
  ::std::string* mutable_model_number();
  ::std::string* release_model_number();
  void set_allocated_model_number(::std::string* model_number);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.ModelNumber)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr model_number_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsModelNumberImpl();
};
// -------------------------------------------------------------------

class PartNumber : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.PartNumber) */ {
 public:
  PartNumber();
  virtual ~PartNumber();

  PartNumber(const PartNumber& from);

  inline PartNumber& operator=(const PartNumber& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartNumber(PartNumber&& from) noexcept
    : PartNumber() {
    *this = ::std::move(from);
  }

  inline PartNumber& operator=(PartNumber&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PartNumber& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartNumber* internal_default_instance() {
    return reinterpret_cast<const PartNumber*>(
               &_PartNumber_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(PartNumber* other);
  friend void swap(PartNumber& a, PartNumber& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartNumber* New() const PROTOBUF_FINAL { return New(NULL); }

  PartNumber* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PartNumber& from);
  void MergeFrom(const PartNumber& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PartNumber* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string part_number = 1;
  void clear_part_number();
  static const int kPartNumberFieldNumber = 1;
  const ::std::string& part_number() const;
  void set_part_number(const ::std::string& value);
  #if LANG_CXX11
  void set_part_number(::std::string&& value);
  #endif
  void set_part_number(const char* value);
  void set_part_number(const char* value, size_t size);
  ::std::string* mutable_part_number();
  ::std::string* release_part_number();
  void set_allocated_part_number(::std::string* part_number);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.PartNumber)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr part_number_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsPartNumberImpl();
};
// -------------------------------------------------------------------

class SerialNumber : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.SerialNumber) */ {
 public:
  SerialNumber();
  virtual ~SerialNumber();

  SerialNumber(const SerialNumber& from);

  inline SerialNumber& operator=(const SerialNumber& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SerialNumber(SerialNumber&& from) noexcept
    : SerialNumber() {
    *this = ::std::move(from);
  }

  inline SerialNumber& operator=(SerialNumber&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SerialNumber& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SerialNumber* internal_default_instance() {
    return reinterpret_cast<const SerialNumber*>(
               &_SerialNumber_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(SerialNumber* other);
  friend void swap(SerialNumber& a, SerialNumber& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SerialNumber* New() const PROTOBUF_FINAL { return New(NULL); }

  SerialNumber* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SerialNumber& from);
  void MergeFrom(const SerialNumber& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SerialNumber* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string serial_number = 1;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 1;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.SerialNumber)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsSerialNumberImpl();
};
// -------------------------------------------------------------------

class MACAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.MACAddress) */ {
 public:
  MACAddress();
  virtual ~MACAddress();

  MACAddress(const MACAddress& from);

  inline MACAddress& operator=(const MACAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MACAddress(MACAddress&& from) noexcept
    : MACAddress() {
    *this = ::std::move(from);
  }

  inline MACAddress& operator=(MACAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MACAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MACAddress* internal_default_instance() {
    return reinterpret_cast<const MACAddress*>(
               &_MACAddress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(MACAddress* other);
  friend void swap(MACAddress& a, MACAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MACAddress* New() const PROTOBUF_FINAL { return New(NULL); }

  MACAddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MACAddress& from);
  void MergeFrom(const MACAddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MACAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes mac_address = 1;
  void clear_mac_address();
  static const int kMacAddressFieldNumber = 1;
  const ::std::string& mac_address() const;
  void set_mac_address(const ::std::string& value);
  #if LANG_CXX11
  void set_mac_address(::std::string&& value);
  #endif
  void set_mac_address(const char* value);
  void set_mac_address(const void* value, size_t size);
  ::std::string* mutable_mac_address();
  ::std::string* release_mac_address();
  void set_allocated_mac_address(::std::string* mac_address);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.MACAddress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr mac_address_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsMACAddressImpl();
};
// -------------------------------------------------------------------

class IPv4Settings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.IPv4Settings) */ {
 public:
  IPv4Settings();
  virtual ~IPv4Settings();

  IPv4Settings(const IPv4Settings& from);

  inline IPv4Settings& operator=(const IPv4Settings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IPv4Settings(IPv4Settings&& from) noexcept
    : IPv4Settings() {
    *this = ::std::move(from);
  }

  inline IPv4Settings& operator=(IPv4Settings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IPv4Settings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IPv4Settings* internal_default_instance() {
    return reinterpret_cast<const IPv4Settings*>(
               &_IPv4Settings_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(IPv4Settings* other);
  friend void swap(IPv4Settings& a, IPv4Settings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IPv4Settings* New() const PROTOBUF_FINAL { return New(NULL); }

  IPv4Settings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IPv4Settings& from);
  void MergeFrom(const IPv4Settings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IPv4Settings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ipv4_address = 1;
  void clear_ipv4_address();
  static const int kIpv4AddressFieldNumber = 1;
  ::google::protobuf::uint32 ipv4_address() const;
  void set_ipv4_address(::google::protobuf::uint32 value);

  // uint32 ipv4_subnet_mask = 2;
  void clear_ipv4_subnet_mask();
  static const int kIpv4SubnetMaskFieldNumber = 2;
  ::google::protobuf::uint32 ipv4_subnet_mask() const;
  void set_ipv4_subnet_mask(::google::protobuf::uint32 value);

  // uint32 ipv4_default_gateway = 3;
  void clear_ipv4_default_gateway();
  static const int kIpv4DefaultGatewayFieldNumber = 3;
  ::google::protobuf::uint32 ipv4_default_gateway() const;
  void set_ipv4_default_gateway(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.IPv4Settings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 ipv4_address_;
  ::google::protobuf::uint32 ipv4_subnet_mask_;
  ::google::protobuf::uint32 ipv4_default_gateway_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsIPv4SettingsImpl();
};
// -------------------------------------------------------------------

class PartNumberRevision : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.PartNumberRevision) */ {
 public:
  PartNumberRevision();
  virtual ~PartNumberRevision();

  PartNumberRevision(const PartNumberRevision& from);

  inline PartNumberRevision& operator=(const PartNumberRevision& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartNumberRevision(PartNumberRevision&& from) noexcept
    : PartNumberRevision() {
    *this = ::std::move(from);
  }

  inline PartNumberRevision& operator=(PartNumberRevision&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PartNumberRevision& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartNumberRevision* internal_default_instance() {
    return reinterpret_cast<const PartNumberRevision*>(
               &_PartNumberRevision_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(PartNumberRevision* other);
  friend void swap(PartNumberRevision& a, PartNumberRevision& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartNumberRevision* New() const PROTOBUF_FINAL { return New(NULL); }

  PartNumberRevision* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PartNumberRevision& from);
  void MergeFrom(const PartNumberRevision& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PartNumberRevision* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string part_number_revision = 1;
  void clear_part_number_revision();
  static const int kPartNumberRevisionFieldNumber = 1;
  const ::std::string& part_number_revision() const;
  void set_part_number_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_part_number_revision(::std::string&& value);
  #endif
  void set_part_number_revision(const char* value);
  void set_part_number_revision(const char* value, size_t size);
  ::std::string* mutable_part_number_revision();
  ::std::string* release_part_number_revision();
  void set_allocated_part_number_revision(::std::string* part_number_revision);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.PartNumberRevision)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr part_number_revision_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsPartNumberRevisionImpl();
};
// -------------------------------------------------------------------

class PowerOnSelfTestResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.PowerOnSelfTestResult) */ {
 public:
  PowerOnSelfTestResult();
  virtual ~PowerOnSelfTestResult();

  PowerOnSelfTestResult(const PowerOnSelfTestResult& from);

  inline PowerOnSelfTestResult& operator=(const PowerOnSelfTestResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PowerOnSelfTestResult(PowerOnSelfTestResult&& from) noexcept
    : PowerOnSelfTestResult() {
    *this = ::std::move(from);
  }

  inline PowerOnSelfTestResult& operator=(PowerOnSelfTestResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PowerOnSelfTestResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PowerOnSelfTestResult* internal_default_instance() {
    return reinterpret_cast<const PowerOnSelfTestResult*>(
               &_PowerOnSelfTestResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(PowerOnSelfTestResult* other);
  friend void swap(PowerOnSelfTestResult& a, PowerOnSelfTestResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PowerOnSelfTestResult* New() const PROTOBUF_FINAL { return New(NULL); }

  PowerOnSelfTestResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PowerOnSelfTestResult& from);
  void MergeFrom(const PowerOnSelfTestResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PowerOnSelfTestResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 power_on_self_test_result = 1;
  void clear_power_on_self_test_result();
  static const int kPowerOnSelfTestResultFieldNumber = 1;
  ::google::protobuf::uint32 power_on_self_test_result() const;
  void set_power_on_self_test_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.PowerOnSelfTestResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 power_on_self_test_result_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsPowerOnSelfTestResultImpl();
};
// -------------------------------------------------------------------

class RebootRqst : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.RebootRqst) */ {
 public:
  RebootRqst();
  virtual ~RebootRqst();

  RebootRqst(const RebootRqst& from);

  inline RebootRqst& operator=(const RebootRqst& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RebootRqst(RebootRqst&& from) noexcept
    : RebootRqst() {
    *this = ::std::move(from);
  }

  inline RebootRqst& operator=(RebootRqst&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RebootRqst& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RebootRqst* internal_default_instance() {
    return reinterpret_cast<const RebootRqst*>(
               &_RebootRqst_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(RebootRqst* other);
  friend void swap(RebootRqst& a, RebootRqst& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RebootRqst* New() const PROTOBUF_FINAL { return New(NULL); }

  RebootRqst* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RebootRqst& from);
  void MergeFrom(const RebootRqst& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RebootRqst* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 delay = 1;
  void clear_delay();
  static const int kDelayFieldNumber = 1;
  ::google::protobuf::uint32 delay() const;
  void set_delay(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.RebootRqst)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 delay_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsRebootRqstImpl();
};
// -------------------------------------------------------------------

class SafetyInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.SafetyInformation) */ {
 public:
  SafetyInformation();
  virtual ~SafetyInformation();

  SafetyInformation(const SafetyInformation& from);

  inline SafetyInformation& operator=(const SafetyInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SafetyInformation(SafetyInformation&& from) noexcept
    : SafetyInformation() {
    *this = ::std::move(from);
  }

  inline SafetyInformation& operator=(SafetyInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SafetyInformation* internal_default_instance() {
    return reinterpret_cast<const SafetyInformation*>(
               &_SafetyInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(SafetyInformation* other);
  friend void swap(SafetyInformation& a, SafetyInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SafetyInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  SafetyInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SafetyInformation& from);
  void MergeFrom(const SafetyInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SafetyInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.SafetyHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Common::SafetyHandle& handle() const;
  ::Kinova::Api::Common::SafetyHandle* release_handle();
  ::Kinova::Api::Common::SafetyHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Common::SafetyHandle* handle);

  // bool can_change_safety_state = 2;
  void clear_can_change_safety_state();
  static const int kCanChangeSafetyStateFieldNumber = 2;
  bool can_change_safety_state() const;
  void set_can_change_safety_state(bool value);

  // bool has_warning_threshold = 3;
  void clear_has_warning_threshold();
  static const int kHasWarningThresholdFieldNumber = 3;
  bool has_warning_threshold() const;
  void set_has_warning_threshold(bool value);

  // bool has_error_threshold = 4;
  void clear_has_error_threshold();
  static const int kHasErrorThresholdFieldNumber = 4;
  bool has_error_threshold() const;
  void set_has_error_threshold(bool value);

  // .Kinova.Api.DeviceConfig.SafetyLimitType limit_type = 5;
  void clear_limit_type();
  static const int kLimitTypeFieldNumber = 5;
  ::Kinova::Api::DeviceConfig::SafetyLimitType limit_type() const;
  void set_limit_type(::Kinova::Api::DeviceConfig::SafetyLimitType value);

  // float default_warning_threshold = 6;
  void clear_default_warning_threshold();
  static const int kDefaultWarningThresholdFieldNumber = 6;
  float default_warning_threshold() const;
  void set_default_warning_threshold(float value);

  // float default_error_threshold = 7;
  void clear_default_error_threshold();
  static const int kDefaultErrorThresholdFieldNumber = 7;
  float default_error_threshold() const;
  void set_default_error_threshold(float value);

  // float upper_hard_limit = 8;
  void clear_upper_hard_limit();
  static const int kUpperHardLimitFieldNumber = 8;
  float upper_hard_limit() const;
  void set_upper_hard_limit(float value);

  // float lower_hard_limit = 9;
  void clear_lower_hard_limit();
  static const int kLowerHardLimitFieldNumber = 9;
  float lower_hard_limit() const;
  void set_lower_hard_limit(float value);

  // .Kinova.Api.Common.SafetyStatusValue status = 11;
  void clear_status();
  static const int kStatusFieldNumber = 11;
  ::Kinova::Api::Common::SafetyStatusValue status() const;
  void set_status(::Kinova::Api::Common::SafetyStatusValue value);

  // .Kinova.Api.Common.Unit unit = 12;
  void clear_unit();
  static const int kUnitFieldNumber = 12;
  ::Kinova::Api::Common::Unit unit() const;
  void set_unit(::Kinova::Api::Common::Unit value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.SafetyInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::SafetyHandle* handle_;
  bool can_change_safety_state_;
  bool has_warning_threshold_;
  bool has_error_threshold_;
  int limit_type_;
  float default_warning_threshold_;
  float default_error_threshold_;
  float upper_hard_limit_;
  float lower_hard_limit_;
  int status_;
  int unit_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsSafetyInformationImpl();
};
// -------------------------------------------------------------------

class SafetyInformationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.SafetyInformationList) */ {
 public:
  SafetyInformationList();
  virtual ~SafetyInformationList();

  SafetyInformationList(const SafetyInformationList& from);

  inline SafetyInformationList& operator=(const SafetyInformationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SafetyInformationList(SafetyInformationList&& from) noexcept
    : SafetyInformationList() {
    *this = ::std::move(from);
  }

  inline SafetyInformationList& operator=(SafetyInformationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyInformationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SafetyInformationList* internal_default_instance() {
    return reinterpret_cast<const SafetyInformationList*>(
               &_SafetyInformationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(SafetyInformationList* other);
  friend void swap(SafetyInformationList& a, SafetyInformationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SafetyInformationList* New() const PROTOBUF_FINAL { return New(NULL); }

  SafetyInformationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SafetyInformationList& from);
  void MergeFrom(const SafetyInformationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SafetyInformationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.DeviceConfig.SafetyInformation information = 1;
  int information_size() const;
  void clear_information();
  static const int kInformationFieldNumber = 1;
  const ::Kinova::Api::DeviceConfig::SafetyInformation& information(int index) const;
  ::Kinova::Api::DeviceConfig::SafetyInformation* mutable_information(int index);
  ::Kinova::Api::DeviceConfig::SafetyInformation* add_information();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::SafetyInformation >*
      mutable_information();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::SafetyInformation >&
      information() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.SafetyInformationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::SafetyInformation > information_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsSafetyInformationListImpl();
};
// -------------------------------------------------------------------

class SafetyEnable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.SafetyEnable) */ {
 public:
  SafetyEnable();
  virtual ~SafetyEnable();

  SafetyEnable(const SafetyEnable& from);

  inline SafetyEnable& operator=(const SafetyEnable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SafetyEnable(SafetyEnable&& from) noexcept
    : SafetyEnable() {
    *this = ::std::move(from);
  }

  inline SafetyEnable& operator=(SafetyEnable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyEnable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SafetyEnable* internal_default_instance() {
    return reinterpret_cast<const SafetyEnable*>(
               &_SafetyEnable_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(SafetyEnable* other);
  friend void swap(SafetyEnable& a, SafetyEnable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SafetyEnable* New() const PROTOBUF_FINAL { return New(NULL); }

  SafetyEnable* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SafetyEnable& from);
  void MergeFrom(const SafetyEnable& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SafetyEnable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.SafetyHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Common::SafetyHandle& handle() const;
  ::Kinova::Api::Common::SafetyHandle* release_handle();
  ::Kinova::Api::Common::SafetyHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Common::SafetyHandle* handle);

  // bool enable = 2;
  void clear_enable();
  static const int kEnableFieldNumber = 2;
  bool enable() const;
  void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.SafetyEnable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::SafetyHandle* handle_;
  bool enable_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsSafetyEnableImpl();
};
// -------------------------------------------------------------------

class SafetyThreshold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.SafetyThreshold) */ {
 public:
  SafetyThreshold();
  virtual ~SafetyThreshold();

  SafetyThreshold(const SafetyThreshold& from);

  inline SafetyThreshold& operator=(const SafetyThreshold& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SafetyThreshold(SafetyThreshold&& from) noexcept
    : SafetyThreshold() {
    *this = ::std::move(from);
  }

  inline SafetyThreshold& operator=(SafetyThreshold&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyThreshold& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SafetyThreshold* internal_default_instance() {
    return reinterpret_cast<const SafetyThreshold*>(
               &_SafetyThreshold_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(SafetyThreshold* other);
  friend void swap(SafetyThreshold& a, SafetyThreshold& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SafetyThreshold* New() const PROTOBUF_FINAL { return New(NULL); }

  SafetyThreshold* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SafetyThreshold& from);
  void MergeFrom(const SafetyThreshold& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SafetyThreshold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.SafetyHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Common::SafetyHandle& handle() const;
  ::Kinova::Api::Common::SafetyHandle* release_handle();
  ::Kinova::Api::Common::SafetyHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Common::SafetyHandle* handle);

  // float value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.SafetyThreshold)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::SafetyHandle* handle_;
  float value_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsSafetyThresholdImpl();
};
// -------------------------------------------------------------------

class SafetyConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.SafetyConfiguration) */ {
 public:
  SafetyConfiguration();
  virtual ~SafetyConfiguration();

  SafetyConfiguration(const SafetyConfiguration& from);

  inline SafetyConfiguration& operator=(const SafetyConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SafetyConfiguration(SafetyConfiguration&& from) noexcept
    : SafetyConfiguration() {
    *this = ::std::move(from);
  }

  inline SafetyConfiguration& operator=(SafetyConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SafetyConfiguration* internal_default_instance() {
    return reinterpret_cast<const SafetyConfiguration*>(
               &_SafetyConfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(SafetyConfiguration* other);
  friend void swap(SafetyConfiguration& a, SafetyConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SafetyConfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  SafetyConfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SafetyConfiguration& from);
  void MergeFrom(const SafetyConfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SafetyConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.SafetyHandle handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::Kinova::Api::Common::SafetyHandle& handle() const;
  ::Kinova::Api::Common::SafetyHandle* release_handle();
  ::Kinova::Api::Common::SafetyHandle* mutable_handle();
  void set_allocated_handle(::Kinova::Api::Common::SafetyHandle* handle);

  // .Kinova.Api.DeviceConfig.SafetyEnable enable = 4;
  bool has_enable() const;
  void clear_enable();
  static const int kEnableFieldNumber = 4;
  const ::Kinova::Api::DeviceConfig::SafetyEnable& enable() const;
  ::Kinova::Api::DeviceConfig::SafetyEnable* release_enable();
  ::Kinova::Api::DeviceConfig::SafetyEnable* mutable_enable();
  void set_allocated_enable(::Kinova::Api::DeviceConfig::SafetyEnable* enable);

  // float error_threshold = 2;
  void clear_error_threshold();
  static const int kErrorThresholdFieldNumber = 2;
  float error_threshold() const;
  void set_error_threshold(float value);

  // float warning_threshold = 3;
  void clear_warning_threshold();
  static const int kWarningThresholdFieldNumber = 3;
  float warning_threshold() const;
  void set_warning_threshold(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.SafetyConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::SafetyHandle* handle_;
  ::Kinova::Api::DeviceConfig::SafetyEnable* enable_;
  float error_threshold_;
  float warning_threshold_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsSafetyConfigurationImpl();
};
// -------------------------------------------------------------------

class SafetyConfigurationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.SafetyConfigurationList) */ {
 public:
  SafetyConfigurationList();
  virtual ~SafetyConfigurationList();

  SafetyConfigurationList(const SafetyConfigurationList& from);

  inline SafetyConfigurationList& operator=(const SafetyConfigurationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SafetyConfigurationList(SafetyConfigurationList&& from) noexcept
    : SafetyConfigurationList() {
    *this = ::std::move(from);
  }

  inline SafetyConfigurationList& operator=(SafetyConfigurationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyConfigurationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SafetyConfigurationList* internal_default_instance() {
    return reinterpret_cast<const SafetyConfigurationList*>(
               &_SafetyConfigurationList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(SafetyConfigurationList* other);
  friend void swap(SafetyConfigurationList& a, SafetyConfigurationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SafetyConfigurationList* New() const PROTOBUF_FINAL { return New(NULL); }

  SafetyConfigurationList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SafetyConfigurationList& from);
  void MergeFrom(const SafetyConfigurationList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SafetyConfigurationList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.DeviceConfig.SafetyConfiguration configuration = 1;
  int configuration_size() const;
  void clear_configuration();
  static const int kConfigurationFieldNumber = 1;
  const ::Kinova::Api::DeviceConfig::SafetyConfiguration& configuration(int index) const;
  ::Kinova::Api::DeviceConfig::SafetyConfiguration* mutable_configuration(int index);
  ::Kinova::Api::DeviceConfig::SafetyConfiguration* add_configuration();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::SafetyConfiguration >*
      mutable_configuration();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::SafetyConfiguration >&
      configuration() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.SafetyConfigurationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::SafetyConfiguration > configuration_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsSafetyConfigurationListImpl();
};
// -------------------------------------------------------------------

class SafetyStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.SafetyStatus) */ {
 public:
  SafetyStatus();
  virtual ~SafetyStatus();

  SafetyStatus(const SafetyStatus& from);

  inline SafetyStatus& operator=(const SafetyStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SafetyStatus(SafetyStatus&& from) noexcept
    : SafetyStatus() {
    *this = ::std::move(from);
  }

  inline SafetyStatus& operator=(SafetyStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SafetyStatus* internal_default_instance() {
    return reinterpret_cast<const SafetyStatus*>(
               &_SafetyStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(SafetyStatus* other);
  friend void swap(SafetyStatus& a, SafetyStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SafetyStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  SafetyStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SafetyStatus& from);
  void MergeFrom(const SafetyStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SafetyStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.SafetyStatusValue value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::Kinova::Api::Common::SafetyStatusValue value() const;
  void set_value(::Kinova::Api::Common::SafetyStatusValue value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.SafetyStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsSafetyStatusImpl();
};
// -------------------------------------------------------------------

class CalibrationParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.CalibrationParameter) */ {
 public:
  CalibrationParameter();
  virtual ~CalibrationParameter();

  CalibrationParameter(const CalibrationParameter& from);

  inline CalibrationParameter& operator=(const CalibrationParameter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CalibrationParameter(CalibrationParameter&& from) noexcept
    : CalibrationParameter() {
    *this = ::std::move(from);
  }

  inline CalibrationParameter& operator=(CalibrationParameter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationParameter& default_instance();

  enum ValueCase {
    kSignedIntValue = 2,
    kUnsignedIntValue = 3,
    kFloatValue = 4,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CalibrationParameter* internal_default_instance() {
    return reinterpret_cast<const CalibrationParameter*>(
               &_CalibrationParameter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(CalibrationParameter* other);
  friend void swap(CalibrationParameter& a, CalibrationParameter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CalibrationParameter* New() const PROTOBUF_FINAL { return New(NULL); }

  CalibrationParameter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CalibrationParameter& from);
  void MergeFrom(const CalibrationParameter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CalibrationParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 calibration_parameter_identifier = 1;
  void clear_calibration_parameter_identifier();
  static const int kCalibrationParameterIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 calibration_parameter_identifier() const;
  void set_calibration_parameter_identifier(::google::protobuf::uint32 value);

  // int32 signedIntValue = 2;
  private:
  bool has_signedintvalue() const;
  public:
  void clear_signedintvalue();
  static const int kSignedIntValueFieldNumber = 2;
  ::google::protobuf::int32 signedintvalue() const;
  void set_signedintvalue(::google::protobuf::int32 value);

  // uint32 unsignedIntValue = 3;
  private:
  bool has_unsignedintvalue() const;
  public:
  void clear_unsignedintvalue();
  static const int kUnsignedIntValueFieldNumber = 3;
  ::google::protobuf::uint32 unsignedintvalue() const;
  void set_unsignedintvalue(::google::protobuf::uint32 value);

  // float floatValue = 4;
  private:
  bool has_floatvalue() const;
  public:
  void clear_floatvalue();
  static const int kFloatValueFieldNumber = 4;
  float floatvalue() const;
  void set_floatvalue(float value);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.CalibrationParameter)
 private:
  void set_has_signedintvalue();
  void set_has_unsignedintvalue();
  void set_has_floatvalue();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 calibration_parameter_identifier_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::int32 signedintvalue_;
    ::google::protobuf::uint32 unsignedintvalue_;
    float floatvalue_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsCalibrationParameterImpl();
};
// -------------------------------------------------------------------

class Calibration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.Calibration) */ {
 public:
  Calibration();
  virtual ~Calibration();

  Calibration(const Calibration& from);

  inline Calibration& operator=(const Calibration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Calibration(Calibration&& from) noexcept
    : Calibration() {
    *this = ::std::move(from);
  }

  inline Calibration& operator=(Calibration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Calibration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Calibration* internal_default_instance() {
    return reinterpret_cast<const Calibration*>(
               &_Calibration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(Calibration* other);
  friend void swap(Calibration& a, Calibration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Calibration* New() const PROTOBUF_FINAL { return New(NULL); }

  Calibration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Calibration& from);
  void MergeFrom(const Calibration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Calibration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.DeviceConfig.CalibrationParameter calibration_parameter = 2;
  int calibration_parameter_size() const;
  void clear_calibration_parameter();
  static const int kCalibrationParameterFieldNumber = 2;
  const ::Kinova::Api::DeviceConfig::CalibrationParameter& calibration_parameter(int index) const;
  ::Kinova::Api::DeviceConfig::CalibrationParameter* mutable_calibration_parameter(int index);
  ::Kinova::Api::DeviceConfig::CalibrationParameter* add_calibration_parameter();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::CalibrationParameter >*
      mutable_calibration_parameter();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::CalibrationParameter >&
      calibration_parameter() const;

  // .Kinova.Api.DeviceConfig.CalibrationItem calibration_item = 1;
  void clear_calibration_item();
  static const int kCalibrationItemFieldNumber = 1;
  ::Kinova::Api::DeviceConfig::CalibrationItem calibration_item() const;
  void set_calibration_item(::Kinova::Api::DeviceConfig::CalibrationItem value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.Calibration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::CalibrationParameter > calibration_parameter_;
  int calibration_item_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsCalibrationImpl();
};
// -------------------------------------------------------------------

class CalibrationElement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.CalibrationElement) */ {
 public:
  CalibrationElement();
  virtual ~CalibrationElement();

  CalibrationElement(const CalibrationElement& from);

  inline CalibrationElement& operator=(const CalibrationElement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CalibrationElement(CalibrationElement&& from) noexcept
    : CalibrationElement() {
    *this = ::std::move(from);
  }

  inline CalibrationElement& operator=(CalibrationElement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationElement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CalibrationElement* internal_default_instance() {
    return reinterpret_cast<const CalibrationElement*>(
               &_CalibrationElement_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(CalibrationElement* other);
  friend void swap(CalibrationElement& a, CalibrationElement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CalibrationElement* New() const PROTOBUF_FINAL { return New(NULL); }

  CalibrationElement* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CalibrationElement& from);
  void MergeFrom(const CalibrationElement& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CalibrationElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.DeviceConfig.CalibrationItem calibration_item = 1;
  void clear_calibration_item();
  static const int kCalibrationItemFieldNumber = 1;
  ::Kinova::Api::DeviceConfig::CalibrationItem calibration_item() const;
  void set_calibration_item(::Kinova::Api::DeviceConfig::CalibrationItem value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.CalibrationElement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int calibration_item_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsCalibrationElementImpl();
};
// -------------------------------------------------------------------

class CalibrationResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.CalibrationResult) */ {
 public:
  CalibrationResult();
  virtual ~CalibrationResult();

  CalibrationResult(const CalibrationResult& from);

  inline CalibrationResult& operator=(const CalibrationResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CalibrationResult(CalibrationResult&& from) noexcept
    : CalibrationResult() {
    *this = ::std::move(from);
  }

  inline CalibrationResult& operator=(CalibrationResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CalibrationResult* internal_default_instance() {
    return reinterpret_cast<const CalibrationResult*>(
               &_CalibrationResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(CalibrationResult* other);
  friend void swap(CalibrationResult& a, CalibrationResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CalibrationResult* New() const PROTOBUF_FINAL { return New(NULL); }

  CalibrationResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CalibrationResult& from);
  void MergeFrom(const CalibrationResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CalibrationResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.DeviceConfig.CalibrationStatus calibration_status = 1;
  void clear_calibration_status();
  static const int kCalibrationStatusFieldNumber = 1;
  ::Kinova::Api::DeviceConfig::CalibrationStatus calibration_status() const;
  void set_calibration_status(::Kinova::Api::DeviceConfig::CalibrationStatus value);

  // uint32 calibration_details = 2;
  void clear_calibration_details();
  static const int kCalibrationDetailsFieldNumber = 2;
  ::google::protobuf::uint32 calibration_details() const;
  void set_calibration_details(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.CalibrationResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int calibration_status_;
  ::google::protobuf::uint32 calibration_details_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsCalibrationResultImpl();
};
// -------------------------------------------------------------------

class CapSenseConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.CapSenseConfig) */ {
 public:
  CapSenseConfig();
  virtual ~CapSenseConfig();

  CapSenseConfig(const CapSenseConfig& from);

  inline CapSenseConfig& operator=(const CapSenseConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CapSenseConfig(CapSenseConfig&& from) noexcept
    : CapSenseConfig() {
    *this = ::std::move(from);
  }

  inline CapSenseConfig& operator=(CapSenseConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CapSenseConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CapSenseConfig* internal_default_instance() {
    return reinterpret_cast<const CapSenseConfig*>(
               &_CapSenseConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(CapSenseConfig* other);
  friend void swap(CapSenseConfig& a, CapSenseConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CapSenseConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  CapSenseConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CapSenseConfig& from);
  void MergeFrom(const CapSenseConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CapSenseConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.DeviceConfig.CapSenseMode mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::Kinova::Api::DeviceConfig::CapSenseMode mode() const;
  void set_mode(::Kinova::Api::DeviceConfig::CapSenseMode value);

  // float threshold_a = 2;
  void clear_threshold_a();
  static const int kThresholdAFieldNumber = 2;
  float threshold_a() const;
  void set_threshold_a(float value);

  // float threshold_b = 3;
  void clear_threshold_b();
  static const int kThresholdBFieldNumber = 3;
  float threshold_b() const;
  void set_threshold_b(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.CapSenseConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int mode_;
  float threshold_a_;
  float threshold_b_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsCapSenseConfigImpl();
};
// -------------------------------------------------------------------

class CapSenseRegister : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.DeviceConfig.CapSenseRegister) */ {
 public:
  CapSenseRegister();
  virtual ~CapSenseRegister();

  CapSenseRegister(const CapSenseRegister& from);

  inline CapSenseRegister& operator=(const CapSenseRegister& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CapSenseRegister(CapSenseRegister&& from) noexcept
    : CapSenseRegister() {
    *this = ::std::move(from);
  }

  inline CapSenseRegister& operator=(CapSenseRegister&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CapSenseRegister& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CapSenseRegister* internal_default_instance() {
    return reinterpret_cast<const CapSenseRegister*>(
               &_CapSenseRegister_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(CapSenseRegister* other);
  friend void swap(CapSenseRegister& a, CapSenseRegister& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CapSenseRegister* New() const PROTOBUF_FINAL { return New(NULL); }

  CapSenseRegister* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CapSenseRegister& from);
  void MergeFrom(const CapSenseRegister& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CapSenseRegister* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  ::google::protobuf::uint32 address() const;
  void set_address(::google::protobuf::uint32 value);

  // uint32 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.DeviceConfig.CapSenseRegister)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 address_;
  ::google::protobuf::uint32 value_;
  mutable int _cached_size_;
  friend struct ::protobuf_DeviceConfig_2eproto::TableStruct;
  friend void ::protobuf_DeviceConfig_2eproto::InitDefaultsCapSenseRegisterImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DeviceType

// .Kinova.Api.Common.DeviceTypes device_type = 1;
inline void DeviceType::clear_device_type() {
  device_type_ = 0;
}
inline ::Kinova::Api::Common::DeviceTypes DeviceType::device_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.DeviceType.device_type)
  return static_cast< ::Kinova::Api::Common::DeviceTypes >(device_type_);
}
inline void DeviceType::set_device_type(::Kinova::Api::Common::DeviceTypes value) {
  
  device_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.DeviceType.device_type)
}

// -------------------------------------------------------------------

// RunMode

// .Kinova.Api.DeviceConfig.RunModes run_mode = 1;
inline void RunMode::clear_run_mode() {
  run_mode_ = 0;
}
inline ::Kinova::Api::DeviceConfig::RunModes RunMode::run_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.RunMode.run_mode)
  return static_cast< ::Kinova::Api::DeviceConfig::RunModes >(run_mode_);
}
inline void RunMode::set_run_mode(::Kinova::Api::DeviceConfig::RunModes value) {
  
  run_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.RunMode.run_mode)
}

// -------------------------------------------------------------------

// FirmwareVersion

// uint32 firmware_version = 1;
inline void FirmwareVersion::clear_firmware_version() {
  firmware_version_ = 0u;
}
inline ::google::protobuf::uint32 FirmwareVersion::firmware_version() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.FirmwareVersion.firmware_version)
  return firmware_version_;
}
inline void FirmwareVersion::set_firmware_version(::google::protobuf::uint32 value) {
  
  firmware_version_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.FirmwareVersion.firmware_version)
}

// -------------------------------------------------------------------

// BootloaderVersion

// uint32 bootloader_version = 1;
inline void BootloaderVersion::clear_bootloader_version() {
  bootloader_version_ = 0u;
}
inline ::google::protobuf::uint32 BootloaderVersion::bootloader_version() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.BootloaderVersion.bootloader_version)
  return bootloader_version_;
}
inline void BootloaderVersion::set_bootloader_version(::google::protobuf::uint32 value) {
  
  bootloader_version_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.BootloaderVersion.bootloader_version)
}

// -------------------------------------------------------------------

// ModelNumber

// string model_number = 1;
inline void ModelNumber::clear_model_number() {
  model_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModelNumber::model_number() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.ModelNumber.model_number)
  return model_number_.GetNoArena();
}
inline void ModelNumber::set_model_number(const ::std::string& value) {
  
  model_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.ModelNumber.model_number)
}
#if LANG_CXX11
inline void ModelNumber::set_model_number(::std::string&& value) {
  
  model_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.DeviceConfig.ModelNumber.model_number)
}
#endif
inline void ModelNumber::set_model_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  model_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.DeviceConfig.ModelNumber.model_number)
}
inline void ModelNumber::set_model_number(const char* value, size_t size) {
  
  model_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.DeviceConfig.ModelNumber.model_number)
}
inline ::std::string* ModelNumber::mutable_model_number() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.DeviceConfig.ModelNumber.model_number)
  return model_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelNumber::release_model_number() {
  // @@protoc_insertion_point(field_release:Kinova.Api.DeviceConfig.ModelNumber.model_number)
  
  return model_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelNumber::set_allocated_model_number(::std::string* model_number) {
  if (model_number != NULL) {
    
  } else {
    
  }
  model_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_number);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.DeviceConfig.ModelNumber.model_number)
}

// -------------------------------------------------------------------

// PartNumber

// string part_number = 1;
inline void PartNumber::clear_part_number() {
  part_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartNumber::part_number() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.PartNumber.part_number)
  return part_number_.GetNoArena();
}
inline void PartNumber::set_part_number(const ::std::string& value) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.PartNumber.part_number)
}
#if LANG_CXX11
inline void PartNumber::set_part_number(::std::string&& value) {
  
  part_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.DeviceConfig.PartNumber.part_number)
}
#endif
inline void PartNumber::set_part_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.DeviceConfig.PartNumber.part_number)
}
inline void PartNumber::set_part_number(const char* value, size_t size) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.DeviceConfig.PartNumber.part_number)
}
inline ::std::string* PartNumber::mutable_part_number() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.DeviceConfig.PartNumber.part_number)
  return part_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartNumber::release_part_number() {
  // @@protoc_insertion_point(field_release:Kinova.Api.DeviceConfig.PartNumber.part_number)
  
  return part_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartNumber::set_allocated_part_number(::std::string* part_number) {
  if (part_number != NULL) {
    
  } else {
    
  }
  part_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), part_number);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.DeviceConfig.PartNumber.part_number)
}

// -------------------------------------------------------------------

// SerialNumber

// string serial_number = 1;
inline void SerialNumber::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SerialNumber::serial_number() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SerialNumber.serial_number)
  return serial_number_.GetNoArena();
}
inline void SerialNumber::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SerialNumber.serial_number)
}
#if LANG_CXX11
inline void SerialNumber::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.DeviceConfig.SerialNumber.serial_number)
}
#endif
inline void SerialNumber::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.DeviceConfig.SerialNumber.serial_number)
}
inline void SerialNumber::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.DeviceConfig.SerialNumber.serial_number)
}
inline ::std::string* SerialNumber::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.DeviceConfig.SerialNumber.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SerialNumber::release_serial_number() {
  // @@protoc_insertion_point(field_release:Kinova.Api.DeviceConfig.SerialNumber.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SerialNumber::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.DeviceConfig.SerialNumber.serial_number)
}

// -------------------------------------------------------------------

// MACAddress

// bytes mac_address = 1;
inline void MACAddress::clear_mac_address() {
  mac_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MACAddress::mac_address() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.MACAddress.mac_address)
  return mac_address_.GetNoArena();
}
inline void MACAddress::set_mac_address(const ::std::string& value) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.MACAddress.mac_address)
}
#if LANG_CXX11
inline void MACAddress::set_mac_address(::std::string&& value) {
  
  mac_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.DeviceConfig.MACAddress.mac_address)
}
#endif
inline void MACAddress::set_mac_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.DeviceConfig.MACAddress.mac_address)
}
inline void MACAddress::set_mac_address(const void* value, size_t size) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.DeviceConfig.MACAddress.mac_address)
}
inline ::std::string* MACAddress::mutable_mac_address() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.DeviceConfig.MACAddress.mac_address)
  return mac_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MACAddress::release_mac_address() {
  // @@protoc_insertion_point(field_release:Kinova.Api.DeviceConfig.MACAddress.mac_address)
  
  return mac_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MACAddress::set_allocated_mac_address(::std::string* mac_address) {
  if (mac_address != NULL) {
    
  } else {
    
  }
  mac_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mac_address);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.DeviceConfig.MACAddress.mac_address)
}

// -------------------------------------------------------------------

// IPv4Settings

// uint32 ipv4_address = 1;
inline void IPv4Settings::clear_ipv4_address() {
  ipv4_address_ = 0u;
}
inline ::google::protobuf::uint32 IPv4Settings::ipv4_address() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.IPv4Settings.ipv4_address)
  return ipv4_address_;
}
inline void IPv4Settings::set_ipv4_address(::google::protobuf::uint32 value) {
  
  ipv4_address_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.IPv4Settings.ipv4_address)
}

// uint32 ipv4_subnet_mask = 2;
inline void IPv4Settings::clear_ipv4_subnet_mask() {
  ipv4_subnet_mask_ = 0u;
}
inline ::google::protobuf::uint32 IPv4Settings::ipv4_subnet_mask() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.IPv4Settings.ipv4_subnet_mask)
  return ipv4_subnet_mask_;
}
inline void IPv4Settings::set_ipv4_subnet_mask(::google::protobuf::uint32 value) {
  
  ipv4_subnet_mask_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.IPv4Settings.ipv4_subnet_mask)
}

// uint32 ipv4_default_gateway = 3;
inline void IPv4Settings::clear_ipv4_default_gateway() {
  ipv4_default_gateway_ = 0u;
}
inline ::google::protobuf::uint32 IPv4Settings::ipv4_default_gateway() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.IPv4Settings.ipv4_default_gateway)
  return ipv4_default_gateway_;
}
inline void IPv4Settings::set_ipv4_default_gateway(::google::protobuf::uint32 value) {
  
  ipv4_default_gateway_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.IPv4Settings.ipv4_default_gateway)
}

// -------------------------------------------------------------------

// PartNumberRevision

// string part_number_revision = 1;
inline void PartNumberRevision::clear_part_number_revision() {
  part_number_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartNumberRevision::part_number_revision() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.PartNumberRevision.part_number_revision)
  return part_number_revision_.GetNoArena();
}
inline void PartNumberRevision::set_part_number_revision(const ::std::string& value) {
  
  part_number_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.PartNumberRevision.part_number_revision)
}
#if LANG_CXX11
inline void PartNumberRevision::set_part_number_revision(::std::string&& value) {
  
  part_number_revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.DeviceConfig.PartNumberRevision.part_number_revision)
}
#endif
inline void PartNumberRevision::set_part_number_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  part_number_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.DeviceConfig.PartNumberRevision.part_number_revision)
}
inline void PartNumberRevision::set_part_number_revision(const char* value, size_t size) {
  
  part_number_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.DeviceConfig.PartNumberRevision.part_number_revision)
}
inline ::std::string* PartNumberRevision::mutable_part_number_revision() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.DeviceConfig.PartNumberRevision.part_number_revision)
  return part_number_revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartNumberRevision::release_part_number_revision() {
  // @@protoc_insertion_point(field_release:Kinova.Api.DeviceConfig.PartNumberRevision.part_number_revision)
  
  return part_number_revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartNumberRevision::set_allocated_part_number_revision(::std::string* part_number_revision) {
  if (part_number_revision != NULL) {
    
  } else {
    
  }
  part_number_revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), part_number_revision);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.DeviceConfig.PartNumberRevision.part_number_revision)
}

// -------------------------------------------------------------------

// PowerOnSelfTestResult

// uint32 power_on_self_test_result = 1;
inline void PowerOnSelfTestResult::clear_power_on_self_test_result() {
  power_on_self_test_result_ = 0u;
}
inline ::google::protobuf::uint32 PowerOnSelfTestResult::power_on_self_test_result() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.PowerOnSelfTestResult.power_on_self_test_result)
  return power_on_self_test_result_;
}
inline void PowerOnSelfTestResult::set_power_on_self_test_result(::google::protobuf::uint32 value) {
  
  power_on_self_test_result_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.PowerOnSelfTestResult.power_on_self_test_result)
}

// -------------------------------------------------------------------

// RebootRqst

// uint32 delay = 1;
inline void RebootRqst::clear_delay() {
  delay_ = 0u;
}
inline ::google::protobuf::uint32 RebootRqst::delay() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.RebootRqst.delay)
  return delay_;
}
inline void RebootRqst::set_delay(::google::protobuf::uint32 value) {
  
  delay_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.RebootRqst.delay)
}

// -------------------------------------------------------------------

// SafetyInformation

// .Kinova.Api.Common.SafetyHandle handle = 1;
inline bool SafetyInformation::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline const ::Kinova::Api::Common::SafetyHandle& SafetyInformation::handle() const {
  const ::Kinova::Api::Common::SafetyHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyInformation.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::SafetyHandle*>(
      &::Kinova::Api::Common::_SafetyHandle_default_instance_);
}
inline ::Kinova::Api::Common::SafetyHandle* SafetyInformation::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.DeviceConfig.SafetyInformation.handle)
  
  ::Kinova::Api::Common::SafetyHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::SafetyHandle* SafetyInformation::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Common::SafetyHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.DeviceConfig.SafetyInformation.handle)
  return handle_;
}
inline void SafetyInformation::set_allocated_handle(::Kinova::Api::Common::SafetyHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(handle_);
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.DeviceConfig.SafetyInformation.handle)
}

// bool can_change_safety_state = 2;
inline void SafetyInformation::clear_can_change_safety_state() {
  can_change_safety_state_ = false;
}
inline bool SafetyInformation::can_change_safety_state() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyInformation.can_change_safety_state)
  return can_change_safety_state_;
}
inline void SafetyInformation::set_can_change_safety_state(bool value) {
  
  can_change_safety_state_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyInformation.can_change_safety_state)
}

// bool has_warning_threshold = 3;
inline void SafetyInformation::clear_has_warning_threshold() {
  has_warning_threshold_ = false;
}
inline bool SafetyInformation::has_warning_threshold() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyInformation.has_warning_threshold)
  return has_warning_threshold_;
}
inline void SafetyInformation::set_has_warning_threshold(bool value) {
  
  has_warning_threshold_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyInformation.has_warning_threshold)
}

// bool has_error_threshold = 4;
inline void SafetyInformation::clear_has_error_threshold() {
  has_error_threshold_ = false;
}
inline bool SafetyInformation::has_error_threshold() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyInformation.has_error_threshold)
  return has_error_threshold_;
}
inline void SafetyInformation::set_has_error_threshold(bool value) {
  
  has_error_threshold_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyInformation.has_error_threshold)
}

// .Kinova.Api.DeviceConfig.SafetyLimitType limit_type = 5;
inline void SafetyInformation::clear_limit_type() {
  limit_type_ = 0;
}
inline ::Kinova::Api::DeviceConfig::SafetyLimitType SafetyInformation::limit_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyInformation.limit_type)
  return static_cast< ::Kinova::Api::DeviceConfig::SafetyLimitType >(limit_type_);
}
inline void SafetyInformation::set_limit_type(::Kinova::Api::DeviceConfig::SafetyLimitType value) {
  
  limit_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyInformation.limit_type)
}

// float default_warning_threshold = 6;
inline void SafetyInformation::clear_default_warning_threshold() {
  default_warning_threshold_ = 0;
}
inline float SafetyInformation::default_warning_threshold() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyInformation.default_warning_threshold)
  return default_warning_threshold_;
}
inline void SafetyInformation::set_default_warning_threshold(float value) {
  
  default_warning_threshold_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyInformation.default_warning_threshold)
}

// float default_error_threshold = 7;
inline void SafetyInformation::clear_default_error_threshold() {
  default_error_threshold_ = 0;
}
inline float SafetyInformation::default_error_threshold() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyInformation.default_error_threshold)
  return default_error_threshold_;
}
inline void SafetyInformation::set_default_error_threshold(float value) {
  
  default_error_threshold_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyInformation.default_error_threshold)
}

// float upper_hard_limit = 8;
inline void SafetyInformation::clear_upper_hard_limit() {
  upper_hard_limit_ = 0;
}
inline float SafetyInformation::upper_hard_limit() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyInformation.upper_hard_limit)
  return upper_hard_limit_;
}
inline void SafetyInformation::set_upper_hard_limit(float value) {
  
  upper_hard_limit_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyInformation.upper_hard_limit)
}

// float lower_hard_limit = 9;
inline void SafetyInformation::clear_lower_hard_limit() {
  lower_hard_limit_ = 0;
}
inline float SafetyInformation::lower_hard_limit() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyInformation.lower_hard_limit)
  return lower_hard_limit_;
}
inline void SafetyInformation::set_lower_hard_limit(float value) {
  
  lower_hard_limit_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyInformation.lower_hard_limit)
}

// .Kinova.Api.Common.SafetyStatusValue status = 11;
inline void SafetyInformation::clear_status() {
  status_ = 0;
}
inline ::Kinova::Api::Common::SafetyStatusValue SafetyInformation::status() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyInformation.status)
  return static_cast< ::Kinova::Api::Common::SafetyStatusValue >(status_);
}
inline void SafetyInformation::set_status(::Kinova::Api::Common::SafetyStatusValue value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyInformation.status)
}

// .Kinova.Api.Common.Unit unit = 12;
inline void SafetyInformation::clear_unit() {
  unit_ = 0;
}
inline ::Kinova::Api::Common::Unit SafetyInformation::unit() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyInformation.unit)
  return static_cast< ::Kinova::Api::Common::Unit >(unit_);
}
inline void SafetyInformation::set_unit(::Kinova::Api::Common::Unit value) {
  
  unit_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyInformation.unit)
}

// -------------------------------------------------------------------

// SafetyInformationList

// repeated .Kinova.Api.DeviceConfig.SafetyInformation information = 1;
inline int SafetyInformationList::information_size() const {
  return information_.size();
}
inline void SafetyInformationList::clear_information() {
  information_.Clear();
}
inline const ::Kinova::Api::DeviceConfig::SafetyInformation& SafetyInformationList::information(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyInformationList.information)
  return information_.Get(index);
}
inline ::Kinova::Api::DeviceConfig::SafetyInformation* SafetyInformationList::mutable_information(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.DeviceConfig.SafetyInformationList.information)
  return information_.Mutable(index);
}
inline ::Kinova::Api::DeviceConfig::SafetyInformation* SafetyInformationList::add_information() {
  // @@protoc_insertion_point(field_add:Kinova.Api.DeviceConfig.SafetyInformationList.information)
  return information_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::SafetyInformation >*
SafetyInformationList::mutable_information() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.DeviceConfig.SafetyInformationList.information)
  return &information_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::SafetyInformation >&
SafetyInformationList::information() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.DeviceConfig.SafetyInformationList.information)
  return information_;
}

// -------------------------------------------------------------------

// SafetyEnable

// .Kinova.Api.Common.SafetyHandle handle = 1;
inline bool SafetyEnable::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline const ::Kinova::Api::Common::SafetyHandle& SafetyEnable::handle() const {
  const ::Kinova::Api::Common::SafetyHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyEnable.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::SafetyHandle*>(
      &::Kinova::Api::Common::_SafetyHandle_default_instance_);
}
inline ::Kinova::Api::Common::SafetyHandle* SafetyEnable::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.DeviceConfig.SafetyEnable.handle)
  
  ::Kinova::Api::Common::SafetyHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::SafetyHandle* SafetyEnable::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Common::SafetyHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.DeviceConfig.SafetyEnable.handle)
  return handle_;
}
inline void SafetyEnable::set_allocated_handle(::Kinova::Api::Common::SafetyHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(handle_);
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.DeviceConfig.SafetyEnable.handle)
}

// bool enable = 2;
inline void SafetyEnable::clear_enable() {
  enable_ = false;
}
inline bool SafetyEnable::enable() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyEnable.enable)
  return enable_;
}
inline void SafetyEnable::set_enable(bool value) {
  
  enable_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyEnable.enable)
}

// -------------------------------------------------------------------

// SafetyThreshold

// .Kinova.Api.Common.SafetyHandle handle = 1;
inline bool SafetyThreshold::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline const ::Kinova::Api::Common::SafetyHandle& SafetyThreshold::handle() const {
  const ::Kinova::Api::Common::SafetyHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyThreshold.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::SafetyHandle*>(
      &::Kinova::Api::Common::_SafetyHandle_default_instance_);
}
inline ::Kinova::Api::Common::SafetyHandle* SafetyThreshold::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.DeviceConfig.SafetyThreshold.handle)
  
  ::Kinova::Api::Common::SafetyHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::SafetyHandle* SafetyThreshold::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Common::SafetyHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.DeviceConfig.SafetyThreshold.handle)
  return handle_;
}
inline void SafetyThreshold::set_allocated_handle(::Kinova::Api::Common::SafetyHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(handle_);
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.DeviceConfig.SafetyThreshold.handle)
}

// float value = 2;
inline void SafetyThreshold::clear_value() {
  value_ = 0;
}
inline float SafetyThreshold::value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyThreshold.value)
  return value_;
}
inline void SafetyThreshold::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyThreshold.value)
}

// -------------------------------------------------------------------

// SafetyConfiguration

// .Kinova.Api.Common.SafetyHandle handle = 1;
inline bool SafetyConfiguration::has_handle() const {
  return this != internal_default_instance() && handle_ != NULL;
}
inline const ::Kinova::Api::Common::SafetyHandle& SafetyConfiguration::handle() const {
  const ::Kinova::Api::Common::SafetyHandle* p = handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyConfiguration.handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::SafetyHandle*>(
      &::Kinova::Api::Common::_SafetyHandle_default_instance_);
}
inline ::Kinova::Api::Common::SafetyHandle* SafetyConfiguration::release_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.DeviceConfig.SafetyConfiguration.handle)
  
  ::Kinova::Api::Common::SafetyHandle* temp = handle_;
  handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::SafetyHandle* SafetyConfiguration::mutable_handle() {
  
  if (handle_ == NULL) {
    handle_ = new ::Kinova::Api::Common::SafetyHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.DeviceConfig.SafetyConfiguration.handle)
  return handle_;
}
inline void SafetyConfiguration::set_allocated_handle(::Kinova::Api::Common::SafetyHandle* handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(handle_);
  }
  if (handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.DeviceConfig.SafetyConfiguration.handle)
}

// float error_threshold = 2;
inline void SafetyConfiguration::clear_error_threshold() {
  error_threshold_ = 0;
}
inline float SafetyConfiguration::error_threshold() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyConfiguration.error_threshold)
  return error_threshold_;
}
inline void SafetyConfiguration::set_error_threshold(float value) {
  
  error_threshold_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyConfiguration.error_threshold)
}

// float warning_threshold = 3;
inline void SafetyConfiguration::clear_warning_threshold() {
  warning_threshold_ = 0;
}
inline float SafetyConfiguration::warning_threshold() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyConfiguration.warning_threshold)
  return warning_threshold_;
}
inline void SafetyConfiguration::set_warning_threshold(float value) {
  
  warning_threshold_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyConfiguration.warning_threshold)
}

// .Kinova.Api.DeviceConfig.SafetyEnable enable = 4;
inline bool SafetyConfiguration::has_enable() const {
  return this != internal_default_instance() && enable_ != NULL;
}
inline void SafetyConfiguration::clear_enable() {
  if (GetArenaNoVirtual() == NULL && enable_ != NULL) {
    delete enable_;
  }
  enable_ = NULL;
}
inline const ::Kinova::Api::DeviceConfig::SafetyEnable& SafetyConfiguration::enable() const {
  const ::Kinova::Api::DeviceConfig::SafetyEnable* p = enable_;
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyConfiguration.enable)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::DeviceConfig::SafetyEnable*>(
      &::Kinova::Api::DeviceConfig::_SafetyEnable_default_instance_);
}
inline ::Kinova::Api::DeviceConfig::SafetyEnable* SafetyConfiguration::release_enable() {
  // @@protoc_insertion_point(field_release:Kinova.Api.DeviceConfig.SafetyConfiguration.enable)
  
  ::Kinova::Api::DeviceConfig::SafetyEnable* temp = enable_;
  enable_ = NULL;
  return temp;
}
inline ::Kinova::Api::DeviceConfig::SafetyEnable* SafetyConfiguration::mutable_enable() {
  
  if (enable_ == NULL) {
    enable_ = new ::Kinova::Api::DeviceConfig::SafetyEnable;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.DeviceConfig.SafetyConfiguration.enable)
  return enable_;
}
inline void SafetyConfiguration::set_allocated_enable(::Kinova::Api::DeviceConfig::SafetyEnable* enable) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete enable_;
  }
  if (enable) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      enable = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, enable, submessage_arena);
    }
    
  } else {
    
  }
  enable_ = enable;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.DeviceConfig.SafetyConfiguration.enable)
}

// -------------------------------------------------------------------

// SafetyConfigurationList

// repeated .Kinova.Api.DeviceConfig.SafetyConfiguration configuration = 1;
inline int SafetyConfigurationList::configuration_size() const {
  return configuration_.size();
}
inline void SafetyConfigurationList::clear_configuration() {
  configuration_.Clear();
}
inline const ::Kinova::Api::DeviceConfig::SafetyConfiguration& SafetyConfigurationList::configuration(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyConfigurationList.configuration)
  return configuration_.Get(index);
}
inline ::Kinova::Api::DeviceConfig::SafetyConfiguration* SafetyConfigurationList::mutable_configuration(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.DeviceConfig.SafetyConfigurationList.configuration)
  return configuration_.Mutable(index);
}
inline ::Kinova::Api::DeviceConfig::SafetyConfiguration* SafetyConfigurationList::add_configuration() {
  // @@protoc_insertion_point(field_add:Kinova.Api.DeviceConfig.SafetyConfigurationList.configuration)
  return configuration_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::SafetyConfiguration >*
SafetyConfigurationList::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.DeviceConfig.SafetyConfigurationList.configuration)
  return &configuration_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::SafetyConfiguration >&
SafetyConfigurationList::configuration() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.DeviceConfig.SafetyConfigurationList.configuration)
  return configuration_;
}

// -------------------------------------------------------------------

// SafetyStatus

// .Kinova.Api.Common.SafetyStatusValue value = 1;
inline void SafetyStatus::clear_value() {
  value_ = 0;
}
inline ::Kinova::Api::Common::SafetyStatusValue SafetyStatus::value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.SafetyStatus.value)
  return static_cast< ::Kinova::Api::Common::SafetyStatusValue >(value_);
}
inline void SafetyStatus::set_value(::Kinova::Api::Common::SafetyStatusValue value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.SafetyStatus.value)
}

// -------------------------------------------------------------------

// CalibrationParameter

// uint32 calibration_parameter_identifier = 1;
inline void CalibrationParameter::clear_calibration_parameter_identifier() {
  calibration_parameter_identifier_ = 0u;
}
inline ::google::protobuf::uint32 CalibrationParameter::calibration_parameter_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.CalibrationParameter.calibration_parameter_identifier)
  return calibration_parameter_identifier_;
}
inline void CalibrationParameter::set_calibration_parameter_identifier(::google::protobuf::uint32 value) {
  
  calibration_parameter_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.CalibrationParameter.calibration_parameter_identifier)
}

// int32 signedIntValue = 2;
inline bool CalibrationParameter::has_signedintvalue() const {
  return value_case() == kSignedIntValue;
}
inline void CalibrationParameter::set_has_signedintvalue() {
  _oneof_case_[0] = kSignedIntValue;
}
inline void CalibrationParameter::clear_signedintvalue() {
  if (has_signedintvalue()) {
    value_.signedintvalue_ = 0;
    clear_has_value();
  }
}
inline ::google::protobuf::int32 CalibrationParameter::signedintvalue() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.CalibrationParameter.signedIntValue)
  if (has_signedintvalue()) {
    return value_.signedintvalue_;
  }
  return 0;
}
inline void CalibrationParameter::set_signedintvalue(::google::protobuf::int32 value) {
  if (!has_signedintvalue()) {
    clear_value();
    set_has_signedintvalue();
  }
  value_.signedintvalue_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.CalibrationParameter.signedIntValue)
}

// uint32 unsignedIntValue = 3;
inline bool CalibrationParameter::has_unsignedintvalue() const {
  return value_case() == kUnsignedIntValue;
}
inline void CalibrationParameter::set_has_unsignedintvalue() {
  _oneof_case_[0] = kUnsignedIntValue;
}
inline void CalibrationParameter::clear_unsignedintvalue() {
  if (has_unsignedintvalue()) {
    value_.unsignedintvalue_ = 0u;
    clear_has_value();
  }
}
inline ::google::protobuf::uint32 CalibrationParameter::unsignedintvalue() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.CalibrationParameter.unsignedIntValue)
  if (has_unsignedintvalue()) {
    return value_.unsignedintvalue_;
  }
  return 0u;
}
inline void CalibrationParameter::set_unsignedintvalue(::google::protobuf::uint32 value) {
  if (!has_unsignedintvalue()) {
    clear_value();
    set_has_unsignedintvalue();
  }
  value_.unsignedintvalue_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.CalibrationParameter.unsignedIntValue)
}

// float floatValue = 4;
inline bool CalibrationParameter::has_floatvalue() const {
  return value_case() == kFloatValue;
}
inline void CalibrationParameter::set_has_floatvalue() {
  _oneof_case_[0] = kFloatValue;
}
inline void CalibrationParameter::clear_floatvalue() {
  if (has_floatvalue()) {
    value_.floatvalue_ = 0;
    clear_has_value();
  }
}
inline float CalibrationParameter::floatvalue() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.CalibrationParameter.floatValue)
  if (has_floatvalue()) {
    return value_.floatvalue_;
  }
  return 0;
}
inline void CalibrationParameter::set_floatvalue(float value) {
  if (!has_floatvalue()) {
    clear_value();
    set_has_floatvalue();
  }
  value_.floatvalue_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.CalibrationParameter.floatValue)
}

inline bool CalibrationParameter::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void CalibrationParameter::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline CalibrationParameter::ValueCase CalibrationParameter::value_case() const {
  return CalibrationParameter::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Calibration

// .Kinova.Api.DeviceConfig.CalibrationItem calibration_item = 1;
inline void Calibration::clear_calibration_item() {
  calibration_item_ = 0;
}
inline ::Kinova::Api::DeviceConfig::CalibrationItem Calibration::calibration_item() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.Calibration.calibration_item)
  return static_cast< ::Kinova::Api::DeviceConfig::CalibrationItem >(calibration_item_);
}
inline void Calibration::set_calibration_item(::Kinova::Api::DeviceConfig::CalibrationItem value) {
  
  calibration_item_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.Calibration.calibration_item)
}

// repeated .Kinova.Api.DeviceConfig.CalibrationParameter calibration_parameter = 2;
inline int Calibration::calibration_parameter_size() const {
  return calibration_parameter_.size();
}
inline void Calibration::clear_calibration_parameter() {
  calibration_parameter_.Clear();
}
inline const ::Kinova::Api::DeviceConfig::CalibrationParameter& Calibration::calibration_parameter(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.Calibration.calibration_parameter)
  return calibration_parameter_.Get(index);
}
inline ::Kinova::Api::DeviceConfig::CalibrationParameter* Calibration::mutable_calibration_parameter(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.DeviceConfig.Calibration.calibration_parameter)
  return calibration_parameter_.Mutable(index);
}
inline ::Kinova::Api::DeviceConfig::CalibrationParameter* Calibration::add_calibration_parameter() {
  // @@protoc_insertion_point(field_add:Kinova.Api.DeviceConfig.Calibration.calibration_parameter)
  return calibration_parameter_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::CalibrationParameter >*
Calibration::mutable_calibration_parameter() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.DeviceConfig.Calibration.calibration_parameter)
  return &calibration_parameter_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::DeviceConfig::CalibrationParameter >&
Calibration::calibration_parameter() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.DeviceConfig.Calibration.calibration_parameter)
  return calibration_parameter_;
}

// -------------------------------------------------------------------

// CalibrationElement

// .Kinova.Api.DeviceConfig.CalibrationItem calibration_item = 1;
inline void CalibrationElement::clear_calibration_item() {
  calibration_item_ = 0;
}
inline ::Kinova::Api::DeviceConfig::CalibrationItem CalibrationElement::calibration_item() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.CalibrationElement.calibration_item)
  return static_cast< ::Kinova::Api::DeviceConfig::CalibrationItem >(calibration_item_);
}
inline void CalibrationElement::set_calibration_item(::Kinova::Api::DeviceConfig::CalibrationItem value) {
  
  calibration_item_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.CalibrationElement.calibration_item)
}

// -------------------------------------------------------------------

// CalibrationResult

// .Kinova.Api.DeviceConfig.CalibrationStatus calibration_status = 1;
inline void CalibrationResult::clear_calibration_status() {
  calibration_status_ = 0;
}
inline ::Kinova::Api::DeviceConfig::CalibrationStatus CalibrationResult::calibration_status() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.CalibrationResult.calibration_status)
  return static_cast< ::Kinova::Api::DeviceConfig::CalibrationStatus >(calibration_status_);
}
inline void CalibrationResult::set_calibration_status(::Kinova::Api::DeviceConfig::CalibrationStatus value) {
  
  calibration_status_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.CalibrationResult.calibration_status)
}

// uint32 calibration_details = 2;
inline void CalibrationResult::clear_calibration_details() {
  calibration_details_ = 0u;
}
inline ::google::protobuf::uint32 CalibrationResult::calibration_details() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.CalibrationResult.calibration_details)
  return calibration_details_;
}
inline void CalibrationResult::set_calibration_details(::google::protobuf::uint32 value) {
  
  calibration_details_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.CalibrationResult.calibration_details)
}

// -------------------------------------------------------------------

// CapSenseConfig

// .Kinova.Api.DeviceConfig.CapSenseMode mode = 1;
inline void CapSenseConfig::clear_mode() {
  mode_ = 0;
}
inline ::Kinova::Api::DeviceConfig::CapSenseMode CapSenseConfig::mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.CapSenseConfig.mode)
  return static_cast< ::Kinova::Api::DeviceConfig::CapSenseMode >(mode_);
}
inline void CapSenseConfig::set_mode(::Kinova::Api::DeviceConfig::CapSenseMode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.CapSenseConfig.mode)
}

// float threshold_a = 2;
inline void CapSenseConfig::clear_threshold_a() {
  threshold_a_ = 0;
}
inline float CapSenseConfig::threshold_a() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.CapSenseConfig.threshold_a)
  return threshold_a_;
}
inline void CapSenseConfig::set_threshold_a(float value) {
  
  threshold_a_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.CapSenseConfig.threshold_a)
}

// float threshold_b = 3;
inline void CapSenseConfig::clear_threshold_b() {
  threshold_b_ = 0;
}
inline float CapSenseConfig::threshold_b() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.CapSenseConfig.threshold_b)
  return threshold_b_;
}
inline void CapSenseConfig::set_threshold_b(float value) {
  
  threshold_b_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.CapSenseConfig.threshold_b)
}

// -------------------------------------------------------------------

// CapSenseRegister

// uint32 address = 1;
inline void CapSenseRegister::clear_address() {
  address_ = 0u;
}
inline ::google::protobuf::uint32 CapSenseRegister::address() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.CapSenseRegister.address)
  return address_;
}
inline void CapSenseRegister::set_address(::google::protobuf::uint32 value) {
  
  address_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.CapSenseRegister.address)
}

// uint32 value = 2;
inline void CapSenseRegister::clear_value() {
  value_ = 0u;
}
inline ::google::protobuf::uint32 CapSenseRegister::value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.DeviceConfig.CapSenseRegister.value)
  return value_;
}
inline void CapSenseRegister::set_value(::google::protobuf::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.DeviceConfig.CapSenseRegister.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace DeviceConfig
}  // namespace Api
}  // namespace Kinova

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Kinova::Api::DeviceConfig::ServiceVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::DeviceConfig::ServiceVersion>() {
  return ::Kinova::Api::DeviceConfig::ServiceVersion_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::DeviceConfig::RunModes> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::DeviceConfig::RunModes>() {
  return ::Kinova::Api::DeviceConfig::RunModes_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::DeviceConfig::CalibrationItem> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::DeviceConfig::CalibrationItem>() {
  return ::Kinova::Api::DeviceConfig::CalibrationItem_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::DeviceConfig::CalibrationStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::DeviceConfig::CalibrationStatus>() {
  return ::Kinova::Api::DeviceConfig::CalibrationStatus_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::DeviceConfig::SafetyLimitType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::DeviceConfig::SafetyLimitType>() {
  return ::Kinova::Api::DeviceConfig::SafetyLimitType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::DeviceConfig::CapSenseMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::DeviceConfig::CapSenseMode>() {
  return ::Kinova::Api::DeviceConfig::CapSenseMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_DeviceConfig_2eproto__INCLUDED
