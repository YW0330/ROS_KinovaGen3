// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ControlConfig.proto

#ifndef PROTOBUF_ControlConfig_2eproto__INCLUDED
#define PROTOBUF_ControlConfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Common.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace protobuf_ControlConfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[19];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsGravityVectorImpl();
void InitDefaultsGravityVector();
void InitDefaultsPositionImpl();
void InitDefaultsPosition();
void InitDefaultsPayloadInformationImpl();
void InitDefaultsPayloadInformation();
void InitDefaultsCartesianTransformImpl();
void InitDefaultsCartesianTransform();
void InitDefaultsToolConfigurationImpl();
void InitDefaultsToolConfiguration();
void InitDefaultsControlConfigurationNotificationImpl();
void InitDefaultsControlConfigurationNotification();
void InitDefaultsCartesianReferenceFrameInfoImpl();
void InitDefaultsCartesianReferenceFrameInfo();
void InitDefaultsTwistLinearSoftLimitImpl();
void InitDefaultsTwistLinearSoftLimit();
void InitDefaultsTwistAngularSoftLimitImpl();
void InitDefaultsTwistAngularSoftLimit();
void InitDefaultsJointSpeedSoftLimitsImpl();
void InitDefaultsJointSpeedSoftLimits();
void InitDefaultsJointAccelerationSoftLimitsImpl();
void InitDefaultsJointAccelerationSoftLimits();
void InitDefaultsKinematicLimitsImpl();
void InitDefaultsKinematicLimits();
void InitDefaultsKinematicLimitsListImpl();
void InitDefaultsKinematicLimitsList();
void InitDefaultsDesiredSpeedsImpl();
void InitDefaultsDesiredSpeeds();
void InitDefaultsLinearTwistImpl();
void InitDefaultsLinearTwist();
void InitDefaultsAngularTwistImpl();
void InitDefaultsAngularTwist();
void InitDefaultsJointSpeedsImpl();
void InitDefaultsJointSpeeds();
void InitDefaultsControlModeInformationImpl();
void InitDefaultsControlModeInformation();
void InitDefaultsControlModeNotificationImpl();
void InitDefaultsControlModeNotification();
inline void InitDefaults() {
  InitDefaultsGravityVector();
  InitDefaultsPosition();
  InitDefaultsPayloadInformation();
  InitDefaultsCartesianTransform();
  InitDefaultsToolConfiguration();
  InitDefaultsControlConfigurationNotification();
  InitDefaultsCartesianReferenceFrameInfo();
  InitDefaultsTwistLinearSoftLimit();
  InitDefaultsTwistAngularSoftLimit();
  InitDefaultsJointSpeedSoftLimits();
  InitDefaultsJointAccelerationSoftLimits();
  InitDefaultsKinematicLimits();
  InitDefaultsKinematicLimitsList();
  InitDefaultsDesiredSpeeds();
  InitDefaultsLinearTwist();
  InitDefaultsAngularTwist();
  InitDefaultsJointSpeeds();
  InitDefaultsControlModeInformation();
  InitDefaultsControlModeNotification();
}
}  // namespace protobuf_ControlConfig_2eproto
namespace Kinova {
namespace Api {
namespace ControlConfig {
class AngularTwist;
class AngularTwistDefaultTypeInternal;
extern AngularTwistDefaultTypeInternal _AngularTwist_default_instance_;
class CartesianReferenceFrameInfo;
class CartesianReferenceFrameInfoDefaultTypeInternal;
extern CartesianReferenceFrameInfoDefaultTypeInternal _CartesianReferenceFrameInfo_default_instance_;
class CartesianTransform;
class CartesianTransformDefaultTypeInternal;
extern CartesianTransformDefaultTypeInternal _CartesianTransform_default_instance_;
class ControlConfigurationNotification;
class ControlConfigurationNotificationDefaultTypeInternal;
extern ControlConfigurationNotificationDefaultTypeInternal _ControlConfigurationNotification_default_instance_;
class ControlModeInformation;
class ControlModeInformationDefaultTypeInternal;
extern ControlModeInformationDefaultTypeInternal _ControlModeInformation_default_instance_;
class ControlModeNotification;
class ControlModeNotificationDefaultTypeInternal;
extern ControlModeNotificationDefaultTypeInternal _ControlModeNotification_default_instance_;
class DesiredSpeeds;
class DesiredSpeedsDefaultTypeInternal;
extern DesiredSpeedsDefaultTypeInternal _DesiredSpeeds_default_instance_;
class GravityVector;
class GravityVectorDefaultTypeInternal;
extern GravityVectorDefaultTypeInternal _GravityVector_default_instance_;
class JointAccelerationSoftLimits;
class JointAccelerationSoftLimitsDefaultTypeInternal;
extern JointAccelerationSoftLimitsDefaultTypeInternal _JointAccelerationSoftLimits_default_instance_;
class JointSpeedSoftLimits;
class JointSpeedSoftLimitsDefaultTypeInternal;
extern JointSpeedSoftLimitsDefaultTypeInternal _JointSpeedSoftLimits_default_instance_;
class JointSpeeds;
class JointSpeedsDefaultTypeInternal;
extern JointSpeedsDefaultTypeInternal _JointSpeeds_default_instance_;
class KinematicLimits;
class KinematicLimitsDefaultTypeInternal;
extern KinematicLimitsDefaultTypeInternal _KinematicLimits_default_instance_;
class KinematicLimitsList;
class KinematicLimitsListDefaultTypeInternal;
extern KinematicLimitsListDefaultTypeInternal _KinematicLimitsList_default_instance_;
class LinearTwist;
class LinearTwistDefaultTypeInternal;
extern LinearTwistDefaultTypeInternal _LinearTwist_default_instance_;
class PayloadInformation;
class PayloadInformationDefaultTypeInternal;
extern PayloadInformationDefaultTypeInternal _PayloadInformation_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class ToolConfiguration;
class ToolConfigurationDefaultTypeInternal;
extern ToolConfigurationDefaultTypeInternal _ToolConfiguration_default_instance_;
class TwistAngularSoftLimit;
class TwistAngularSoftLimitDefaultTypeInternal;
extern TwistAngularSoftLimitDefaultTypeInternal _TwistAngularSoftLimit_default_instance_;
class TwistLinearSoftLimit;
class TwistLinearSoftLimitDefaultTypeInternal;
extern TwistLinearSoftLimitDefaultTypeInternal _TwistLinearSoftLimit_default_instance_;
}  // namespace ControlConfig
}  // namespace Api
}  // namespace Kinova
namespace Kinova {
namespace Api {
namespace ControlConfig {

enum ServiceVersion {
  RESERVED_0 = 0,
  CURRENT_VERSION = 1,
  ServiceVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ServiceVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ServiceVersion_IsValid(int value);
const ServiceVersion ServiceVersion_MIN = RESERVED_0;
const ServiceVersion ServiceVersion_MAX = CURRENT_VERSION;
const int ServiceVersion_ARRAYSIZE = ServiceVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceVersion_descriptor();
inline const ::std::string& ServiceVersion_Name(ServiceVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceVersion_descriptor(), value);
}
inline bool ServiceVersion_Parse(
    const ::std::string& name, ServiceVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceVersion>(
    ServiceVersion_descriptor(), name, value);
}
enum ControlConfigurationEvent {
  UNSPECIFIED_CONTROL_CONFIGURATION_EVENT = 0,
  ANGLE_UNIT_CHANGED = 1,
  GRAVITY_VECTOR_CHANGED = 2,
  JOINT_ADMITTANCE_CONFIGURATION_CHANGED = 4,
  NULL_ADMITTANCE_CONFIGURATION_CHANGED = 5,
  CARTESIAN_ADMITTANCE_CONFIGURATION_CHANGED = 6,
  JOINT_TORQUE_HYBRID_CONFIGURATION_CHANGED = 7,
  WRENCH_COMMAND_NORMAL_CONFIGURATION_CHANGED = 8,
  WRENCH_COMMAND_RESTRICTED_CONFIGURATION_CHANGED = 9,
  CONTROL_CONFIGURATION_FACTORY_RESTORED = 10,
  TOOL_CONFIGURATION_CHANGED = 11,
  PAYLOAD_CONFIGURATION_CHANGED = 12,
  CARTESIAN_REFERENCE_CHANGED = 13,
  CHANGE_CONTROL_MODE_FAILED = 14,
  JOINT_SPEED_SOFT_LIMITS_CHANGED = 16,
  TWIST_LINEAR_SOFT_LIMIT_CHANGED = 17,
  TWIST_ANGULAR_SOFT_LIMIT_CHANGED = 18,
  JOINT_ACCELERATION_SOFT_LIMITS_CHANGED = 19,
  DESIRED_TWIST_LINEAR_SPEED_CHANGED = 20,
  DESIRED_TWIST_ANGULAR_SPEED_CHANGED = 21,
  DESIRED_JOINT_SPEED_CHANGED = 22,
  ControlConfigurationEvent_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ControlConfigurationEvent_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ControlConfigurationEvent_IsValid(int value);
const ControlConfigurationEvent ControlConfigurationEvent_MIN = UNSPECIFIED_CONTROL_CONFIGURATION_EVENT;
const ControlConfigurationEvent ControlConfigurationEvent_MAX = DESIRED_JOINT_SPEED_CHANGED;
const int ControlConfigurationEvent_ARRAYSIZE = ControlConfigurationEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControlConfigurationEvent_descriptor();
inline const ::std::string& ControlConfigurationEvent_Name(ControlConfigurationEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControlConfigurationEvent_descriptor(), value);
}
inline bool ControlConfigurationEvent_Parse(
    const ::std::string& name, ControlConfigurationEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlConfigurationEvent>(
    ControlConfigurationEvent_descriptor(), name, value);
}
enum ControlMode {
  UNSPECIFIED_CONTROL_MODE = 0,
  ANGULAR_JOYSTICK = 1,
  CARTESIAN_JOYSTICK = 2,
  ANGULAR_TRAJECTORY = 4,
  CARTESIAN_TRAJECTORY = 5,
  CARTESIAN_ADMITTANCE = 6,
  JOINT_ADMITTANCE = 7,
  NULL_SPACE_ADMITTANCE = 8,
  FORCE_CONTROL = 10,
  FORCE_CONTROL_MOTION_RESTRICTED = 11,
  CARTESIAN_WAYPOINT_TRAJECTORY = 12,
  IDLE = 13,
  ControlMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ControlMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ControlMode_IsValid(int value);
const ControlMode ControlMode_MIN = UNSPECIFIED_CONTROL_MODE;
const ControlMode ControlMode_MAX = IDLE;
const int ControlMode_ARRAYSIZE = ControlMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControlMode_descriptor();
inline const ::std::string& ControlMode_Name(ControlMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControlMode_descriptor(), value);
}
inline bool ControlMode_Parse(
    const ::std::string& name, ControlMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlMode>(
    ControlMode_descriptor(), name, value);
}
// ===================================================================

class GravityVector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.GravityVector) */ {
 public:
  GravityVector();
  virtual ~GravityVector();

  GravityVector(const GravityVector& from);

  inline GravityVector& operator=(const GravityVector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GravityVector(GravityVector&& from) noexcept
    : GravityVector() {
    *this = ::std::move(from);
  }

  inline GravityVector& operator=(GravityVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GravityVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GravityVector* internal_default_instance() {
    return reinterpret_cast<const GravityVector*>(
               &_GravityVector_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(GravityVector* other);
  friend void swap(GravityVector& a, GravityVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GravityVector* New() const PROTOBUF_FINAL { return New(NULL); }

  GravityVector* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GravityVector& from);
  void MergeFrom(const GravityVector& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GravityVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.GravityVector)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsGravityVectorImpl();
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Position* other);
  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const PROTOBUF_FINAL { return New(NULL); }

  Position* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.Position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsPositionImpl();
};
// -------------------------------------------------------------------

class PayloadInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.PayloadInformation) */ {
 public:
  PayloadInformation();
  virtual ~PayloadInformation();

  PayloadInformation(const PayloadInformation& from);

  inline PayloadInformation& operator=(const PayloadInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PayloadInformation(PayloadInformation&& from) noexcept
    : PayloadInformation() {
    *this = ::std::move(from);
  }

  inline PayloadInformation& operator=(PayloadInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PayloadInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PayloadInformation* internal_default_instance() {
    return reinterpret_cast<const PayloadInformation*>(
               &_PayloadInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(PayloadInformation* other);
  friend void swap(PayloadInformation& a, PayloadInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PayloadInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  PayloadInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PayloadInformation& from);
  void MergeFrom(const PayloadInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PayloadInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.ControlConfig.Position payload_mass_center = 2;
  bool has_payload_mass_center() const;
  void clear_payload_mass_center();
  static const int kPayloadMassCenterFieldNumber = 2;
  const ::Kinova::Api::ControlConfig::Position& payload_mass_center() const;
  ::Kinova::Api::ControlConfig::Position* release_payload_mass_center();
  ::Kinova::Api::ControlConfig::Position* mutable_payload_mass_center();
  void set_allocated_payload_mass_center(::Kinova::Api::ControlConfig::Position* payload_mass_center);

  // float payload_mass = 1;
  void clear_payload_mass();
  static const int kPayloadMassFieldNumber = 1;
  float payload_mass() const;
  void set_payload_mass(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.PayloadInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::ControlConfig::Position* payload_mass_center_;
  float payload_mass_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsPayloadInformationImpl();
};
// -------------------------------------------------------------------

class CartesianTransform : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.CartesianTransform) */ {
 public:
  CartesianTransform();
  virtual ~CartesianTransform();

  CartesianTransform(const CartesianTransform& from);

  inline CartesianTransform& operator=(const CartesianTransform& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianTransform(CartesianTransform&& from) noexcept
    : CartesianTransform() {
    *this = ::std::move(from);
  }

  inline CartesianTransform& operator=(CartesianTransform&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianTransform& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianTransform* internal_default_instance() {
    return reinterpret_cast<const CartesianTransform*>(
               &_CartesianTransform_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CartesianTransform* other);
  friend void swap(CartesianTransform& a, CartesianTransform& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianTransform* New() const PROTOBUF_FINAL { return New(NULL); }

  CartesianTransform* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CartesianTransform& from);
  void MergeFrom(const CartesianTransform& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CartesianTransform* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // float theta_x = 4;
  void clear_theta_x();
  static const int kThetaXFieldNumber = 4;
  float theta_x() const;
  void set_theta_x(float value);

  // float theta_y = 5;
  void clear_theta_y();
  static const int kThetaYFieldNumber = 5;
  float theta_y() const;
  void set_theta_y(float value);

  // float theta_z = 6;
  void clear_theta_z();
  static const int kThetaZFieldNumber = 6;
  float theta_z() const;
  void set_theta_z(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.CartesianTransform)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  float theta_x_;
  float theta_y_;
  float theta_z_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsCartesianTransformImpl();
};
// -------------------------------------------------------------------

class ToolConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.ToolConfiguration) */ {
 public:
  ToolConfiguration();
  virtual ~ToolConfiguration();

  ToolConfiguration(const ToolConfiguration& from);

  inline ToolConfiguration& operator=(const ToolConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ToolConfiguration(ToolConfiguration&& from) noexcept
    : ToolConfiguration() {
    *this = ::std::move(from);
  }

  inline ToolConfiguration& operator=(ToolConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ToolConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ToolConfiguration* internal_default_instance() {
    return reinterpret_cast<const ToolConfiguration*>(
               &_ToolConfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ToolConfiguration* other);
  friend void swap(ToolConfiguration& a, ToolConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ToolConfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  ToolConfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ToolConfiguration& from);
  void MergeFrom(const ToolConfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ToolConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.ControlConfig.CartesianTransform tool_transform = 1;
  bool has_tool_transform() const;
  void clear_tool_transform();
  static const int kToolTransformFieldNumber = 1;
  const ::Kinova::Api::ControlConfig::CartesianTransform& tool_transform() const;
  ::Kinova::Api::ControlConfig::CartesianTransform* release_tool_transform();
  ::Kinova::Api::ControlConfig::CartesianTransform* mutable_tool_transform();
  void set_allocated_tool_transform(::Kinova::Api::ControlConfig::CartesianTransform* tool_transform);

  // .Kinova.Api.ControlConfig.Position tool_mass_center = 3;
  bool has_tool_mass_center() const;
  void clear_tool_mass_center();
  static const int kToolMassCenterFieldNumber = 3;
  const ::Kinova::Api::ControlConfig::Position& tool_mass_center() const;
  ::Kinova::Api::ControlConfig::Position* release_tool_mass_center();
  ::Kinova::Api::ControlConfig::Position* mutable_tool_mass_center();
  void set_allocated_tool_mass_center(::Kinova::Api::ControlConfig::Position* tool_mass_center);

  // float tool_mass = 2;
  void clear_tool_mass();
  static const int kToolMassFieldNumber = 2;
  float tool_mass() const;
  void set_tool_mass(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.ToolConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::ControlConfig::CartesianTransform* tool_transform_;
  ::Kinova::Api::ControlConfig::Position* tool_mass_center_;
  float tool_mass_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsToolConfigurationImpl();
};
// -------------------------------------------------------------------

class ControlConfigurationNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.ControlConfigurationNotification) */ {
 public:
  ControlConfigurationNotification();
  virtual ~ControlConfigurationNotification();

  ControlConfigurationNotification(const ControlConfigurationNotification& from);

  inline ControlConfigurationNotification& operator=(const ControlConfigurationNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlConfigurationNotification(ControlConfigurationNotification&& from) noexcept
    : ControlConfigurationNotification() {
    *this = ::std::move(from);
  }

  inline ControlConfigurationNotification& operator=(ControlConfigurationNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlConfigurationNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlConfigurationNotification* internal_default_instance() {
    return reinterpret_cast<const ControlConfigurationNotification*>(
               &_ControlConfigurationNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ControlConfigurationNotification* other);
  friend void swap(ControlConfigurationNotification& a, ControlConfigurationNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlConfigurationNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  ControlConfigurationNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControlConfigurationNotification& from);
  void MergeFrom(const ControlConfigurationNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControlConfigurationNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.Timestamp timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 3;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 3;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 4;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 4;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.ControlConfig.ControlConfigurationEvent event = 1;
  void clear_event();
  static const int kEventFieldNumber = 1;
  ::Kinova::Api::ControlConfig::ControlConfigurationEvent event() const;
  void set_event(::Kinova::Api::ControlConfig::ControlConfigurationEvent value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.ControlConfigurationNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  int event_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsControlConfigurationNotificationImpl();
};
// -------------------------------------------------------------------

class CartesianReferenceFrameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.CartesianReferenceFrameInfo) */ {
 public:
  CartesianReferenceFrameInfo();
  virtual ~CartesianReferenceFrameInfo();

  CartesianReferenceFrameInfo(const CartesianReferenceFrameInfo& from);

  inline CartesianReferenceFrameInfo& operator=(const CartesianReferenceFrameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianReferenceFrameInfo(CartesianReferenceFrameInfo&& from) noexcept
    : CartesianReferenceFrameInfo() {
    *this = ::std::move(from);
  }

  inline CartesianReferenceFrameInfo& operator=(CartesianReferenceFrameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianReferenceFrameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianReferenceFrameInfo* internal_default_instance() {
    return reinterpret_cast<const CartesianReferenceFrameInfo*>(
               &_CartesianReferenceFrameInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(CartesianReferenceFrameInfo* other);
  friend void swap(CartesianReferenceFrameInfo& a, CartesianReferenceFrameInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianReferenceFrameInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CartesianReferenceFrameInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CartesianReferenceFrameInfo& from);
  void MergeFrom(const CartesianReferenceFrameInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CartesianReferenceFrameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.CartesianReferenceFrame reference_frame = 1;
  void clear_reference_frame();
  static const int kReferenceFrameFieldNumber = 1;
  ::Kinova::Api::Common::CartesianReferenceFrame reference_frame() const;
  void set_reference_frame(::Kinova::Api::Common::CartesianReferenceFrame value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.CartesianReferenceFrameInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int reference_frame_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsCartesianReferenceFrameInfoImpl();
};
// -------------------------------------------------------------------

class TwistLinearSoftLimit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.TwistLinearSoftLimit) */ {
 public:
  TwistLinearSoftLimit();
  virtual ~TwistLinearSoftLimit();

  TwistLinearSoftLimit(const TwistLinearSoftLimit& from);

  inline TwistLinearSoftLimit& operator=(const TwistLinearSoftLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TwistLinearSoftLimit(TwistLinearSoftLimit&& from) noexcept
    : TwistLinearSoftLimit() {
    *this = ::std::move(from);
  }

  inline TwistLinearSoftLimit& operator=(TwistLinearSoftLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TwistLinearSoftLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TwistLinearSoftLimit* internal_default_instance() {
    return reinterpret_cast<const TwistLinearSoftLimit*>(
               &_TwistLinearSoftLimit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(TwistLinearSoftLimit* other);
  friend void swap(TwistLinearSoftLimit& a, TwistLinearSoftLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TwistLinearSoftLimit* New() const PROTOBUF_FINAL { return New(NULL); }

  TwistLinearSoftLimit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TwistLinearSoftLimit& from);
  void MergeFrom(const TwistLinearSoftLimit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TwistLinearSoftLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.ControlConfig.ControlMode control_mode = 1;
  void clear_control_mode();
  static const int kControlModeFieldNumber = 1;
  ::Kinova::Api::ControlConfig::ControlMode control_mode() const;
  void set_control_mode(::Kinova::Api::ControlConfig::ControlMode value);

  // float twist_linear_soft_limit = 2;
  void clear_twist_linear_soft_limit();
  static const int kTwistLinearSoftLimitFieldNumber = 2;
  float twist_linear_soft_limit() const;
  void set_twist_linear_soft_limit(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.TwistLinearSoftLimit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int control_mode_;
  float twist_linear_soft_limit_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsTwistLinearSoftLimitImpl();
};
// -------------------------------------------------------------------

class TwistAngularSoftLimit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.TwistAngularSoftLimit) */ {
 public:
  TwistAngularSoftLimit();
  virtual ~TwistAngularSoftLimit();

  TwistAngularSoftLimit(const TwistAngularSoftLimit& from);

  inline TwistAngularSoftLimit& operator=(const TwistAngularSoftLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TwistAngularSoftLimit(TwistAngularSoftLimit&& from) noexcept
    : TwistAngularSoftLimit() {
    *this = ::std::move(from);
  }

  inline TwistAngularSoftLimit& operator=(TwistAngularSoftLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TwistAngularSoftLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TwistAngularSoftLimit* internal_default_instance() {
    return reinterpret_cast<const TwistAngularSoftLimit*>(
               &_TwistAngularSoftLimit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(TwistAngularSoftLimit* other);
  friend void swap(TwistAngularSoftLimit& a, TwistAngularSoftLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TwistAngularSoftLimit* New() const PROTOBUF_FINAL { return New(NULL); }

  TwistAngularSoftLimit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TwistAngularSoftLimit& from);
  void MergeFrom(const TwistAngularSoftLimit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TwistAngularSoftLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.ControlConfig.ControlMode control_mode = 1;
  void clear_control_mode();
  static const int kControlModeFieldNumber = 1;
  ::Kinova::Api::ControlConfig::ControlMode control_mode() const;
  void set_control_mode(::Kinova::Api::ControlConfig::ControlMode value);

  // float twist_angular_soft_limit = 2;
  void clear_twist_angular_soft_limit();
  static const int kTwistAngularSoftLimitFieldNumber = 2;
  float twist_angular_soft_limit() const;
  void set_twist_angular_soft_limit(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.TwistAngularSoftLimit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int control_mode_;
  float twist_angular_soft_limit_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsTwistAngularSoftLimitImpl();
};
// -------------------------------------------------------------------

class JointSpeedSoftLimits : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.JointSpeedSoftLimits) */ {
 public:
  JointSpeedSoftLimits();
  virtual ~JointSpeedSoftLimits();

  JointSpeedSoftLimits(const JointSpeedSoftLimits& from);

  inline JointSpeedSoftLimits& operator=(const JointSpeedSoftLimits& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointSpeedSoftLimits(JointSpeedSoftLimits&& from) noexcept
    : JointSpeedSoftLimits() {
    *this = ::std::move(from);
  }

  inline JointSpeedSoftLimits& operator=(JointSpeedSoftLimits&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JointSpeedSoftLimits& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointSpeedSoftLimits* internal_default_instance() {
    return reinterpret_cast<const JointSpeedSoftLimits*>(
               &_JointSpeedSoftLimits_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(JointSpeedSoftLimits* other);
  friend void swap(JointSpeedSoftLimits& a, JointSpeedSoftLimits& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointSpeedSoftLimits* New() const PROTOBUF_FINAL { return New(NULL); }

  JointSpeedSoftLimits* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JointSpeedSoftLimits& from);
  void MergeFrom(const JointSpeedSoftLimits& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JointSpeedSoftLimits* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float joint_speed_soft_limits = 2;
  int joint_speed_soft_limits_size() const;
  void clear_joint_speed_soft_limits();
  static const int kJointSpeedSoftLimitsFieldNumber = 2;
  float joint_speed_soft_limits(int index) const;
  void set_joint_speed_soft_limits(int index, float value);
  void add_joint_speed_soft_limits(float value);
  const ::google::protobuf::RepeatedField< float >&
      joint_speed_soft_limits() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_joint_speed_soft_limits();

  // .Kinova.Api.ControlConfig.ControlMode control_mode = 1;
  void clear_control_mode();
  static const int kControlModeFieldNumber = 1;
  ::Kinova::Api::ControlConfig::ControlMode control_mode() const;
  void set_control_mode(::Kinova::Api::ControlConfig::ControlMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.JointSpeedSoftLimits)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > joint_speed_soft_limits_;
  mutable int _joint_speed_soft_limits_cached_byte_size_;
  int control_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsJointSpeedSoftLimitsImpl();
};
// -------------------------------------------------------------------

class JointAccelerationSoftLimits : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.JointAccelerationSoftLimits) */ {
 public:
  JointAccelerationSoftLimits();
  virtual ~JointAccelerationSoftLimits();

  JointAccelerationSoftLimits(const JointAccelerationSoftLimits& from);

  inline JointAccelerationSoftLimits& operator=(const JointAccelerationSoftLimits& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointAccelerationSoftLimits(JointAccelerationSoftLimits&& from) noexcept
    : JointAccelerationSoftLimits() {
    *this = ::std::move(from);
  }

  inline JointAccelerationSoftLimits& operator=(JointAccelerationSoftLimits&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JointAccelerationSoftLimits& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointAccelerationSoftLimits* internal_default_instance() {
    return reinterpret_cast<const JointAccelerationSoftLimits*>(
               &_JointAccelerationSoftLimits_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(JointAccelerationSoftLimits* other);
  friend void swap(JointAccelerationSoftLimits& a, JointAccelerationSoftLimits& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointAccelerationSoftLimits* New() const PROTOBUF_FINAL { return New(NULL); }

  JointAccelerationSoftLimits* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JointAccelerationSoftLimits& from);
  void MergeFrom(const JointAccelerationSoftLimits& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JointAccelerationSoftLimits* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float joint_acceleration_soft_limits = 2;
  int joint_acceleration_soft_limits_size() const;
  void clear_joint_acceleration_soft_limits();
  static const int kJointAccelerationSoftLimitsFieldNumber = 2;
  float joint_acceleration_soft_limits(int index) const;
  void set_joint_acceleration_soft_limits(int index, float value);
  void add_joint_acceleration_soft_limits(float value);
  const ::google::protobuf::RepeatedField< float >&
      joint_acceleration_soft_limits() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_joint_acceleration_soft_limits();

  // .Kinova.Api.ControlConfig.ControlMode control_mode = 1;
  void clear_control_mode();
  static const int kControlModeFieldNumber = 1;
  ::Kinova::Api::ControlConfig::ControlMode control_mode() const;
  void set_control_mode(::Kinova::Api::ControlConfig::ControlMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.JointAccelerationSoftLimits)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > joint_acceleration_soft_limits_;
  mutable int _joint_acceleration_soft_limits_cached_byte_size_;
  int control_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsJointAccelerationSoftLimitsImpl();
};
// -------------------------------------------------------------------

class KinematicLimits : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.KinematicLimits) */ {
 public:
  KinematicLimits();
  virtual ~KinematicLimits();

  KinematicLimits(const KinematicLimits& from);

  inline KinematicLimits& operator=(const KinematicLimits& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KinematicLimits(KinematicLimits&& from) noexcept
    : KinematicLimits() {
    *this = ::std::move(from);
  }

  inline KinematicLimits& operator=(KinematicLimits&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KinematicLimits& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KinematicLimits* internal_default_instance() {
    return reinterpret_cast<const KinematicLimits*>(
               &_KinematicLimits_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(KinematicLimits* other);
  friend void swap(KinematicLimits& a, KinematicLimits& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KinematicLimits* New() const PROTOBUF_FINAL { return New(NULL); }

  KinematicLimits* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KinematicLimits& from);
  void MergeFrom(const KinematicLimits& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KinematicLimits* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float joint_speed_limits = 4;
  int joint_speed_limits_size() const;
  void clear_joint_speed_limits();
  static const int kJointSpeedLimitsFieldNumber = 4;
  float joint_speed_limits(int index) const;
  void set_joint_speed_limits(int index, float value);
  void add_joint_speed_limits(float value);
  const ::google::protobuf::RepeatedField< float >&
      joint_speed_limits() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_joint_speed_limits();

  // repeated float joint_acceleration_limits = 5;
  int joint_acceleration_limits_size() const;
  void clear_joint_acceleration_limits();
  static const int kJointAccelerationLimitsFieldNumber = 5;
  float joint_acceleration_limits(int index) const;
  void set_joint_acceleration_limits(int index, float value);
  void add_joint_acceleration_limits(float value);
  const ::google::protobuf::RepeatedField< float >&
      joint_acceleration_limits() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_joint_acceleration_limits();

  // .Kinova.Api.ControlConfig.ControlMode control_mode = 1;
  void clear_control_mode();
  static const int kControlModeFieldNumber = 1;
  ::Kinova::Api::ControlConfig::ControlMode control_mode() const;
  void set_control_mode(::Kinova::Api::ControlConfig::ControlMode value);

  // float twist_linear = 2;
  void clear_twist_linear();
  static const int kTwistLinearFieldNumber = 2;
  float twist_linear() const;
  void set_twist_linear(float value);

  // float twist_angular = 3;
  void clear_twist_angular();
  static const int kTwistAngularFieldNumber = 3;
  float twist_angular() const;
  void set_twist_angular(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.KinematicLimits)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > joint_speed_limits_;
  mutable int _joint_speed_limits_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > joint_acceleration_limits_;
  mutable int _joint_acceleration_limits_cached_byte_size_;
  int control_mode_;
  float twist_linear_;
  float twist_angular_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsKinematicLimitsImpl();
};
// -------------------------------------------------------------------

class KinematicLimitsList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.KinematicLimitsList) */ {
 public:
  KinematicLimitsList();
  virtual ~KinematicLimitsList();

  KinematicLimitsList(const KinematicLimitsList& from);

  inline KinematicLimitsList& operator=(const KinematicLimitsList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KinematicLimitsList(KinematicLimitsList&& from) noexcept
    : KinematicLimitsList() {
    *this = ::std::move(from);
  }

  inline KinematicLimitsList& operator=(KinematicLimitsList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KinematicLimitsList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KinematicLimitsList* internal_default_instance() {
    return reinterpret_cast<const KinematicLimitsList*>(
               &_KinematicLimitsList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(KinematicLimitsList* other);
  friend void swap(KinematicLimitsList& a, KinematicLimitsList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KinematicLimitsList* New() const PROTOBUF_FINAL { return New(NULL); }

  KinematicLimitsList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KinematicLimitsList& from);
  void MergeFrom(const KinematicLimitsList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KinematicLimitsList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.ControlConfig.KinematicLimits kinematic_limits_list = 1;
  int kinematic_limits_list_size() const;
  void clear_kinematic_limits_list();
  static const int kKinematicLimitsListFieldNumber = 1;
  const ::Kinova::Api::ControlConfig::KinematicLimits& kinematic_limits_list(int index) const;
  ::Kinova::Api::ControlConfig::KinematicLimits* mutable_kinematic_limits_list(int index);
  ::Kinova::Api::ControlConfig::KinematicLimits* add_kinematic_limits_list();
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::ControlConfig::KinematicLimits >*
      mutable_kinematic_limits_list();
  const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::ControlConfig::KinematicLimits >&
      kinematic_limits_list() const;

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.KinematicLimitsList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Kinova::Api::ControlConfig::KinematicLimits > kinematic_limits_list_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsKinematicLimitsListImpl();
};
// -------------------------------------------------------------------

class DesiredSpeeds : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.DesiredSpeeds) */ {
 public:
  DesiredSpeeds();
  virtual ~DesiredSpeeds();

  DesiredSpeeds(const DesiredSpeeds& from);

  inline DesiredSpeeds& operator=(const DesiredSpeeds& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DesiredSpeeds(DesiredSpeeds&& from) noexcept
    : DesiredSpeeds() {
    *this = ::std::move(from);
  }

  inline DesiredSpeeds& operator=(DesiredSpeeds&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DesiredSpeeds& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DesiredSpeeds* internal_default_instance() {
    return reinterpret_cast<const DesiredSpeeds*>(
               &_DesiredSpeeds_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(DesiredSpeeds* other);
  friend void swap(DesiredSpeeds& a, DesiredSpeeds& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DesiredSpeeds* New() const PROTOBUF_FINAL { return New(NULL); }

  DesiredSpeeds* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DesiredSpeeds& from);
  void MergeFrom(const DesiredSpeeds& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DesiredSpeeds* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float joint_speed = 3;
  int joint_speed_size() const;
  void clear_joint_speed();
  static const int kJointSpeedFieldNumber = 3;
  float joint_speed(int index) const;
  void set_joint_speed(int index, float value);
  void add_joint_speed(float value);
  const ::google::protobuf::RepeatedField< float >&
      joint_speed() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_joint_speed();

  // float linear = 1;
  void clear_linear();
  static const int kLinearFieldNumber = 1;
  float linear() const;
  void set_linear(float value);

  // float angular = 2;
  void clear_angular();
  static const int kAngularFieldNumber = 2;
  float angular() const;
  void set_angular(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.DesiredSpeeds)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > joint_speed_;
  mutable int _joint_speed_cached_byte_size_;
  float linear_;
  float angular_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsDesiredSpeedsImpl();
};
// -------------------------------------------------------------------

class LinearTwist : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.LinearTwist) */ {
 public:
  LinearTwist();
  virtual ~LinearTwist();

  LinearTwist(const LinearTwist& from);

  inline LinearTwist& operator=(const LinearTwist& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinearTwist(LinearTwist&& from) noexcept
    : LinearTwist() {
    *this = ::std::move(from);
  }

  inline LinearTwist& operator=(LinearTwist&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LinearTwist& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinearTwist* internal_default_instance() {
    return reinterpret_cast<const LinearTwist*>(
               &_LinearTwist_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(LinearTwist* other);
  friend void swap(LinearTwist& a, LinearTwist& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinearTwist* New() const PROTOBUF_FINAL { return New(NULL); }

  LinearTwist* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinearTwist& from);
  void MergeFrom(const LinearTwist& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinearTwist* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float linear = 1;
  void clear_linear();
  static const int kLinearFieldNumber = 1;
  float linear() const;
  void set_linear(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.LinearTwist)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float linear_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsLinearTwistImpl();
};
// -------------------------------------------------------------------

class AngularTwist : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.AngularTwist) */ {
 public:
  AngularTwist();
  virtual ~AngularTwist();

  AngularTwist(const AngularTwist& from);

  inline AngularTwist& operator=(const AngularTwist& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AngularTwist(AngularTwist&& from) noexcept
    : AngularTwist() {
    *this = ::std::move(from);
  }

  inline AngularTwist& operator=(AngularTwist&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AngularTwist& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AngularTwist* internal_default_instance() {
    return reinterpret_cast<const AngularTwist*>(
               &_AngularTwist_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(AngularTwist* other);
  friend void swap(AngularTwist& a, AngularTwist& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AngularTwist* New() const PROTOBUF_FINAL { return New(NULL); }

  AngularTwist* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AngularTwist& from);
  void MergeFrom(const AngularTwist& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AngularTwist* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float angular = 1;
  void clear_angular();
  static const int kAngularFieldNumber = 1;
  float angular() const;
  void set_angular(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.AngularTwist)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float angular_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsAngularTwistImpl();
};
// -------------------------------------------------------------------

class JointSpeeds : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.JointSpeeds) */ {
 public:
  JointSpeeds();
  virtual ~JointSpeeds();

  JointSpeeds(const JointSpeeds& from);

  inline JointSpeeds& operator=(const JointSpeeds& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointSpeeds(JointSpeeds&& from) noexcept
    : JointSpeeds() {
    *this = ::std::move(from);
  }

  inline JointSpeeds& operator=(JointSpeeds&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JointSpeeds& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointSpeeds* internal_default_instance() {
    return reinterpret_cast<const JointSpeeds*>(
               &_JointSpeeds_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(JointSpeeds* other);
  friend void swap(JointSpeeds& a, JointSpeeds& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointSpeeds* New() const PROTOBUF_FINAL { return New(NULL); }

  JointSpeeds* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JointSpeeds& from);
  void MergeFrom(const JointSpeeds& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JointSpeeds* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float joint_speed = 1;
  int joint_speed_size() const;
  void clear_joint_speed();
  static const int kJointSpeedFieldNumber = 1;
  float joint_speed(int index) const;
  void set_joint_speed(int index, float value);
  void add_joint_speed(float value);
  const ::google::protobuf::RepeatedField< float >&
      joint_speed() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_joint_speed();

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.JointSpeeds)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > joint_speed_;
  mutable int _joint_speed_cached_byte_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsJointSpeedsImpl();
};
// -------------------------------------------------------------------

class ControlModeInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.ControlModeInformation) */ {
 public:
  ControlModeInformation();
  virtual ~ControlModeInformation();

  ControlModeInformation(const ControlModeInformation& from);

  inline ControlModeInformation& operator=(const ControlModeInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlModeInformation(ControlModeInformation&& from) noexcept
    : ControlModeInformation() {
    *this = ::std::move(from);
  }

  inline ControlModeInformation& operator=(ControlModeInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlModeInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlModeInformation* internal_default_instance() {
    return reinterpret_cast<const ControlModeInformation*>(
               &_ControlModeInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(ControlModeInformation* other);
  friend void swap(ControlModeInformation& a, ControlModeInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlModeInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  ControlModeInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControlModeInformation& from);
  void MergeFrom(const ControlModeInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControlModeInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.ControlConfig.ControlMode control_mode = 1;
  void clear_control_mode();
  static const int kControlModeFieldNumber = 1;
  ::Kinova::Api::ControlConfig::ControlMode control_mode() const;
  void set_control_mode(::Kinova::Api::ControlConfig::ControlMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.ControlModeInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int control_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsControlModeInformationImpl();
};
// -------------------------------------------------------------------

class ControlModeNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ControlConfig.ControlModeNotification) */ {
 public:
  ControlModeNotification();
  virtual ~ControlModeNotification();

  ControlModeNotification(const ControlModeNotification& from);

  inline ControlModeNotification& operator=(const ControlModeNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlModeNotification(ControlModeNotification&& from) noexcept
    : ControlModeNotification() {
    *this = ::std::move(from);
  }

  inline ControlModeNotification& operator=(ControlModeNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlModeNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlModeNotification* internal_default_instance() {
    return reinterpret_cast<const ControlModeNotification*>(
               &_ControlModeNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(ControlModeNotification* other);
  friend void swap(ControlModeNotification& a, ControlModeNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlModeNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  ControlModeNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControlModeNotification& from);
  void MergeFrom(const ControlModeNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControlModeNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.Timestamp timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 3;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 3;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 4;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 4;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.ControlConfig.ControlMode control_mode = 1;
  void clear_control_mode();
  static const int kControlModeFieldNumber = 1;
  ::Kinova::Api::ControlConfig::ControlMode control_mode() const;
  void set_control_mode(::Kinova::Api::ControlConfig::ControlMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ControlConfig.ControlModeNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  int control_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_ControlConfig_2eproto::TableStruct;
  friend void ::protobuf_ControlConfig_2eproto::InitDefaultsControlModeNotificationImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GravityVector

// float x = 1;
inline void GravityVector::clear_x() {
  x_ = 0;
}
inline float GravityVector::x() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.GravityVector.x)
  return x_;
}
inline void GravityVector::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.GravityVector.x)
}

// float y = 2;
inline void GravityVector::clear_y() {
  y_ = 0;
}
inline float GravityVector::y() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.GravityVector.y)
  return y_;
}
inline void GravityVector::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.GravityVector.y)
}

// float z = 3;
inline void GravityVector::clear_z() {
  z_ = 0;
}
inline float GravityVector::z() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.GravityVector.z)
  return z_;
}
inline void GravityVector::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.GravityVector.z)
}

// -------------------------------------------------------------------

// Position

// float x = 1;
inline void Position::clear_x() {
  x_ = 0;
}
inline float Position::x() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.Position.x)
  return x_;
}
inline void Position::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.Position.x)
}

// float y = 2;
inline void Position::clear_y() {
  y_ = 0;
}
inline float Position::y() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.Position.y)
  return y_;
}
inline void Position::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.Position.y)
}

// float z = 3;
inline void Position::clear_z() {
  z_ = 0;
}
inline float Position::z() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.Position.z)
  return z_;
}
inline void Position::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.Position.z)
}

// -------------------------------------------------------------------

// PayloadInformation

// float payload_mass = 1;
inline void PayloadInformation::clear_payload_mass() {
  payload_mass_ = 0;
}
inline float PayloadInformation::payload_mass() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.PayloadInformation.payload_mass)
  return payload_mass_;
}
inline void PayloadInformation::set_payload_mass(float value) {
  
  payload_mass_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.PayloadInformation.payload_mass)
}

// .Kinova.Api.ControlConfig.Position payload_mass_center = 2;
inline bool PayloadInformation::has_payload_mass_center() const {
  return this != internal_default_instance() && payload_mass_center_ != NULL;
}
inline void PayloadInformation::clear_payload_mass_center() {
  if (GetArenaNoVirtual() == NULL && payload_mass_center_ != NULL) {
    delete payload_mass_center_;
  }
  payload_mass_center_ = NULL;
}
inline const ::Kinova::Api::ControlConfig::Position& PayloadInformation::payload_mass_center() const {
  const ::Kinova::Api::ControlConfig::Position* p = payload_mass_center_;
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.PayloadInformation.payload_mass_center)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::ControlConfig::Position*>(
      &::Kinova::Api::ControlConfig::_Position_default_instance_);
}
inline ::Kinova::Api::ControlConfig::Position* PayloadInformation::release_payload_mass_center() {
  // @@protoc_insertion_point(field_release:Kinova.Api.ControlConfig.PayloadInformation.payload_mass_center)
  
  ::Kinova::Api::ControlConfig::Position* temp = payload_mass_center_;
  payload_mass_center_ = NULL;
  return temp;
}
inline ::Kinova::Api::ControlConfig::Position* PayloadInformation::mutable_payload_mass_center() {
  
  if (payload_mass_center_ == NULL) {
    payload_mass_center_ = new ::Kinova::Api::ControlConfig::Position;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.ControlConfig.PayloadInformation.payload_mass_center)
  return payload_mass_center_;
}
inline void PayloadInformation::set_allocated_payload_mass_center(::Kinova::Api::ControlConfig::Position* payload_mass_center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete payload_mass_center_;
  }
  if (payload_mass_center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      payload_mass_center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, payload_mass_center, submessage_arena);
    }
    
  } else {
    
  }
  payload_mass_center_ = payload_mass_center;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.ControlConfig.PayloadInformation.payload_mass_center)
}

// -------------------------------------------------------------------

// CartesianTransform

// float x = 1;
inline void CartesianTransform::clear_x() {
  x_ = 0;
}
inline float CartesianTransform::x() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.CartesianTransform.x)
  return x_;
}
inline void CartesianTransform::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.CartesianTransform.x)
}

// float y = 2;
inline void CartesianTransform::clear_y() {
  y_ = 0;
}
inline float CartesianTransform::y() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.CartesianTransform.y)
  return y_;
}
inline void CartesianTransform::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.CartesianTransform.y)
}

// float z = 3;
inline void CartesianTransform::clear_z() {
  z_ = 0;
}
inline float CartesianTransform::z() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.CartesianTransform.z)
  return z_;
}
inline void CartesianTransform::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.CartesianTransform.z)
}

// float theta_x = 4;
inline void CartesianTransform::clear_theta_x() {
  theta_x_ = 0;
}
inline float CartesianTransform::theta_x() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.CartesianTransform.theta_x)
  return theta_x_;
}
inline void CartesianTransform::set_theta_x(float value) {
  
  theta_x_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.CartesianTransform.theta_x)
}

// float theta_y = 5;
inline void CartesianTransform::clear_theta_y() {
  theta_y_ = 0;
}
inline float CartesianTransform::theta_y() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.CartesianTransform.theta_y)
  return theta_y_;
}
inline void CartesianTransform::set_theta_y(float value) {
  
  theta_y_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.CartesianTransform.theta_y)
}

// float theta_z = 6;
inline void CartesianTransform::clear_theta_z() {
  theta_z_ = 0;
}
inline float CartesianTransform::theta_z() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.CartesianTransform.theta_z)
  return theta_z_;
}
inline void CartesianTransform::set_theta_z(float value) {
  
  theta_z_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.CartesianTransform.theta_z)
}

// -------------------------------------------------------------------

// ToolConfiguration

// .Kinova.Api.ControlConfig.CartesianTransform tool_transform = 1;
inline bool ToolConfiguration::has_tool_transform() const {
  return this != internal_default_instance() && tool_transform_ != NULL;
}
inline void ToolConfiguration::clear_tool_transform() {
  if (GetArenaNoVirtual() == NULL && tool_transform_ != NULL) {
    delete tool_transform_;
  }
  tool_transform_ = NULL;
}
inline const ::Kinova::Api::ControlConfig::CartesianTransform& ToolConfiguration::tool_transform() const {
  const ::Kinova::Api::ControlConfig::CartesianTransform* p = tool_transform_;
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.ToolConfiguration.tool_transform)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::ControlConfig::CartesianTransform*>(
      &::Kinova::Api::ControlConfig::_CartesianTransform_default_instance_);
}
inline ::Kinova::Api::ControlConfig::CartesianTransform* ToolConfiguration::release_tool_transform() {
  // @@protoc_insertion_point(field_release:Kinova.Api.ControlConfig.ToolConfiguration.tool_transform)
  
  ::Kinova::Api::ControlConfig::CartesianTransform* temp = tool_transform_;
  tool_transform_ = NULL;
  return temp;
}
inline ::Kinova::Api::ControlConfig::CartesianTransform* ToolConfiguration::mutable_tool_transform() {
  
  if (tool_transform_ == NULL) {
    tool_transform_ = new ::Kinova::Api::ControlConfig::CartesianTransform;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.ControlConfig.ToolConfiguration.tool_transform)
  return tool_transform_;
}
inline void ToolConfiguration::set_allocated_tool_transform(::Kinova::Api::ControlConfig::CartesianTransform* tool_transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tool_transform_;
  }
  if (tool_transform) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tool_transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tool_transform, submessage_arena);
    }
    
  } else {
    
  }
  tool_transform_ = tool_transform;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.ControlConfig.ToolConfiguration.tool_transform)
}

// float tool_mass = 2;
inline void ToolConfiguration::clear_tool_mass() {
  tool_mass_ = 0;
}
inline float ToolConfiguration::tool_mass() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.ToolConfiguration.tool_mass)
  return tool_mass_;
}
inline void ToolConfiguration::set_tool_mass(float value) {
  
  tool_mass_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.ToolConfiguration.tool_mass)
}

// .Kinova.Api.ControlConfig.Position tool_mass_center = 3;
inline bool ToolConfiguration::has_tool_mass_center() const {
  return this != internal_default_instance() && tool_mass_center_ != NULL;
}
inline void ToolConfiguration::clear_tool_mass_center() {
  if (GetArenaNoVirtual() == NULL && tool_mass_center_ != NULL) {
    delete tool_mass_center_;
  }
  tool_mass_center_ = NULL;
}
inline const ::Kinova::Api::ControlConfig::Position& ToolConfiguration::tool_mass_center() const {
  const ::Kinova::Api::ControlConfig::Position* p = tool_mass_center_;
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.ToolConfiguration.tool_mass_center)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::ControlConfig::Position*>(
      &::Kinova::Api::ControlConfig::_Position_default_instance_);
}
inline ::Kinova::Api::ControlConfig::Position* ToolConfiguration::release_tool_mass_center() {
  // @@protoc_insertion_point(field_release:Kinova.Api.ControlConfig.ToolConfiguration.tool_mass_center)
  
  ::Kinova::Api::ControlConfig::Position* temp = tool_mass_center_;
  tool_mass_center_ = NULL;
  return temp;
}
inline ::Kinova::Api::ControlConfig::Position* ToolConfiguration::mutable_tool_mass_center() {
  
  if (tool_mass_center_ == NULL) {
    tool_mass_center_ = new ::Kinova::Api::ControlConfig::Position;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.ControlConfig.ToolConfiguration.tool_mass_center)
  return tool_mass_center_;
}
inline void ToolConfiguration::set_allocated_tool_mass_center(::Kinova::Api::ControlConfig::Position* tool_mass_center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tool_mass_center_;
  }
  if (tool_mass_center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tool_mass_center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tool_mass_center, submessage_arena);
    }
    
  } else {
    
  }
  tool_mass_center_ = tool_mass_center;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.ControlConfig.ToolConfiguration.tool_mass_center)
}

// -------------------------------------------------------------------

// ControlConfigurationNotification

// .Kinova.Api.ControlConfig.ControlConfigurationEvent event = 1;
inline void ControlConfigurationNotification::clear_event() {
  event_ = 0;
}
inline ::Kinova::Api::ControlConfig::ControlConfigurationEvent ControlConfigurationNotification::event() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.ControlConfigurationNotification.event)
  return static_cast< ::Kinova::Api::ControlConfig::ControlConfigurationEvent >(event_);
}
inline void ControlConfigurationNotification::set_event(::Kinova::Api::ControlConfig::ControlConfigurationEvent value) {
  
  event_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.ControlConfigurationNotification.event)
}

// .Kinova.Api.Common.Timestamp timestamp = 2;
inline bool ControlConfigurationNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& ControlConfigurationNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.ControlConfigurationNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* ControlConfigurationNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.ControlConfig.ControlConfigurationNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* ControlConfigurationNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.ControlConfig.ControlConfigurationNotification.timestamp)
  return timestamp_;
}
inline void ControlConfigurationNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.ControlConfig.ControlConfigurationNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 3;
inline bool ControlConfigurationNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& ControlConfigurationNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.ControlConfigurationNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* ControlConfigurationNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.ControlConfig.ControlConfigurationNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* ControlConfigurationNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.ControlConfig.ControlConfigurationNotification.user_handle)
  return user_handle_;
}
inline void ControlConfigurationNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.ControlConfig.ControlConfigurationNotification.user_handle)
}

// .Kinova.Api.Common.Connection connection = 4;
inline bool ControlConfigurationNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& ControlConfigurationNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.ControlConfigurationNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* ControlConfigurationNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.ControlConfig.ControlConfigurationNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* ControlConfigurationNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.ControlConfig.ControlConfigurationNotification.connection)
  return connection_;
}
inline void ControlConfigurationNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.ControlConfig.ControlConfigurationNotification.connection)
}

// -------------------------------------------------------------------

// CartesianReferenceFrameInfo

// .Kinova.Api.Common.CartesianReferenceFrame reference_frame = 1;
inline void CartesianReferenceFrameInfo::clear_reference_frame() {
  reference_frame_ = 0;
}
inline ::Kinova::Api::Common::CartesianReferenceFrame CartesianReferenceFrameInfo::reference_frame() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.CartesianReferenceFrameInfo.reference_frame)
  return static_cast< ::Kinova::Api::Common::CartesianReferenceFrame >(reference_frame_);
}
inline void CartesianReferenceFrameInfo::set_reference_frame(::Kinova::Api::Common::CartesianReferenceFrame value) {
  
  reference_frame_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.CartesianReferenceFrameInfo.reference_frame)
}

// -------------------------------------------------------------------

// TwistLinearSoftLimit

// .Kinova.Api.ControlConfig.ControlMode control_mode = 1;
inline void TwistLinearSoftLimit::clear_control_mode() {
  control_mode_ = 0;
}
inline ::Kinova::Api::ControlConfig::ControlMode TwistLinearSoftLimit::control_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.TwistLinearSoftLimit.control_mode)
  return static_cast< ::Kinova::Api::ControlConfig::ControlMode >(control_mode_);
}
inline void TwistLinearSoftLimit::set_control_mode(::Kinova::Api::ControlConfig::ControlMode value) {
  
  control_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.TwistLinearSoftLimit.control_mode)
}

// float twist_linear_soft_limit = 2;
inline void TwistLinearSoftLimit::clear_twist_linear_soft_limit() {
  twist_linear_soft_limit_ = 0;
}
inline float TwistLinearSoftLimit::twist_linear_soft_limit() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.TwistLinearSoftLimit.twist_linear_soft_limit)
  return twist_linear_soft_limit_;
}
inline void TwistLinearSoftLimit::set_twist_linear_soft_limit(float value) {
  
  twist_linear_soft_limit_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.TwistLinearSoftLimit.twist_linear_soft_limit)
}

// -------------------------------------------------------------------

// TwistAngularSoftLimit

// .Kinova.Api.ControlConfig.ControlMode control_mode = 1;
inline void TwistAngularSoftLimit::clear_control_mode() {
  control_mode_ = 0;
}
inline ::Kinova::Api::ControlConfig::ControlMode TwistAngularSoftLimit::control_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.TwistAngularSoftLimit.control_mode)
  return static_cast< ::Kinova::Api::ControlConfig::ControlMode >(control_mode_);
}
inline void TwistAngularSoftLimit::set_control_mode(::Kinova::Api::ControlConfig::ControlMode value) {
  
  control_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.TwistAngularSoftLimit.control_mode)
}

// float twist_angular_soft_limit = 2;
inline void TwistAngularSoftLimit::clear_twist_angular_soft_limit() {
  twist_angular_soft_limit_ = 0;
}
inline float TwistAngularSoftLimit::twist_angular_soft_limit() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.TwistAngularSoftLimit.twist_angular_soft_limit)
  return twist_angular_soft_limit_;
}
inline void TwistAngularSoftLimit::set_twist_angular_soft_limit(float value) {
  
  twist_angular_soft_limit_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.TwistAngularSoftLimit.twist_angular_soft_limit)
}

// -------------------------------------------------------------------

// JointSpeedSoftLimits

// .Kinova.Api.ControlConfig.ControlMode control_mode = 1;
inline void JointSpeedSoftLimits::clear_control_mode() {
  control_mode_ = 0;
}
inline ::Kinova::Api::ControlConfig::ControlMode JointSpeedSoftLimits::control_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.JointSpeedSoftLimits.control_mode)
  return static_cast< ::Kinova::Api::ControlConfig::ControlMode >(control_mode_);
}
inline void JointSpeedSoftLimits::set_control_mode(::Kinova::Api::ControlConfig::ControlMode value) {
  
  control_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.JointSpeedSoftLimits.control_mode)
}

// repeated float joint_speed_soft_limits = 2;
inline int JointSpeedSoftLimits::joint_speed_soft_limits_size() const {
  return joint_speed_soft_limits_.size();
}
inline void JointSpeedSoftLimits::clear_joint_speed_soft_limits() {
  joint_speed_soft_limits_.Clear();
}
inline float JointSpeedSoftLimits::joint_speed_soft_limits(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.JointSpeedSoftLimits.joint_speed_soft_limits)
  return joint_speed_soft_limits_.Get(index);
}
inline void JointSpeedSoftLimits::set_joint_speed_soft_limits(int index, float value) {
  joint_speed_soft_limits_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.JointSpeedSoftLimits.joint_speed_soft_limits)
}
inline void JointSpeedSoftLimits::add_joint_speed_soft_limits(float value) {
  joint_speed_soft_limits_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.ControlConfig.JointSpeedSoftLimits.joint_speed_soft_limits)
}
inline const ::google::protobuf::RepeatedField< float >&
JointSpeedSoftLimits::joint_speed_soft_limits() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.ControlConfig.JointSpeedSoftLimits.joint_speed_soft_limits)
  return joint_speed_soft_limits_;
}
inline ::google::protobuf::RepeatedField< float >*
JointSpeedSoftLimits::mutable_joint_speed_soft_limits() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.ControlConfig.JointSpeedSoftLimits.joint_speed_soft_limits)
  return &joint_speed_soft_limits_;
}

// -------------------------------------------------------------------

// JointAccelerationSoftLimits

// .Kinova.Api.ControlConfig.ControlMode control_mode = 1;
inline void JointAccelerationSoftLimits::clear_control_mode() {
  control_mode_ = 0;
}
inline ::Kinova::Api::ControlConfig::ControlMode JointAccelerationSoftLimits::control_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.JointAccelerationSoftLimits.control_mode)
  return static_cast< ::Kinova::Api::ControlConfig::ControlMode >(control_mode_);
}
inline void JointAccelerationSoftLimits::set_control_mode(::Kinova::Api::ControlConfig::ControlMode value) {
  
  control_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.JointAccelerationSoftLimits.control_mode)
}

// repeated float joint_acceleration_soft_limits = 2;
inline int JointAccelerationSoftLimits::joint_acceleration_soft_limits_size() const {
  return joint_acceleration_soft_limits_.size();
}
inline void JointAccelerationSoftLimits::clear_joint_acceleration_soft_limits() {
  joint_acceleration_soft_limits_.Clear();
}
inline float JointAccelerationSoftLimits::joint_acceleration_soft_limits(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.JointAccelerationSoftLimits.joint_acceleration_soft_limits)
  return joint_acceleration_soft_limits_.Get(index);
}
inline void JointAccelerationSoftLimits::set_joint_acceleration_soft_limits(int index, float value) {
  joint_acceleration_soft_limits_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.JointAccelerationSoftLimits.joint_acceleration_soft_limits)
}
inline void JointAccelerationSoftLimits::add_joint_acceleration_soft_limits(float value) {
  joint_acceleration_soft_limits_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.ControlConfig.JointAccelerationSoftLimits.joint_acceleration_soft_limits)
}
inline const ::google::protobuf::RepeatedField< float >&
JointAccelerationSoftLimits::joint_acceleration_soft_limits() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.ControlConfig.JointAccelerationSoftLimits.joint_acceleration_soft_limits)
  return joint_acceleration_soft_limits_;
}
inline ::google::protobuf::RepeatedField< float >*
JointAccelerationSoftLimits::mutable_joint_acceleration_soft_limits() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.ControlConfig.JointAccelerationSoftLimits.joint_acceleration_soft_limits)
  return &joint_acceleration_soft_limits_;
}

// -------------------------------------------------------------------

// KinematicLimits

// .Kinova.Api.ControlConfig.ControlMode control_mode = 1;
inline void KinematicLimits::clear_control_mode() {
  control_mode_ = 0;
}
inline ::Kinova::Api::ControlConfig::ControlMode KinematicLimits::control_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.KinematicLimits.control_mode)
  return static_cast< ::Kinova::Api::ControlConfig::ControlMode >(control_mode_);
}
inline void KinematicLimits::set_control_mode(::Kinova::Api::ControlConfig::ControlMode value) {
  
  control_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.KinematicLimits.control_mode)
}

// float twist_linear = 2;
inline void KinematicLimits::clear_twist_linear() {
  twist_linear_ = 0;
}
inline float KinematicLimits::twist_linear() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.KinematicLimits.twist_linear)
  return twist_linear_;
}
inline void KinematicLimits::set_twist_linear(float value) {
  
  twist_linear_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.KinematicLimits.twist_linear)
}

// float twist_angular = 3;
inline void KinematicLimits::clear_twist_angular() {
  twist_angular_ = 0;
}
inline float KinematicLimits::twist_angular() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.KinematicLimits.twist_angular)
  return twist_angular_;
}
inline void KinematicLimits::set_twist_angular(float value) {
  
  twist_angular_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.KinematicLimits.twist_angular)
}

// repeated float joint_speed_limits = 4;
inline int KinematicLimits::joint_speed_limits_size() const {
  return joint_speed_limits_.size();
}
inline void KinematicLimits::clear_joint_speed_limits() {
  joint_speed_limits_.Clear();
}
inline float KinematicLimits::joint_speed_limits(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.KinematicLimits.joint_speed_limits)
  return joint_speed_limits_.Get(index);
}
inline void KinematicLimits::set_joint_speed_limits(int index, float value) {
  joint_speed_limits_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.KinematicLimits.joint_speed_limits)
}
inline void KinematicLimits::add_joint_speed_limits(float value) {
  joint_speed_limits_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.ControlConfig.KinematicLimits.joint_speed_limits)
}
inline const ::google::protobuf::RepeatedField< float >&
KinematicLimits::joint_speed_limits() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.ControlConfig.KinematicLimits.joint_speed_limits)
  return joint_speed_limits_;
}
inline ::google::protobuf::RepeatedField< float >*
KinematicLimits::mutable_joint_speed_limits() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.ControlConfig.KinematicLimits.joint_speed_limits)
  return &joint_speed_limits_;
}

// repeated float joint_acceleration_limits = 5;
inline int KinematicLimits::joint_acceleration_limits_size() const {
  return joint_acceleration_limits_.size();
}
inline void KinematicLimits::clear_joint_acceleration_limits() {
  joint_acceleration_limits_.Clear();
}
inline float KinematicLimits::joint_acceleration_limits(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.KinematicLimits.joint_acceleration_limits)
  return joint_acceleration_limits_.Get(index);
}
inline void KinematicLimits::set_joint_acceleration_limits(int index, float value) {
  joint_acceleration_limits_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.KinematicLimits.joint_acceleration_limits)
}
inline void KinematicLimits::add_joint_acceleration_limits(float value) {
  joint_acceleration_limits_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.ControlConfig.KinematicLimits.joint_acceleration_limits)
}
inline const ::google::protobuf::RepeatedField< float >&
KinematicLimits::joint_acceleration_limits() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.ControlConfig.KinematicLimits.joint_acceleration_limits)
  return joint_acceleration_limits_;
}
inline ::google::protobuf::RepeatedField< float >*
KinematicLimits::mutable_joint_acceleration_limits() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.ControlConfig.KinematicLimits.joint_acceleration_limits)
  return &joint_acceleration_limits_;
}

// -------------------------------------------------------------------

// KinematicLimitsList

// repeated .Kinova.Api.ControlConfig.KinematicLimits kinematic_limits_list = 1;
inline int KinematicLimitsList::kinematic_limits_list_size() const {
  return kinematic_limits_list_.size();
}
inline void KinematicLimitsList::clear_kinematic_limits_list() {
  kinematic_limits_list_.Clear();
}
inline const ::Kinova::Api::ControlConfig::KinematicLimits& KinematicLimitsList::kinematic_limits_list(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.KinematicLimitsList.kinematic_limits_list)
  return kinematic_limits_list_.Get(index);
}
inline ::Kinova::Api::ControlConfig::KinematicLimits* KinematicLimitsList::mutable_kinematic_limits_list(int index) {
  // @@protoc_insertion_point(field_mutable:Kinova.Api.ControlConfig.KinematicLimitsList.kinematic_limits_list)
  return kinematic_limits_list_.Mutable(index);
}
inline ::Kinova::Api::ControlConfig::KinematicLimits* KinematicLimitsList::add_kinematic_limits_list() {
  // @@protoc_insertion_point(field_add:Kinova.Api.ControlConfig.KinematicLimitsList.kinematic_limits_list)
  return kinematic_limits_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Kinova::Api::ControlConfig::KinematicLimits >*
KinematicLimitsList::mutable_kinematic_limits_list() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.ControlConfig.KinematicLimitsList.kinematic_limits_list)
  return &kinematic_limits_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Kinova::Api::ControlConfig::KinematicLimits >&
KinematicLimitsList::kinematic_limits_list() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.ControlConfig.KinematicLimitsList.kinematic_limits_list)
  return kinematic_limits_list_;
}

// -------------------------------------------------------------------

// DesiredSpeeds

// float linear = 1;
inline void DesiredSpeeds::clear_linear() {
  linear_ = 0;
}
inline float DesiredSpeeds::linear() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.DesiredSpeeds.linear)
  return linear_;
}
inline void DesiredSpeeds::set_linear(float value) {
  
  linear_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.DesiredSpeeds.linear)
}

// float angular = 2;
inline void DesiredSpeeds::clear_angular() {
  angular_ = 0;
}
inline float DesiredSpeeds::angular() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.DesiredSpeeds.angular)
  return angular_;
}
inline void DesiredSpeeds::set_angular(float value) {
  
  angular_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.DesiredSpeeds.angular)
}

// repeated float joint_speed = 3;
inline int DesiredSpeeds::joint_speed_size() const {
  return joint_speed_.size();
}
inline void DesiredSpeeds::clear_joint_speed() {
  joint_speed_.Clear();
}
inline float DesiredSpeeds::joint_speed(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.DesiredSpeeds.joint_speed)
  return joint_speed_.Get(index);
}
inline void DesiredSpeeds::set_joint_speed(int index, float value) {
  joint_speed_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.DesiredSpeeds.joint_speed)
}
inline void DesiredSpeeds::add_joint_speed(float value) {
  joint_speed_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.ControlConfig.DesiredSpeeds.joint_speed)
}
inline const ::google::protobuf::RepeatedField< float >&
DesiredSpeeds::joint_speed() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.ControlConfig.DesiredSpeeds.joint_speed)
  return joint_speed_;
}
inline ::google::protobuf::RepeatedField< float >*
DesiredSpeeds::mutable_joint_speed() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.ControlConfig.DesiredSpeeds.joint_speed)
  return &joint_speed_;
}

// -------------------------------------------------------------------

// LinearTwist

// float linear = 1;
inline void LinearTwist::clear_linear() {
  linear_ = 0;
}
inline float LinearTwist::linear() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.LinearTwist.linear)
  return linear_;
}
inline void LinearTwist::set_linear(float value) {
  
  linear_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.LinearTwist.linear)
}

// -------------------------------------------------------------------

// AngularTwist

// float angular = 1;
inline void AngularTwist::clear_angular() {
  angular_ = 0;
}
inline float AngularTwist::angular() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.AngularTwist.angular)
  return angular_;
}
inline void AngularTwist::set_angular(float value) {
  
  angular_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.AngularTwist.angular)
}

// -------------------------------------------------------------------

// JointSpeeds

// repeated float joint_speed = 1;
inline int JointSpeeds::joint_speed_size() const {
  return joint_speed_.size();
}
inline void JointSpeeds::clear_joint_speed() {
  joint_speed_.Clear();
}
inline float JointSpeeds::joint_speed(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.JointSpeeds.joint_speed)
  return joint_speed_.Get(index);
}
inline void JointSpeeds::set_joint_speed(int index, float value) {
  joint_speed_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.JointSpeeds.joint_speed)
}
inline void JointSpeeds::add_joint_speed(float value) {
  joint_speed_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.ControlConfig.JointSpeeds.joint_speed)
}
inline const ::google::protobuf::RepeatedField< float >&
JointSpeeds::joint_speed() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.ControlConfig.JointSpeeds.joint_speed)
  return joint_speed_;
}
inline ::google::protobuf::RepeatedField< float >*
JointSpeeds::mutable_joint_speed() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.ControlConfig.JointSpeeds.joint_speed)
  return &joint_speed_;
}

// -------------------------------------------------------------------

// ControlModeInformation

// .Kinova.Api.ControlConfig.ControlMode control_mode = 1;
inline void ControlModeInformation::clear_control_mode() {
  control_mode_ = 0;
}
inline ::Kinova::Api::ControlConfig::ControlMode ControlModeInformation::control_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.ControlModeInformation.control_mode)
  return static_cast< ::Kinova::Api::ControlConfig::ControlMode >(control_mode_);
}
inline void ControlModeInformation::set_control_mode(::Kinova::Api::ControlConfig::ControlMode value) {
  
  control_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.ControlModeInformation.control_mode)
}

// -------------------------------------------------------------------

// ControlModeNotification

// .Kinova.Api.ControlConfig.ControlMode control_mode = 1;
inline void ControlModeNotification::clear_control_mode() {
  control_mode_ = 0;
}
inline ::Kinova::Api::ControlConfig::ControlMode ControlModeNotification::control_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.ControlModeNotification.control_mode)
  return static_cast< ::Kinova::Api::ControlConfig::ControlMode >(control_mode_);
}
inline void ControlModeNotification::set_control_mode(::Kinova::Api::ControlConfig::ControlMode value) {
  
  control_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ControlConfig.ControlModeNotification.control_mode)
}

// .Kinova.Api.Common.Timestamp timestamp = 2;
inline bool ControlModeNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::Kinova::Api::Common::Timestamp& ControlModeNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.ControlModeNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* ControlModeNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.ControlConfig.ControlModeNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* ControlModeNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.ControlConfig.ControlModeNotification.timestamp)
  return timestamp_;
}
inline void ControlModeNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.ControlConfig.ControlModeNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 3;
inline bool ControlModeNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& ControlModeNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.ControlModeNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* ControlModeNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.ControlConfig.ControlModeNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* ControlModeNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.ControlConfig.ControlModeNotification.user_handle)
  return user_handle_;
}
inline void ControlModeNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_handle_);
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.ControlConfig.ControlModeNotification.user_handle)
}

// .Kinova.Api.Common.Connection connection = 4;
inline bool ControlModeNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline const ::Kinova::Api::Common::Connection& ControlModeNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.ControlConfig.ControlModeNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* ControlModeNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.ControlConfig.ControlModeNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* ControlModeNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.ControlConfig.ControlModeNotification.connection)
  return connection_;
}
inline void ControlModeNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connection_);
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.ControlConfig.ControlModeNotification.connection)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ControlConfig
}  // namespace Api
}  // namespace Kinova

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Kinova::Api::ControlConfig::ServiceVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::ControlConfig::ServiceVersion>() {
  return ::Kinova::Api::ControlConfig::ServiceVersion_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::ControlConfig::ControlConfigurationEvent> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::ControlConfig::ControlConfigurationEvent>() {
  return ::Kinova::Api::ControlConfig::ControlConfigurationEvent_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::ControlConfig::ControlMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::ControlConfig::ControlMode>() {
  return ::Kinova::Api::ControlConfig::ControlMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ControlConfig_2eproto__INCLUDED
