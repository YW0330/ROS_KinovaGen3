// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ActuatorConfig.proto

#ifndef PROTOBUF_ActuatorConfig_2eproto__INCLUDED
#define PROTOBUF_ActuatorConfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Common.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace protobuf_ActuatorConfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[18];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsAxisPositionImpl();
void InitDefaultsAxisPosition();
void InitDefaultsAxisOffsetsImpl();
void InitDefaultsAxisOffsets();
void InitDefaultsTorqueCalibrationImpl();
void InitDefaultsTorqueCalibration();
void InitDefaultsTorqueOffsetImpl();
void InitDefaultsTorqueOffset();
void InitDefaultsControlModeInformationImpl();
void InitDefaultsControlModeInformation();
void InitDefaultsControlLoopImpl();
void InitDefaultsControlLoop();
void InitDefaultsLoopSelectionImpl();
void InitDefaultsLoopSelection();
void InitDefaultsVectorDriveParametersImpl();
void InitDefaultsVectorDriveParameters();
void InitDefaultsEncoderDerivativeParametersImpl();
void InitDefaultsEncoderDerivativeParameters();
void InitDefaultsControlLoopParametersImpl();
void InitDefaultsControlLoopParameters();
void InitDefaultsFrequencyResponseImpl();
void InitDefaultsFrequencyResponse();
void InitDefaultsStepResponseImpl();
void InitDefaultsStepResponse();
void InitDefaultsRampResponseImpl();
void InitDefaultsRampResponse();
void InitDefaultsCustomDataSelectionImpl();
void InitDefaultsCustomDataSelection();
void InitDefaultsCommandModeInformationImpl();
void InitDefaultsCommandModeInformation();
void InitDefaultsServoingImpl();
void InitDefaultsServoing();
void InitDefaultsPositionCommandImpl();
void InitDefaultsPositionCommand();
void InitDefaultsCoggingFeedforwardModeInformationImpl();
void InitDefaultsCoggingFeedforwardModeInformation();
inline void InitDefaults() {
  InitDefaultsAxisPosition();
  InitDefaultsAxisOffsets();
  InitDefaultsTorqueCalibration();
  InitDefaultsTorqueOffset();
  InitDefaultsControlModeInformation();
  InitDefaultsControlLoop();
  InitDefaultsLoopSelection();
  InitDefaultsVectorDriveParameters();
  InitDefaultsEncoderDerivativeParameters();
  InitDefaultsControlLoopParameters();
  InitDefaultsFrequencyResponse();
  InitDefaultsStepResponse();
  InitDefaultsRampResponse();
  InitDefaultsCustomDataSelection();
  InitDefaultsCommandModeInformation();
  InitDefaultsServoing();
  InitDefaultsPositionCommand();
  InitDefaultsCoggingFeedforwardModeInformation();
}
}  // namespace protobuf_ActuatorConfig_2eproto
namespace Kinova {
namespace Api {
namespace ActuatorConfig {
class AxisOffsets;
class AxisOffsetsDefaultTypeInternal;
extern AxisOffsetsDefaultTypeInternal _AxisOffsets_default_instance_;
class AxisPosition;
class AxisPositionDefaultTypeInternal;
extern AxisPositionDefaultTypeInternal _AxisPosition_default_instance_;
class CoggingFeedforwardModeInformation;
class CoggingFeedforwardModeInformationDefaultTypeInternal;
extern CoggingFeedforwardModeInformationDefaultTypeInternal _CoggingFeedforwardModeInformation_default_instance_;
class CommandModeInformation;
class CommandModeInformationDefaultTypeInternal;
extern CommandModeInformationDefaultTypeInternal _CommandModeInformation_default_instance_;
class ControlLoop;
class ControlLoopDefaultTypeInternal;
extern ControlLoopDefaultTypeInternal _ControlLoop_default_instance_;
class ControlLoopParameters;
class ControlLoopParametersDefaultTypeInternal;
extern ControlLoopParametersDefaultTypeInternal _ControlLoopParameters_default_instance_;
class ControlModeInformation;
class ControlModeInformationDefaultTypeInternal;
extern ControlModeInformationDefaultTypeInternal _ControlModeInformation_default_instance_;
class CustomDataSelection;
class CustomDataSelectionDefaultTypeInternal;
extern CustomDataSelectionDefaultTypeInternal _CustomDataSelection_default_instance_;
class EncoderDerivativeParameters;
class EncoderDerivativeParametersDefaultTypeInternal;
extern EncoderDerivativeParametersDefaultTypeInternal _EncoderDerivativeParameters_default_instance_;
class FrequencyResponse;
class FrequencyResponseDefaultTypeInternal;
extern FrequencyResponseDefaultTypeInternal _FrequencyResponse_default_instance_;
class LoopSelection;
class LoopSelectionDefaultTypeInternal;
extern LoopSelectionDefaultTypeInternal _LoopSelection_default_instance_;
class PositionCommand;
class PositionCommandDefaultTypeInternal;
extern PositionCommandDefaultTypeInternal _PositionCommand_default_instance_;
class RampResponse;
class RampResponseDefaultTypeInternal;
extern RampResponseDefaultTypeInternal _RampResponse_default_instance_;
class Servoing;
class ServoingDefaultTypeInternal;
extern ServoingDefaultTypeInternal _Servoing_default_instance_;
class StepResponse;
class StepResponseDefaultTypeInternal;
extern StepResponseDefaultTypeInternal _StepResponse_default_instance_;
class TorqueCalibration;
class TorqueCalibrationDefaultTypeInternal;
extern TorqueCalibrationDefaultTypeInternal _TorqueCalibration_default_instance_;
class TorqueOffset;
class TorqueOffsetDefaultTypeInternal;
extern TorqueOffsetDefaultTypeInternal _TorqueOffset_default_instance_;
class VectorDriveParameters;
class VectorDriveParametersDefaultTypeInternal;
extern VectorDriveParametersDefaultTypeInternal _VectorDriveParameters_default_instance_;
}  // namespace ActuatorConfig
}  // namespace Api
}  // namespace Kinova
namespace Kinova {
namespace Api {
namespace ActuatorConfig {

enum ServiceVersion {
  RESERVED_0 = 0,
  CURRENT_VERSION = 1,
  ServiceVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ServiceVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ServiceVersion_IsValid(int value);
const ServiceVersion ServiceVersion_MIN = RESERVED_0;
const ServiceVersion ServiceVersion_MAX = CURRENT_VERSION;
const int ServiceVersion_ARRAYSIZE = ServiceVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceVersion_descriptor();
inline const ::std::string& ServiceVersion_Name(ServiceVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceVersion_descriptor(), value);
}
inline bool ServiceVersion_Parse(
    const ::std::string& name, ServiceVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceVersion>(
    ServiceVersion_descriptor(), name, value);
}
enum SafetyLimitType {
  MAXIMAL_LIMIT = 0,
  MINIMAL_LIMIT = 1,
  SafetyLimitType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SafetyLimitType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SafetyLimitType_IsValid(int value);
const SafetyLimitType SafetyLimitType_MIN = MAXIMAL_LIMIT;
const SafetyLimitType SafetyLimitType_MAX = MINIMAL_LIMIT;
const int SafetyLimitType_ARRAYSIZE = SafetyLimitType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SafetyLimitType_descriptor();
inline const ::std::string& SafetyLimitType_Name(SafetyLimitType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SafetyLimitType_descriptor(), value);
}
inline bool SafetyLimitType_Parse(
    const ::std::string& name, SafetyLimitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SafetyLimitType>(
    SafetyLimitType_descriptor(), name, value);
}
enum ControlMode {
  NONE = 0,
  POSITION = 1,
  VELOCITY = 2,
  TORQUE = 3,
  CURRENT = 4,
  CUSTOM = 5,
  TORQUE_HIGH_VELOCITY = 6,
  ControlMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ControlMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ControlMode_IsValid(int value);
const ControlMode ControlMode_MIN = NONE;
const ControlMode ControlMode_MAX = TORQUE_HIGH_VELOCITY;
const int ControlMode_ARRAYSIZE = ControlMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControlMode_descriptor();
inline const ::std::string& ControlMode_Name(ControlMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControlMode_descriptor(), value);
}
inline bool ControlMode_Parse(
    const ::std::string& name, ControlMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlMode>(
    ControlMode_descriptor(), name, value);
}
enum CommandMode {
  CYCLIC = 0,
  ASYNC_CYCLIC_FLAGS = 1,
  ASYNC = 2,
  CYCLIC_JITTERCOMPENSATED_POSITION = 3,
  CYCLIC_JITTERCOMPENSATED_VELOCITY = 4,
  CYCLIC_JITTERCOMPENSATED_ACCELERATION = 5,
  CommandMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CommandMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CommandMode_IsValid(int value);
const CommandMode CommandMode_MIN = CYCLIC;
const CommandMode CommandMode_MAX = CYCLIC_JITTERCOMPENSATED_ACCELERATION;
const int CommandMode_ARRAYSIZE = CommandMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommandMode_descriptor();
inline const ::std::string& CommandMode_Name(CommandMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommandMode_descriptor(), value);
}
inline bool CommandMode_Parse(
    const ::std::string& name, CommandMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandMode>(
    CommandMode_descriptor(), name, value);
}
enum ControlLoopSelection {
  RESERVED = 0,
  JOINT_POSITION = 1,
  MOTOR_POSITION = 2,
  JOINT_VELOCITY = 4,
  MOTOR_VELOCITY = 8,
  JOINT_TORQUE = 16,
  MOTOR_CURRENT = 32,
  JOINT_TORQUE_HIGH_VELOCITY = 64,
  ControlLoopSelection_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ControlLoopSelection_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ControlLoopSelection_IsValid(int value);
const ControlLoopSelection ControlLoopSelection_MIN = RESERVED;
const ControlLoopSelection ControlLoopSelection_MAX = JOINT_TORQUE_HIGH_VELOCITY;
const int ControlLoopSelection_ARRAYSIZE = ControlLoopSelection_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControlLoopSelection_descriptor();
inline const ::std::string& ControlLoopSelection_Name(ControlLoopSelection value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControlLoopSelection_descriptor(), value);
}
inline bool ControlLoopSelection_Parse(
    const ::std::string& name, ControlLoopSelection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlLoopSelection>(
    ControlLoopSelection_descriptor(), name, value);
}
enum CoggingFeedforwardMode {
  FEEDFORWARD_OFF = 0,
  FEEDFORWARD_ADAPTIVE = 1,
  FEEDFORWARD_CALIBRATED = 2,
  CoggingFeedforwardMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CoggingFeedforwardMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CoggingFeedforwardMode_IsValid(int value);
const CoggingFeedforwardMode CoggingFeedforwardMode_MIN = FEEDFORWARD_OFF;
const CoggingFeedforwardMode CoggingFeedforwardMode_MAX = FEEDFORWARD_CALIBRATED;
const int CoggingFeedforwardMode_ARRAYSIZE = CoggingFeedforwardMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CoggingFeedforwardMode_descriptor();
inline const ::std::string& CoggingFeedforwardMode_Name(CoggingFeedforwardMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CoggingFeedforwardMode_descriptor(), value);
}
inline bool CoggingFeedforwardMode_Parse(
    const ::std::string& name, CoggingFeedforwardMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CoggingFeedforwardMode>(
    CoggingFeedforwardMode_descriptor(), name, value);
}
enum SafetyIdentifierBankA {
  UNSPECIFIED_ACTUATOR_SAFETY_IDENTIFIER_BANK_A = 0,
  FOLLOWING_ERROR = 1,
  MAXIMUM_VELOCITY = 2,
  JOINT_LIMIT_HIGH = 4,
  JOINT_LIMIT_LOW = 8,
  STRAIN_GAUGE_MISMATCH = 16,
  MAXIMUM_TORQUE = 32,
  UNRELIABLE_ABSOLUTE_POSITION = 64,
  MAGNETIC_POSITION = 128,
  HALL_POSITION = 256,
  HALL_SEQUENCE = 512,
  INPUT_ENCODER_HALL_MISMATCH = 1024,
  INPUT_ENCODER_INDEX_MISMATCH = 2048,
  INPUT_ENCODER_MAGNETIC_MISMATCH = 4096,
  MAXIMUM_MOTOR_CURRENT = 8192,
  MOTOR_CURRENT_MISMATCH = 16384,
  MAXIMUM_VOLTAGE = 32768,
  MINIMUM_VOLTAGE = 65536,
  MAXIMUM_MOTOR_TEMPERATURE = 131072,
  MAXIMUM_CORE_TEMPERATURE = 262144,
  NON_VOLATILE_MEMORY_CORRUPTED = 524288,
  MOTOR_DRIVER_FAULT = 1048576,
  EMERGENCY_LINE_ASSERTED = 2097152,
  COMMUNICATION_TICK_LOST = 4194304,
  WATCHDOG_TRIGGERED = 8388608,
  UNRELIABLE_CAPACITIVE_SENSOR = 16777216,
  UNEXPECTED_GEAR_RATIO = 33554432,
  HALL_MAGNETIC_MISMATCH = 67108864,
  SafetyIdentifierBankA_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SafetyIdentifierBankA_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SafetyIdentifierBankA_IsValid(int value);
const SafetyIdentifierBankA SafetyIdentifierBankA_MIN = UNSPECIFIED_ACTUATOR_SAFETY_IDENTIFIER_BANK_A;
const SafetyIdentifierBankA SafetyIdentifierBankA_MAX = HALL_MAGNETIC_MISMATCH;
const int SafetyIdentifierBankA_ARRAYSIZE = SafetyIdentifierBankA_MAX + 1;

const ::google::protobuf::EnumDescriptor* SafetyIdentifierBankA_descriptor();
inline const ::std::string& SafetyIdentifierBankA_Name(SafetyIdentifierBankA value) {
  return ::google::protobuf::internal::NameOfEnum(
    SafetyIdentifierBankA_descriptor(), value);
}
inline bool SafetyIdentifierBankA_Parse(
    const ::std::string& name, SafetyIdentifierBankA* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SafetyIdentifierBankA>(
    SafetyIdentifierBankA_descriptor(), name, value);
}
enum CustomDataIndex {
  NO_CUSTOM_DATA_SELECTED = 0,
  UINT32_TEST_RAMP = 1,
  UINT32_MOTOR_ENCODER_RAW = 2,
  UINT32_JOINT_ENCODER_RAW = 3,
  FLOAT_TEMPERATURE_PHASE_0 = 4,
  FLOAT_TEMPERATURE_PHASE_1 = 5,
  FLOAT_TEMPERATURE_PHASE_2 = 6,
  INT32_TORQUE_SENSOR_RAW_0 = 7,
  INT32_TORQUE_SENSOR_RAW_1 = 8,
  INT32_TORQUE_SENSOR_RAW_2 = 9,
  INT32_TORQUE_SENSOR_RAW_3 = 10,
  FLOAT_TORQUE_SENSOR_0 = 11,
  FLOAT_TORQUE_SENSOR_1 = 12,
  FLOAT_TORQUE_SENSOR_2 = 13,
  FLOAT_TORQUE_SENSOR_3 = 14,
  UINT32_MOTOR_ENCODER_RAW_LATCH_ON_INDEX_RISING = 15,
  UINT32_JOINT_ENCODER_RAW_LATCH_ON_INDEX_RISING = 16,
  UINT32_ABSOLUTE_POSITION_SENSOR_RAW = 17,
  FLOAT_ABSOLUTE_POSITION_SENSOR = 18,
  FLOAT_CONTROL_POSITION_JOINT_REQUESTED = 19,
  UINT32_JIG_FLAGS = 20,
  UINT32_TICK_MOTOR_CONTROL = 21,
  UINT32_TICK_JOINT_CONTROL = 22,
  UINT32_INDEX_TICK_MOTOR_CONTROL = 23,
  UINT32_INDEX_TICK_JOINT_CONTROL = 24,
  FLOAT_ACCELERATION_X = 25,
  FLOAT_ACCELERATION_Y = 26,
  FLOAT_ACCELERATION_Z = 27,
  FLOAT_ANGULAR_RATE_X = 28,
  FLOAT_ANGULAR_RATE_Y = 29,
  FLOAT_ANGULAR_RATE_Z = 30,
  FLOAT_POSITION_MOTOR_CMD = 31,
  FLOAT_VELOCITY_MOTOR_CMD = 32,
  FLOAT_POSITION_MOTOR = 33,
  FLOAT_VELOCITY_MOTOR = 34,
  UINT32_COMMUNICATIONS_JITTER = 35,
  FLOAT_TORQUE_AVERAGE = 36,
  FLOAT_CURRENT_MOTOR = 37,
  FLOAT_VOLTAGE_DIGITAL = 38,
  FLOAT_TEMPERATURE_MOTOR_CELSIUS = 39,
  FLOAT_TEMPERATURE_CORE_CELSIUS = 40,
  UINT32_FAULT_A = 41,
  UINT32_FAULT_B = 42,
  UINT32_WARNING_A = 43,
  UINT32_WARNING_B = 44,
  FLOAT_POSITION_FROM_HALLS = 45,
  FLOAT_PHASE_CURRENT_0 = 46,
  FLOAT_PHASE_CURRENT_1 = 47,
  FLOAT_PHASE_CURRENT_2 = 48,
  FLOAT_PHASE_PWM_0 = 49,
  FLOAT_PHASE_PWM_1 = 50,
  FLOAT_PHASE_PWM_2 = 51,
  FLOAT_MOTOR_ELECTRICAL_ANGLE = 52,
  FLOAT_CURRENT_MOTOR_CMD = 53,
  FLOAT_TORQUE_JOINT_CMD = 54,
  FLOAT_POSITION_UNWRAPPED = 55,
  UINT32_HALL_SENSOR_0 = 56,
  UINT32_HALL_SENSOR_1 = 57,
  UINT32_HALL_SENSOR_2 = 58,
  INT32_HALL_SENSOR_SCALED_0 = 59,
  INT32_HALL_SENSOR_SCALED_1 = 60,
  INT32_HALL_SENSOR_SCALED_2 = 61,
  FLOAT_COGGING_COEFFICIENT_A_0 = 62,
  FLOAT_COGGING_COEFFICIENT_A_1 = 63,
  FLOAT_COGGING_COEFFICIENT_A_2 = 64,
  FLOAT_COGGING_COEFFICIENT_A_3 = 65,
  FLOAT_COGGING_COEFFICIENT_A_4 = 66,
  FLOAT_COGGING_COEFFICIENT_A_5 = 67,
  FLOAT_COGGING_COEFFICIENT_A_6 = 68,
  FLOAT_COGGING_COEFFICIENT_A_7 = 69,
  FLOAT_COGGING_COEFFICIENT_A_8 = 70,
  FLOAT_COGGING_COEFFICIENT_A_9 = 71,
  FLOAT_COGGING_COEFFICIENT_A_10 = 72,
  FLOAT_COGGING_COEFFICIENT_A_11 = 73,
  FLOAT_COGGING_COEFFICIENT_A_12 = 74,
  FLOAT_COGGING_COEFFICIENT_A_13 = 75,
  FLOAT_COGGING_COEFFICIENT_A_14 = 76,
  FLOAT_COGGING_COEFFICIENT_A_15 = 77,
  FLOAT_COGGING_COEFFICIENT_B_0 = 78,
  FLOAT_COGGING_COEFFICIENT_B_1 = 79,
  FLOAT_COGGING_COEFFICIENT_B_2 = 80,
  FLOAT_COGGING_COEFFICIENT_B_3 = 81,
  FLOAT_COGGING_COEFFICIENT_B_4 = 82,
  FLOAT_COGGING_COEFFICIENT_B_5 = 83,
  FLOAT_COGGING_COEFFICIENT_B_6 = 84,
  FLOAT_COGGING_COEFFICIENT_B_7 = 85,
  FLOAT_COGGING_COEFFICIENT_B_8 = 86,
  FLOAT_COGGING_COEFFICIENT_B_9 = 87,
  FLOAT_COGGING_COEFFICIENT_B_10 = 88,
  FLOAT_COGGING_COEFFICIENT_B_11 = 89,
  FLOAT_COGGING_COEFFICIENT_B_12 = 90,
  FLOAT_COGGING_COEFFICIENT_B_13 = 91,
  FLOAT_COGGING_COEFFICIENT_B_14 = 92,
  FLOAT_COGGING_COEFFICIENT_B_15 = 93,
  FLOAT_CURRENT_COGGING_FEEDFORWARD = 94,
  CustomDataIndex_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CustomDataIndex_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CustomDataIndex_IsValid(int value);
const CustomDataIndex CustomDataIndex_MIN = NO_CUSTOM_DATA_SELECTED;
const CustomDataIndex CustomDataIndex_MAX = FLOAT_CURRENT_COGGING_FEEDFORWARD;
const int CustomDataIndex_ARRAYSIZE = CustomDataIndex_MAX + 1;

const ::google::protobuf::EnumDescriptor* CustomDataIndex_descriptor();
inline const ::std::string& CustomDataIndex_Name(CustomDataIndex value) {
  return ::google::protobuf::internal::NameOfEnum(
    CustomDataIndex_descriptor(), value);
}
inline bool CustomDataIndex_Parse(
    const ::std::string& name, CustomDataIndex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CustomDataIndex>(
    CustomDataIndex_descriptor(), name, value);
}
// ===================================================================

class AxisPosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.AxisPosition) */ {
 public:
  AxisPosition();
  virtual ~AxisPosition();

  AxisPosition(const AxisPosition& from);

  inline AxisPosition& operator=(const AxisPosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AxisPosition(AxisPosition&& from) noexcept
    : AxisPosition() {
    *this = ::std::move(from);
  }

  inline AxisPosition& operator=(AxisPosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AxisPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AxisPosition* internal_default_instance() {
    return reinterpret_cast<const AxisPosition*>(
               &_AxisPosition_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(AxisPosition* other);
  friend void swap(AxisPosition& a, AxisPosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AxisPosition* New() const PROTOBUF_FINAL { return New(NULL); }

  AxisPosition* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AxisPosition& from);
  void MergeFrom(const AxisPosition& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AxisPosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float position = 1;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  float position() const;
  void set_position(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.AxisPosition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float position_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsAxisPositionImpl();
};
// -------------------------------------------------------------------

class AxisOffsets : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.AxisOffsets) */ {
 public:
  AxisOffsets();
  virtual ~AxisOffsets();

  AxisOffsets(const AxisOffsets& from);

  inline AxisOffsets& operator=(const AxisOffsets& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AxisOffsets(AxisOffsets&& from) noexcept
    : AxisOffsets() {
    *this = ::std::move(from);
  }

  inline AxisOffsets& operator=(AxisOffsets&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AxisOffsets& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AxisOffsets* internal_default_instance() {
    return reinterpret_cast<const AxisOffsets*>(
               &_AxisOffsets_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AxisOffsets* other);
  friend void swap(AxisOffsets& a, AxisOffsets& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AxisOffsets* New() const PROTOBUF_FINAL { return New(NULL); }

  AxisOffsets* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AxisOffsets& from);
  void MergeFrom(const AxisOffsets& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AxisOffsets* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float absolute_offset = 1;
  void clear_absolute_offset();
  static const int kAbsoluteOffsetFieldNumber = 1;
  float absolute_offset() const;
  void set_absolute_offset(float value);

  // float relative_offset = 2;
  void clear_relative_offset();
  static const int kRelativeOffsetFieldNumber = 2;
  float relative_offset() const;
  void set_relative_offset(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.AxisOffsets)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float absolute_offset_;
  float relative_offset_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsAxisOffsetsImpl();
};
// -------------------------------------------------------------------

class TorqueCalibration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.TorqueCalibration) */ {
 public:
  TorqueCalibration();
  virtual ~TorqueCalibration();

  TorqueCalibration(const TorqueCalibration& from);

  inline TorqueCalibration& operator=(const TorqueCalibration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TorqueCalibration(TorqueCalibration&& from) noexcept
    : TorqueCalibration() {
    *this = ::std::move(from);
  }

  inline TorqueCalibration& operator=(TorqueCalibration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TorqueCalibration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TorqueCalibration* internal_default_instance() {
    return reinterpret_cast<const TorqueCalibration*>(
               &_TorqueCalibration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TorqueCalibration* other);
  friend void swap(TorqueCalibration& a, TorqueCalibration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TorqueCalibration* New() const PROTOBUF_FINAL { return New(NULL); }

  TorqueCalibration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TorqueCalibration& from);
  void MergeFrom(const TorqueCalibration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TorqueCalibration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float gain = 3;
  int gain_size() const;
  void clear_gain();
  static const int kGainFieldNumber = 3;
  float gain(int index) const;
  void set_gain(int index, float value);
  void add_gain(float value);
  const ::google::protobuf::RepeatedField< float >&
      gain() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_gain();

  // repeated float offset = 4;
  int offset_size() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  float offset(int index) const;
  void set_offset(int index, float value);
  void add_offset(float value);
  const ::google::protobuf::RepeatedField< float >&
      offset() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_offset();

  // float global_gain = 1;
  void clear_global_gain();
  static const int kGlobalGainFieldNumber = 1;
  float global_gain() const;
  void set_global_gain(float value);

  // float global_offset = 2;
  void clear_global_offset();
  static const int kGlobalOffsetFieldNumber = 2;
  float global_offset() const;
  void set_global_offset(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.TorqueCalibration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > gain_;
  mutable int _gain_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > offset_;
  mutable int _offset_cached_byte_size_;
  float global_gain_;
  float global_offset_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsTorqueCalibrationImpl();
};
// -------------------------------------------------------------------

class TorqueOffset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.TorqueOffset) */ {
 public:
  TorqueOffset();
  virtual ~TorqueOffset();

  TorqueOffset(const TorqueOffset& from);

  inline TorqueOffset& operator=(const TorqueOffset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TorqueOffset(TorqueOffset&& from) noexcept
    : TorqueOffset() {
    *this = ::std::move(from);
  }

  inline TorqueOffset& operator=(TorqueOffset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TorqueOffset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TorqueOffset* internal_default_instance() {
    return reinterpret_cast<const TorqueOffset*>(
               &_TorqueOffset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TorqueOffset* other);
  friend void swap(TorqueOffset& a, TorqueOffset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TorqueOffset* New() const PROTOBUF_FINAL { return New(NULL); }

  TorqueOffset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TorqueOffset& from);
  void MergeFrom(const TorqueOffset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TorqueOffset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float torque_offset = 1;
  void clear_torque_offset();
  static const int kTorqueOffsetFieldNumber = 1;
  float torque_offset() const;
  void set_torque_offset(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.TorqueOffset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float torque_offset_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsTorqueOffsetImpl();
};
// -------------------------------------------------------------------

class ControlModeInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.ControlModeInformation) */ {
 public:
  ControlModeInformation();
  virtual ~ControlModeInformation();

  ControlModeInformation(const ControlModeInformation& from);

  inline ControlModeInformation& operator=(const ControlModeInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlModeInformation(ControlModeInformation&& from) noexcept
    : ControlModeInformation() {
    *this = ::std::move(from);
  }

  inline ControlModeInformation& operator=(ControlModeInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlModeInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlModeInformation* internal_default_instance() {
    return reinterpret_cast<const ControlModeInformation*>(
               &_ControlModeInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ControlModeInformation* other);
  friend void swap(ControlModeInformation& a, ControlModeInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlModeInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  ControlModeInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControlModeInformation& from);
  void MergeFrom(const ControlModeInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControlModeInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.ActuatorConfig.ControlMode control_mode = 1;
  void clear_control_mode();
  static const int kControlModeFieldNumber = 1;
  ::Kinova::Api::ActuatorConfig::ControlMode control_mode() const;
  void set_control_mode(::Kinova::Api::ActuatorConfig::ControlMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.ControlModeInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int control_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsControlModeInformationImpl();
};
// -------------------------------------------------------------------

class ControlLoop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.ControlLoop) */ {
 public:
  ControlLoop();
  virtual ~ControlLoop();

  ControlLoop(const ControlLoop& from);

  inline ControlLoop& operator=(const ControlLoop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlLoop(ControlLoop&& from) noexcept
    : ControlLoop() {
    *this = ::std::move(from);
  }

  inline ControlLoop& operator=(ControlLoop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlLoop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlLoop* internal_default_instance() {
    return reinterpret_cast<const ControlLoop*>(
               &_ControlLoop_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ControlLoop* other);
  friend void swap(ControlLoop& a, ControlLoop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlLoop* New() const PROTOBUF_FINAL { return New(NULL); }

  ControlLoop* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControlLoop& from);
  void MergeFrom(const ControlLoop& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControlLoop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // fixed32 control_loop = 1;
  void clear_control_loop();
  static const int kControlLoopFieldNumber = 1;
  ::google::protobuf::uint32 control_loop() const;
  void set_control_loop(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.ControlLoop)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 control_loop_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsControlLoopImpl();
};
// -------------------------------------------------------------------

class LoopSelection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.LoopSelection) */ {
 public:
  LoopSelection();
  virtual ~LoopSelection();

  LoopSelection(const LoopSelection& from);

  inline LoopSelection& operator=(const LoopSelection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoopSelection(LoopSelection&& from) noexcept
    : LoopSelection() {
    *this = ::std::move(from);
  }

  inline LoopSelection& operator=(LoopSelection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoopSelection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoopSelection* internal_default_instance() {
    return reinterpret_cast<const LoopSelection*>(
               &_LoopSelection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(LoopSelection* other);
  friend void swap(LoopSelection& a, LoopSelection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoopSelection* New() const PROTOBUF_FINAL { return New(NULL); }

  LoopSelection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoopSelection& from);
  void MergeFrom(const LoopSelection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoopSelection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.ActuatorConfig.ControlLoopSelection loop_selection = 1;
  void clear_loop_selection();
  static const int kLoopSelectionFieldNumber = 1;
  ::Kinova::Api::ActuatorConfig::ControlLoopSelection loop_selection() const;
  void set_loop_selection(::Kinova::Api::ActuatorConfig::ControlLoopSelection value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.LoopSelection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int loop_selection_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsLoopSelectionImpl();
};
// -------------------------------------------------------------------

class VectorDriveParameters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.VectorDriveParameters) */ {
 public:
  VectorDriveParameters();
  virtual ~VectorDriveParameters();

  VectorDriveParameters(const VectorDriveParameters& from);

  inline VectorDriveParameters& operator=(const VectorDriveParameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VectorDriveParameters(VectorDriveParameters&& from) noexcept
    : VectorDriveParameters() {
    *this = ::std::move(from);
  }

  inline VectorDriveParameters& operator=(VectorDriveParameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VectorDriveParameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VectorDriveParameters* internal_default_instance() {
    return reinterpret_cast<const VectorDriveParameters*>(
               &_VectorDriveParameters_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(VectorDriveParameters* other);
  friend void swap(VectorDriveParameters& a, VectorDriveParameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VectorDriveParameters* New() const PROTOBUF_FINAL { return New(NULL); }

  VectorDriveParameters* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VectorDriveParameters& from);
  void MergeFrom(const VectorDriveParameters& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VectorDriveParameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float kpq = 1;
  void clear_kpq();
  static const int kKpqFieldNumber = 1;
  float kpq() const;
  void set_kpq(float value);

  // float kiq = 2;
  void clear_kiq();
  static const int kKiqFieldNumber = 2;
  float kiq() const;
  void set_kiq(float value);

  // float kpd = 3;
  void clear_kpd();
  static const int kKpdFieldNumber = 3;
  float kpd() const;
  void set_kpd(float value);

  // float kid = 4;
  void clear_kid();
  static const int kKidFieldNumber = 4;
  float kid() const;
  void set_kid(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.VectorDriveParameters)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float kpq_;
  float kiq_;
  float kpd_;
  float kid_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsVectorDriveParametersImpl();
};
// -------------------------------------------------------------------

class EncoderDerivativeParameters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.EncoderDerivativeParameters) */ {
 public:
  EncoderDerivativeParameters();
  virtual ~EncoderDerivativeParameters();

  EncoderDerivativeParameters(const EncoderDerivativeParameters& from);

  inline EncoderDerivativeParameters& operator=(const EncoderDerivativeParameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EncoderDerivativeParameters(EncoderDerivativeParameters&& from) noexcept
    : EncoderDerivativeParameters() {
    *this = ::std::move(from);
  }

  inline EncoderDerivativeParameters& operator=(EncoderDerivativeParameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EncoderDerivativeParameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EncoderDerivativeParameters* internal_default_instance() {
    return reinterpret_cast<const EncoderDerivativeParameters*>(
               &_EncoderDerivativeParameters_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(EncoderDerivativeParameters* other);
  friend void swap(EncoderDerivativeParameters& a, EncoderDerivativeParameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EncoderDerivativeParameters* New() const PROTOBUF_FINAL { return New(NULL); }

  EncoderDerivativeParameters* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EncoderDerivativeParameters& from);
  void MergeFrom(const EncoderDerivativeParameters& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EncoderDerivativeParameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 max_window_width = 1;
  void clear_max_window_width();
  static const int kMaxWindowWidthFieldNumber = 1;
  ::google::protobuf::uint32 max_window_width() const;
  void set_max_window_width(::google::protobuf::uint32 value);

  // float min_angle = 2;
  void clear_min_angle();
  static const int kMinAngleFieldNumber = 2;
  float min_angle() const;
  void set_min_angle(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.EncoderDerivativeParameters)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 max_window_width_;
  float min_angle_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsEncoderDerivativeParametersImpl();
};
// -------------------------------------------------------------------

class ControlLoopParameters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.ControlLoopParameters) */ {
 public:
  ControlLoopParameters();
  virtual ~ControlLoopParameters();

  ControlLoopParameters(const ControlLoopParameters& from);

  inline ControlLoopParameters& operator=(const ControlLoopParameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlLoopParameters(ControlLoopParameters&& from) noexcept
    : ControlLoopParameters() {
    *this = ::std::move(from);
  }

  inline ControlLoopParameters& operator=(ControlLoopParameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlLoopParameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlLoopParameters* internal_default_instance() {
    return reinterpret_cast<const ControlLoopParameters*>(
               &_ControlLoopParameters_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ControlLoopParameters* other);
  friend void swap(ControlLoopParameters& a, ControlLoopParameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlLoopParameters* New() const PROTOBUF_FINAL { return New(NULL); }

  ControlLoopParameters* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControlLoopParameters& from);
  void MergeFrom(const ControlLoopParameters& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControlLoopParameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float kAz = 4;
  int kaz_size() const;
  void clear_kaz();
  static const int kKAzFieldNumber = 4;
  float kaz(int index) const;
  void set_kaz(int index, float value);
  void add_kaz(float value);
  const ::google::protobuf::RepeatedField< float >&
      kaz() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_kaz();

  // repeated float kBz = 5;
  int kbz_size() const;
  void clear_kbz();
  static const int kKBzFieldNumber = 5;
  float kbz(int index) const;
  void set_kbz(int index, float value);
  void add_kbz(float value);
  const ::google::protobuf::RepeatedField< float >&
      kbz() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_kbz();

  // .Kinova.Api.ActuatorConfig.ControlLoopSelection loop_selection = 1;
  void clear_loop_selection();
  static const int kLoopSelectionFieldNumber = 1;
  ::Kinova::Api::ActuatorConfig::ControlLoopSelection loop_selection() const;
  void set_loop_selection(::Kinova::Api::ActuatorConfig::ControlLoopSelection value);

  // float error_saturation = 2;
  void clear_error_saturation();
  static const int kErrorSaturationFieldNumber = 2;
  float error_saturation() const;
  void set_error_saturation(float value);

  // float output_saturation = 3;
  void clear_output_saturation();
  static const int kOutputSaturationFieldNumber = 3;
  float output_saturation() const;
  void set_output_saturation(float value);

  // float error_dead_band = 6;
  void clear_error_dead_band();
  static const int kErrorDeadBandFieldNumber = 6;
  float error_dead_band() const;
  void set_error_dead_band(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.ControlLoopParameters)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > kaz_;
  mutable int _kaz_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > kbz_;
  mutable int _kbz_cached_byte_size_;
  int loop_selection_;
  float error_saturation_;
  float output_saturation_;
  float error_dead_band_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsControlLoopParametersImpl();
};
// -------------------------------------------------------------------

class FrequencyResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.FrequencyResponse) */ {
 public:
  FrequencyResponse();
  virtual ~FrequencyResponse();

  FrequencyResponse(const FrequencyResponse& from);

  inline FrequencyResponse& operator=(const FrequencyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FrequencyResponse(FrequencyResponse&& from) noexcept
    : FrequencyResponse() {
    *this = ::std::move(from);
  }

  inline FrequencyResponse& operator=(FrequencyResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrequencyResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrequencyResponse* internal_default_instance() {
    return reinterpret_cast<const FrequencyResponse*>(
               &_FrequencyResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(FrequencyResponse* other);
  friend void swap(FrequencyResponse& a, FrequencyResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FrequencyResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  FrequencyResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FrequencyResponse& from);
  void MergeFrom(const FrequencyResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FrequencyResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.ActuatorConfig.ControlLoopSelection loop_selection = 1;
  void clear_loop_selection();
  static const int kLoopSelectionFieldNumber = 1;
  ::Kinova::Api::ActuatorConfig::ControlLoopSelection loop_selection() const;
  void set_loop_selection(::Kinova::Api::ActuatorConfig::ControlLoopSelection value);

  // float min_frequency = 2;
  void clear_min_frequency();
  static const int kMinFrequencyFieldNumber = 2;
  float min_frequency() const;
  void set_min_frequency(float value);

  // float max_frequency = 3;
  void clear_max_frequency();
  static const int kMaxFrequencyFieldNumber = 3;
  float max_frequency() const;
  void set_max_frequency(float value);

  // float amplitude = 4;
  void clear_amplitude();
  static const int kAmplitudeFieldNumber = 4;
  float amplitude() const;
  void set_amplitude(float value);

  // float duration = 5;
  void clear_duration();
  static const int kDurationFieldNumber = 5;
  float duration() const;
  void set_duration(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.FrequencyResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int loop_selection_;
  float min_frequency_;
  float max_frequency_;
  float amplitude_;
  float duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsFrequencyResponseImpl();
};
// -------------------------------------------------------------------

class StepResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.StepResponse) */ {
 public:
  StepResponse();
  virtual ~StepResponse();

  StepResponse(const StepResponse& from);

  inline StepResponse& operator=(const StepResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StepResponse(StepResponse&& from) noexcept
    : StepResponse() {
    *this = ::std::move(from);
  }

  inline StepResponse& operator=(StepResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StepResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StepResponse* internal_default_instance() {
    return reinterpret_cast<const StepResponse*>(
               &_StepResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(StepResponse* other);
  friend void swap(StepResponse& a, StepResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StepResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  StepResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StepResponse& from);
  void MergeFrom(const StepResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StepResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.ActuatorConfig.ControlLoopSelection loop_selection = 1;
  void clear_loop_selection();
  static const int kLoopSelectionFieldNumber = 1;
  ::Kinova::Api::ActuatorConfig::ControlLoopSelection loop_selection() const;
  void set_loop_selection(::Kinova::Api::ActuatorConfig::ControlLoopSelection value);

  // float amplitude = 2;
  void clear_amplitude();
  static const int kAmplitudeFieldNumber = 2;
  float amplitude() const;
  void set_amplitude(float value);

  // float step_delay = 3;
  void clear_step_delay();
  static const int kStepDelayFieldNumber = 3;
  float step_delay() const;
  void set_step_delay(float value);

  // float duration = 4;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  float duration() const;
  void set_duration(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.StepResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int loop_selection_;
  float amplitude_;
  float step_delay_;
  float duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsStepResponseImpl();
};
// -------------------------------------------------------------------

class RampResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.RampResponse) */ {
 public:
  RampResponse();
  virtual ~RampResponse();

  RampResponse(const RampResponse& from);

  inline RampResponse& operator=(const RampResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RampResponse(RampResponse&& from) noexcept
    : RampResponse() {
    *this = ::std::move(from);
  }

  inline RampResponse& operator=(RampResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RampResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RampResponse* internal_default_instance() {
    return reinterpret_cast<const RampResponse*>(
               &_RampResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(RampResponse* other);
  friend void swap(RampResponse& a, RampResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RampResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RampResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RampResponse& from);
  void MergeFrom(const RampResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RampResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.ActuatorConfig.ControlLoopSelection loop_selection = 1;
  void clear_loop_selection();
  static const int kLoopSelectionFieldNumber = 1;
  ::Kinova::Api::ActuatorConfig::ControlLoopSelection loop_selection() const;
  void set_loop_selection(::Kinova::Api::ActuatorConfig::ControlLoopSelection value);

  // float slope = 2;
  void clear_slope();
  static const int kSlopeFieldNumber = 2;
  float slope() const;
  void set_slope(float value);

  // float ramp_delay = 3;
  void clear_ramp_delay();
  static const int kRampDelayFieldNumber = 3;
  float ramp_delay() const;
  void set_ramp_delay(float value);

  // float duration = 4;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  float duration() const;
  void set_duration(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.RampResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int loop_selection_;
  float slope_;
  float ramp_delay_;
  float duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsRampResponseImpl();
};
// -------------------------------------------------------------------

class CustomDataSelection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.CustomDataSelection) */ {
 public:
  CustomDataSelection();
  virtual ~CustomDataSelection();

  CustomDataSelection(const CustomDataSelection& from);

  inline CustomDataSelection& operator=(const CustomDataSelection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomDataSelection(CustomDataSelection&& from) noexcept
    : CustomDataSelection() {
    *this = ::std::move(from);
  }

  inline CustomDataSelection& operator=(CustomDataSelection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomDataSelection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomDataSelection* internal_default_instance() {
    return reinterpret_cast<const CustomDataSelection*>(
               &_CustomDataSelection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(CustomDataSelection* other);
  friend void swap(CustomDataSelection& a, CustomDataSelection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomDataSelection* New() const PROTOBUF_FINAL { return New(NULL); }

  CustomDataSelection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CustomDataSelection& from);
  void MergeFrom(const CustomDataSelection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CustomDataSelection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Kinova.Api.ActuatorConfig.CustomDataIndex channel = 1;
  int channel_size() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::Kinova::Api::ActuatorConfig::CustomDataIndex channel(int index) const;
  void set_channel(int index, ::Kinova::Api::ActuatorConfig::CustomDataIndex value);
  void add_channel(::Kinova::Api::ActuatorConfig::CustomDataIndex value);
  const ::google::protobuf::RepeatedField<int>& channel() const;
  ::google::protobuf::RepeatedField<int>* mutable_channel();

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.CustomDataSelection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField<int> channel_;
  mutable int _channel_cached_byte_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsCustomDataSelectionImpl();
};
// -------------------------------------------------------------------

class CommandModeInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.CommandModeInformation) */ {
 public:
  CommandModeInformation();
  virtual ~CommandModeInformation();

  CommandModeInformation(const CommandModeInformation& from);

  inline CommandModeInformation& operator=(const CommandModeInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommandModeInformation(CommandModeInformation&& from) noexcept
    : CommandModeInformation() {
    *this = ::std::move(from);
  }

  inline CommandModeInformation& operator=(CommandModeInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandModeInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandModeInformation* internal_default_instance() {
    return reinterpret_cast<const CommandModeInformation*>(
               &_CommandModeInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(CommandModeInformation* other);
  friend void swap(CommandModeInformation& a, CommandModeInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommandModeInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  CommandModeInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CommandModeInformation& from);
  void MergeFrom(const CommandModeInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CommandModeInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.ActuatorConfig.CommandMode command_mode = 1;
  void clear_command_mode();
  static const int kCommandModeFieldNumber = 1;
  ::Kinova::Api::ActuatorConfig::CommandMode command_mode() const;
  void set_command_mode(::Kinova::Api::ActuatorConfig::CommandMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.CommandModeInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int command_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsCommandModeInformationImpl();
};
// -------------------------------------------------------------------

class Servoing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.Servoing) */ {
 public:
  Servoing();
  virtual ~Servoing();

  Servoing(const Servoing& from);

  inline Servoing& operator=(const Servoing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Servoing(Servoing&& from) noexcept
    : Servoing() {
    *this = ::std::move(from);
  }

  inline Servoing& operator=(Servoing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Servoing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Servoing* internal_default_instance() {
    return reinterpret_cast<const Servoing*>(
               &_Servoing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Servoing* other);
  friend void swap(Servoing& a, Servoing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Servoing* New() const PROTOBUF_FINAL { return New(NULL); }

  Servoing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Servoing& from);
  void MergeFrom(const Servoing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Servoing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool enabled = 1;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.Servoing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool enabled_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsServoingImpl();
};
// -------------------------------------------------------------------

class PositionCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.PositionCommand) */ {
 public:
  PositionCommand();
  virtual ~PositionCommand();

  PositionCommand(const PositionCommand& from);

  inline PositionCommand& operator=(const PositionCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PositionCommand(PositionCommand&& from) noexcept
    : PositionCommand() {
    *this = ::std::move(from);
  }

  inline PositionCommand& operator=(PositionCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PositionCommand* internal_default_instance() {
    return reinterpret_cast<const PositionCommand*>(
               &_PositionCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(PositionCommand* other);
  friend void swap(PositionCommand& a, PositionCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PositionCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  PositionCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PositionCommand& from);
  void MergeFrom(const PositionCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PositionCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float position = 1;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  float position() const;
  void set_position(float value);

  // float velocity = 2;
  void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  float velocity() const;
  void set_velocity(float value);

  // float acceleration = 3;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 3;
  float acceleration() const;
  void set_acceleration(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.PositionCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float position_;
  float velocity_;
  float acceleration_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsPositionCommandImpl();
};
// -------------------------------------------------------------------

class CoggingFeedforwardModeInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.ActuatorConfig.CoggingFeedforwardModeInformation) */ {
 public:
  CoggingFeedforwardModeInformation();
  virtual ~CoggingFeedforwardModeInformation();

  CoggingFeedforwardModeInformation(const CoggingFeedforwardModeInformation& from);

  inline CoggingFeedforwardModeInformation& operator=(const CoggingFeedforwardModeInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CoggingFeedforwardModeInformation(CoggingFeedforwardModeInformation&& from) noexcept
    : CoggingFeedforwardModeInformation() {
    *this = ::std::move(from);
  }

  inline CoggingFeedforwardModeInformation& operator=(CoggingFeedforwardModeInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CoggingFeedforwardModeInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoggingFeedforwardModeInformation* internal_default_instance() {
    return reinterpret_cast<const CoggingFeedforwardModeInformation*>(
               &_CoggingFeedforwardModeInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(CoggingFeedforwardModeInformation* other);
  friend void swap(CoggingFeedforwardModeInformation& a, CoggingFeedforwardModeInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CoggingFeedforwardModeInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  CoggingFeedforwardModeInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CoggingFeedforwardModeInformation& from);
  void MergeFrom(const CoggingFeedforwardModeInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CoggingFeedforwardModeInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.ActuatorConfig.CoggingFeedforwardMode cogging_feedforward_mode = 1;
  void clear_cogging_feedforward_mode();
  static const int kCoggingFeedforwardModeFieldNumber = 1;
  ::Kinova::Api::ActuatorConfig::CoggingFeedforwardMode cogging_feedforward_mode() const;
  void set_cogging_feedforward_mode(::Kinova::Api::ActuatorConfig::CoggingFeedforwardMode value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.ActuatorConfig.CoggingFeedforwardModeInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int cogging_feedforward_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_ActuatorConfig_2eproto::TableStruct;
  friend void ::protobuf_ActuatorConfig_2eproto::InitDefaultsCoggingFeedforwardModeInformationImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AxisPosition

// float position = 1;
inline void AxisPosition::clear_position() {
  position_ = 0;
}
inline float AxisPosition::position() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.AxisPosition.position)
  return position_;
}
inline void AxisPosition::set_position(float value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.AxisPosition.position)
}

// -------------------------------------------------------------------

// AxisOffsets

// float absolute_offset = 1;
inline void AxisOffsets::clear_absolute_offset() {
  absolute_offset_ = 0;
}
inline float AxisOffsets::absolute_offset() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.AxisOffsets.absolute_offset)
  return absolute_offset_;
}
inline void AxisOffsets::set_absolute_offset(float value) {
  
  absolute_offset_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.AxisOffsets.absolute_offset)
}

// float relative_offset = 2;
inline void AxisOffsets::clear_relative_offset() {
  relative_offset_ = 0;
}
inline float AxisOffsets::relative_offset() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.AxisOffsets.relative_offset)
  return relative_offset_;
}
inline void AxisOffsets::set_relative_offset(float value) {
  
  relative_offset_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.AxisOffsets.relative_offset)
}

// -------------------------------------------------------------------

// TorqueCalibration

// float global_gain = 1;
inline void TorqueCalibration::clear_global_gain() {
  global_gain_ = 0;
}
inline float TorqueCalibration::global_gain() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.TorqueCalibration.global_gain)
  return global_gain_;
}
inline void TorqueCalibration::set_global_gain(float value) {
  
  global_gain_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.TorqueCalibration.global_gain)
}

// float global_offset = 2;
inline void TorqueCalibration::clear_global_offset() {
  global_offset_ = 0;
}
inline float TorqueCalibration::global_offset() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.TorqueCalibration.global_offset)
  return global_offset_;
}
inline void TorqueCalibration::set_global_offset(float value) {
  
  global_offset_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.TorqueCalibration.global_offset)
}

// repeated float gain = 3;
inline int TorqueCalibration::gain_size() const {
  return gain_.size();
}
inline void TorqueCalibration::clear_gain() {
  gain_.Clear();
}
inline float TorqueCalibration::gain(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.TorqueCalibration.gain)
  return gain_.Get(index);
}
inline void TorqueCalibration::set_gain(int index, float value) {
  gain_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.TorqueCalibration.gain)
}
inline void TorqueCalibration::add_gain(float value) {
  gain_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.ActuatorConfig.TorqueCalibration.gain)
}
inline const ::google::protobuf::RepeatedField< float >&
TorqueCalibration::gain() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.ActuatorConfig.TorqueCalibration.gain)
  return gain_;
}
inline ::google::protobuf::RepeatedField< float >*
TorqueCalibration::mutable_gain() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.ActuatorConfig.TorqueCalibration.gain)
  return &gain_;
}

// repeated float offset = 4;
inline int TorqueCalibration::offset_size() const {
  return offset_.size();
}
inline void TorqueCalibration::clear_offset() {
  offset_.Clear();
}
inline float TorqueCalibration::offset(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.TorqueCalibration.offset)
  return offset_.Get(index);
}
inline void TorqueCalibration::set_offset(int index, float value) {
  offset_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.TorqueCalibration.offset)
}
inline void TorqueCalibration::add_offset(float value) {
  offset_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.ActuatorConfig.TorqueCalibration.offset)
}
inline const ::google::protobuf::RepeatedField< float >&
TorqueCalibration::offset() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.ActuatorConfig.TorqueCalibration.offset)
  return offset_;
}
inline ::google::protobuf::RepeatedField< float >*
TorqueCalibration::mutable_offset() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.ActuatorConfig.TorqueCalibration.offset)
  return &offset_;
}

// -------------------------------------------------------------------

// TorqueOffset

// float torque_offset = 1;
inline void TorqueOffset::clear_torque_offset() {
  torque_offset_ = 0;
}
inline float TorqueOffset::torque_offset() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.TorqueOffset.torque_offset)
  return torque_offset_;
}
inline void TorqueOffset::set_torque_offset(float value) {
  
  torque_offset_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.TorqueOffset.torque_offset)
}

// -------------------------------------------------------------------

// ControlModeInformation

// .Kinova.Api.ActuatorConfig.ControlMode control_mode = 1;
inline void ControlModeInformation::clear_control_mode() {
  control_mode_ = 0;
}
inline ::Kinova::Api::ActuatorConfig::ControlMode ControlModeInformation::control_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.ControlModeInformation.control_mode)
  return static_cast< ::Kinova::Api::ActuatorConfig::ControlMode >(control_mode_);
}
inline void ControlModeInformation::set_control_mode(::Kinova::Api::ActuatorConfig::ControlMode value) {
  
  control_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.ControlModeInformation.control_mode)
}

// -------------------------------------------------------------------

// ControlLoop

// fixed32 control_loop = 1;
inline void ControlLoop::clear_control_loop() {
  control_loop_ = 0u;
}
inline ::google::protobuf::uint32 ControlLoop::control_loop() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.ControlLoop.control_loop)
  return control_loop_;
}
inline void ControlLoop::set_control_loop(::google::protobuf::uint32 value) {
  
  control_loop_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.ControlLoop.control_loop)
}

// -------------------------------------------------------------------

// LoopSelection

// .Kinova.Api.ActuatorConfig.ControlLoopSelection loop_selection = 1;
inline void LoopSelection::clear_loop_selection() {
  loop_selection_ = 0;
}
inline ::Kinova::Api::ActuatorConfig::ControlLoopSelection LoopSelection::loop_selection() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.LoopSelection.loop_selection)
  return static_cast< ::Kinova::Api::ActuatorConfig::ControlLoopSelection >(loop_selection_);
}
inline void LoopSelection::set_loop_selection(::Kinova::Api::ActuatorConfig::ControlLoopSelection value) {
  
  loop_selection_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.LoopSelection.loop_selection)
}

// -------------------------------------------------------------------

// VectorDriveParameters

// float kpq = 1;
inline void VectorDriveParameters::clear_kpq() {
  kpq_ = 0;
}
inline float VectorDriveParameters::kpq() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.VectorDriveParameters.kpq)
  return kpq_;
}
inline void VectorDriveParameters::set_kpq(float value) {
  
  kpq_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.VectorDriveParameters.kpq)
}

// float kiq = 2;
inline void VectorDriveParameters::clear_kiq() {
  kiq_ = 0;
}
inline float VectorDriveParameters::kiq() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.VectorDriveParameters.kiq)
  return kiq_;
}
inline void VectorDriveParameters::set_kiq(float value) {
  
  kiq_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.VectorDriveParameters.kiq)
}

// float kpd = 3;
inline void VectorDriveParameters::clear_kpd() {
  kpd_ = 0;
}
inline float VectorDriveParameters::kpd() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.VectorDriveParameters.kpd)
  return kpd_;
}
inline void VectorDriveParameters::set_kpd(float value) {
  
  kpd_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.VectorDriveParameters.kpd)
}

// float kid = 4;
inline void VectorDriveParameters::clear_kid() {
  kid_ = 0;
}
inline float VectorDriveParameters::kid() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.VectorDriveParameters.kid)
  return kid_;
}
inline void VectorDriveParameters::set_kid(float value) {
  
  kid_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.VectorDriveParameters.kid)
}

// -------------------------------------------------------------------

// EncoderDerivativeParameters

// uint32 max_window_width = 1;
inline void EncoderDerivativeParameters::clear_max_window_width() {
  max_window_width_ = 0u;
}
inline ::google::protobuf::uint32 EncoderDerivativeParameters::max_window_width() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.EncoderDerivativeParameters.max_window_width)
  return max_window_width_;
}
inline void EncoderDerivativeParameters::set_max_window_width(::google::protobuf::uint32 value) {
  
  max_window_width_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.EncoderDerivativeParameters.max_window_width)
}

// float min_angle = 2;
inline void EncoderDerivativeParameters::clear_min_angle() {
  min_angle_ = 0;
}
inline float EncoderDerivativeParameters::min_angle() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.EncoderDerivativeParameters.min_angle)
  return min_angle_;
}
inline void EncoderDerivativeParameters::set_min_angle(float value) {
  
  min_angle_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.EncoderDerivativeParameters.min_angle)
}

// -------------------------------------------------------------------

// ControlLoopParameters

// .Kinova.Api.ActuatorConfig.ControlLoopSelection loop_selection = 1;
inline void ControlLoopParameters::clear_loop_selection() {
  loop_selection_ = 0;
}
inline ::Kinova::Api::ActuatorConfig::ControlLoopSelection ControlLoopParameters::loop_selection() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.ControlLoopParameters.loop_selection)
  return static_cast< ::Kinova::Api::ActuatorConfig::ControlLoopSelection >(loop_selection_);
}
inline void ControlLoopParameters::set_loop_selection(::Kinova::Api::ActuatorConfig::ControlLoopSelection value) {
  
  loop_selection_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.ControlLoopParameters.loop_selection)
}

// float error_saturation = 2;
inline void ControlLoopParameters::clear_error_saturation() {
  error_saturation_ = 0;
}
inline float ControlLoopParameters::error_saturation() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.ControlLoopParameters.error_saturation)
  return error_saturation_;
}
inline void ControlLoopParameters::set_error_saturation(float value) {
  
  error_saturation_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.ControlLoopParameters.error_saturation)
}

// float output_saturation = 3;
inline void ControlLoopParameters::clear_output_saturation() {
  output_saturation_ = 0;
}
inline float ControlLoopParameters::output_saturation() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.ControlLoopParameters.output_saturation)
  return output_saturation_;
}
inline void ControlLoopParameters::set_output_saturation(float value) {
  
  output_saturation_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.ControlLoopParameters.output_saturation)
}

// repeated float kAz = 4;
inline int ControlLoopParameters::kaz_size() const {
  return kaz_.size();
}
inline void ControlLoopParameters::clear_kaz() {
  kaz_.Clear();
}
inline float ControlLoopParameters::kaz(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.ControlLoopParameters.kAz)
  return kaz_.Get(index);
}
inline void ControlLoopParameters::set_kaz(int index, float value) {
  kaz_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.ControlLoopParameters.kAz)
}
inline void ControlLoopParameters::add_kaz(float value) {
  kaz_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.ActuatorConfig.ControlLoopParameters.kAz)
}
inline const ::google::protobuf::RepeatedField< float >&
ControlLoopParameters::kaz() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.ActuatorConfig.ControlLoopParameters.kAz)
  return kaz_;
}
inline ::google::protobuf::RepeatedField< float >*
ControlLoopParameters::mutable_kaz() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.ActuatorConfig.ControlLoopParameters.kAz)
  return &kaz_;
}

// repeated float kBz = 5;
inline int ControlLoopParameters::kbz_size() const {
  return kbz_.size();
}
inline void ControlLoopParameters::clear_kbz() {
  kbz_.Clear();
}
inline float ControlLoopParameters::kbz(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.ControlLoopParameters.kBz)
  return kbz_.Get(index);
}
inline void ControlLoopParameters::set_kbz(int index, float value) {
  kbz_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.ControlLoopParameters.kBz)
}
inline void ControlLoopParameters::add_kbz(float value) {
  kbz_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.ActuatorConfig.ControlLoopParameters.kBz)
}
inline const ::google::protobuf::RepeatedField< float >&
ControlLoopParameters::kbz() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.ActuatorConfig.ControlLoopParameters.kBz)
  return kbz_;
}
inline ::google::protobuf::RepeatedField< float >*
ControlLoopParameters::mutable_kbz() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.ActuatorConfig.ControlLoopParameters.kBz)
  return &kbz_;
}

// float error_dead_band = 6;
inline void ControlLoopParameters::clear_error_dead_band() {
  error_dead_band_ = 0;
}
inline float ControlLoopParameters::error_dead_band() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.ControlLoopParameters.error_dead_band)
  return error_dead_band_;
}
inline void ControlLoopParameters::set_error_dead_band(float value) {
  
  error_dead_band_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.ControlLoopParameters.error_dead_band)
}

// -------------------------------------------------------------------

// FrequencyResponse

// .Kinova.Api.ActuatorConfig.ControlLoopSelection loop_selection = 1;
inline void FrequencyResponse::clear_loop_selection() {
  loop_selection_ = 0;
}
inline ::Kinova::Api::ActuatorConfig::ControlLoopSelection FrequencyResponse::loop_selection() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.FrequencyResponse.loop_selection)
  return static_cast< ::Kinova::Api::ActuatorConfig::ControlLoopSelection >(loop_selection_);
}
inline void FrequencyResponse::set_loop_selection(::Kinova::Api::ActuatorConfig::ControlLoopSelection value) {
  
  loop_selection_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.FrequencyResponse.loop_selection)
}

// float min_frequency = 2;
inline void FrequencyResponse::clear_min_frequency() {
  min_frequency_ = 0;
}
inline float FrequencyResponse::min_frequency() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.FrequencyResponse.min_frequency)
  return min_frequency_;
}
inline void FrequencyResponse::set_min_frequency(float value) {
  
  min_frequency_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.FrequencyResponse.min_frequency)
}

// float max_frequency = 3;
inline void FrequencyResponse::clear_max_frequency() {
  max_frequency_ = 0;
}
inline float FrequencyResponse::max_frequency() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.FrequencyResponse.max_frequency)
  return max_frequency_;
}
inline void FrequencyResponse::set_max_frequency(float value) {
  
  max_frequency_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.FrequencyResponse.max_frequency)
}

// float amplitude = 4;
inline void FrequencyResponse::clear_amplitude() {
  amplitude_ = 0;
}
inline float FrequencyResponse::amplitude() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.FrequencyResponse.amplitude)
  return amplitude_;
}
inline void FrequencyResponse::set_amplitude(float value) {
  
  amplitude_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.FrequencyResponse.amplitude)
}

// float duration = 5;
inline void FrequencyResponse::clear_duration() {
  duration_ = 0;
}
inline float FrequencyResponse::duration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.FrequencyResponse.duration)
  return duration_;
}
inline void FrequencyResponse::set_duration(float value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.FrequencyResponse.duration)
}

// -------------------------------------------------------------------

// StepResponse

// .Kinova.Api.ActuatorConfig.ControlLoopSelection loop_selection = 1;
inline void StepResponse::clear_loop_selection() {
  loop_selection_ = 0;
}
inline ::Kinova::Api::ActuatorConfig::ControlLoopSelection StepResponse::loop_selection() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.StepResponse.loop_selection)
  return static_cast< ::Kinova::Api::ActuatorConfig::ControlLoopSelection >(loop_selection_);
}
inline void StepResponse::set_loop_selection(::Kinova::Api::ActuatorConfig::ControlLoopSelection value) {
  
  loop_selection_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.StepResponse.loop_selection)
}

// float amplitude = 2;
inline void StepResponse::clear_amplitude() {
  amplitude_ = 0;
}
inline float StepResponse::amplitude() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.StepResponse.amplitude)
  return amplitude_;
}
inline void StepResponse::set_amplitude(float value) {
  
  amplitude_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.StepResponse.amplitude)
}

// float step_delay = 3;
inline void StepResponse::clear_step_delay() {
  step_delay_ = 0;
}
inline float StepResponse::step_delay() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.StepResponse.step_delay)
  return step_delay_;
}
inline void StepResponse::set_step_delay(float value) {
  
  step_delay_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.StepResponse.step_delay)
}

// float duration = 4;
inline void StepResponse::clear_duration() {
  duration_ = 0;
}
inline float StepResponse::duration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.StepResponse.duration)
  return duration_;
}
inline void StepResponse::set_duration(float value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.StepResponse.duration)
}

// -------------------------------------------------------------------

// RampResponse

// .Kinova.Api.ActuatorConfig.ControlLoopSelection loop_selection = 1;
inline void RampResponse::clear_loop_selection() {
  loop_selection_ = 0;
}
inline ::Kinova::Api::ActuatorConfig::ControlLoopSelection RampResponse::loop_selection() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.RampResponse.loop_selection)
  return static_cast< ::Kinova::Api::ActuatorConfig::ControlLoopSelection >(loop_selection_);
}
inline void RampResponse::set_loop_selection(::Kinova::Api::ActuatorConfig::ControlLoopSelection value) {
  
  loop_selection_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.RampResponse.loop_selection)
}

// float slope = 2;
inline void RampResponse::clear_slope() {
  slope_ = 0;
}
inline float RampResponse::slope() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.RampResponse.slope)
  return slope_;
}
inline void RampResponse::set_slope(float value) {
  
  slope_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.RampResponse.slope)
}

// float ramp_delay = 3;
inline void RampResponse::clear_ramp_delay() {
  ramp_delay_ = 0;
}
inline float RampResponse::ramp_delay() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.RampResponse.ramp_delay)
  return ramp_delay_;
}
inline void RampResponse::set_ramp_delay(float value) {
  
  ramp_delay_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.RampResponse.ramp_delay)
}

// float duration = 4;
inline void RampResponse::clear_duration() {
  duration_ = 0;
}
inline float RampResponse::duration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.RampResponse.duration)
  return duration_;
}
inline void RampResponse::set_duration(float value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.RampResponse.duration)
}

// -------------------------------------------------------------------

// CustomDataSelection

// repeated .Kinova.Api.ActuatorConfig.CustomDataIndex channel = 1;
inline int CustomDataSelection::channel_size() const {
  return channel_.size();
}
inline void CustomDataSelection::clear_channel() {
  channel_.Clear();
}
inline ::Kinova::Api::ActuatorConfig::CustomDataIndex CustomDataSelection::channel(int index) const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.CustomDataSelection.channel)
  return static_cast< ::Kinova::Api::ActuatorConfig::CustomDataIndex >(channel_.Get(index));
}
inline void CustomDataSelection::set_channel(int index, ::Kinova::Api::ActuatorConfig::CustomDataIndex value) {
  channel_.Set(index, value);
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.CustomDataSelection.channel)
}
inline void CustomDataSelection::add_channel(::Kinova::Api::ActuatorConfig::CustomDataIndex value) {
  channel_.Add(value);
  // @@protoc_insertion_point(field_add:Kinova.Api.ActuatorConfig.CustomDataSelection.channel)
}
inline const ::google::protobuf::RepeatedField<int>&
CustomDataSelection::channel() const {
  // @@protoc_insertion_point(field_list:Kinova.Api.ActuatorConfig.CustomDataSelection.channel)
  return channel_;
}
inline ::google::protobuf::RepeatedField<int>*
CustomDataSelection::mutable_channel() {
  // @@protoc_insertion_point(field_mutable_list:Kinova.Api.ActuatorConfig.CustomDataSelection.channel)
  return &channel_;
}

// -------------------------------------------------------------------

// CommandModeInformation

// .Kinova.Api.ActuatorConfig.CommandMode command_mode = 1;
inline void CommandModeInformation::clear_command_mode() {
  command_mode_ = 0;
}
inline ::Kinova::Api::ActuatorConfig::CommandMode CommandModeInformation::command_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.CommandModeInformation.command_mode)
  return static_cast< ::Kinova::Api::ActuatorConfig::CommandMode >(command_mode_);
}
inline void CommandModeInformation::set_command_mode(::Kinova::Api::ActuatorConfig::CommandMode value) {
  
  command_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.CommandModeInformation.command_mode)
}

// -------------------------------------------------------------------

// Servoing

// bool enabled = 1;
inline void Servoing::clear_enabled() {
  enabled_ = false;
}
inline bool Servoing::enabled() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.Servoing.enabled)
  return enabled_;
}
inline void Servoing::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.Servoing.enabled)
}

// -------------------------------------------------------------------

// PositionCommand

// float position = 1;
inline void PositionCommand::clear_position() {
  position_ = 0;
}
inline float PositionCommand::position() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.PositionCommand.position)
  return position_;
}
inline void PositionCommand::set_position(float value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.PositionCommand.position)
}

// float velocity = 2;
inline void PositionCommand::clear_velocity() {
  velocity_ = 0;
}
inline float PositionCommand::velocity() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.PositionCommand.velocity)
  return velocity_;
}
inline void PositionCommand::set_velocity(float value) {
  
  velocity_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.PositionCommand.velocity)
}

// float acceleration = 3;
inline void PositionCommand::clear_acceleration() {
  acceleration_ = 0;
}
inline float PositionCommand::acceleration() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.PositionCommand.acceleration)
  return acceleration_;
}
inline void PositionCommand::set_acceleration(float value) {
  
  acceleration_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.PositionCommand.acceleration)
}

// -------------------------------------------------------------------

// CoggingFeedforwardModeInformation

// .Kinova.Api.ActuatorConfig.CoggingFeedforwardMode cogging_feedforward_mode = 1;
inline void CoggingFeedforwardModeInformation::clear_cogging_feedforward_mode() {
  cogging_feedforward_mode_ = 0;
}
inline ::Kinova::Api::ActuatorConfig::CoggingFeedforwardMode CoggingFeedforwardModeInformation::cogging_feedforward_mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.ActuatorConfig.CoggingFeedforwardModeInformation.cogging_feedforward_mode)
  return static_cast< ::Kinova::Api::ActuatorConfig::CoggingFeedforwardMode >(cogging_feedforward_mode_);
}
inline void CoggingFeedforwardModeInformation::set_cogging_feedforward_mode(::Kinova::Api::ActuatorConfig::CoggingFeedforwardMode value) {
  
  cogging_feedforward_mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.ActuatorConfig.CoggingFeedforwardModeInformation.cogging_feedforward_mode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ActuatorConfig
}  // namespace Api
}  // namespace Kinova

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Kinova::Api::ActuatorConfig::ServiceVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::ActuatorConfig::ServiceVersion>() {
  return ::Kinova::Api::ActuatorConfig::ServiceVersion_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::ActuatorConfig::SafetyLimitType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::ActuatorConfig::SafetyLimitType>() {
  return ::Kinova::Api::ActuatorConfig::SafetyLimitType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::ActuatorConfig::ControlMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::ActuatorConfig::ControlMode>() {
  return ::Kinova::Api::ActuatorConfig::ControlMode_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::ActuatorConfig::CommandMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::ActuatorConfig::CommandMode>() {
  return ::Kinova::Api::ActuatorConfig::CommandMode_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::ActuatorConfig::ControlLoopSelection> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::ActuatorConfig::ControlLoopSelection>() {
  return ::Kinova::Api::ActuatorConfig::ControlLoopSelection_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::ActuatorConfig::CoggingFeedforwardMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::ActuatorConfig::CoggingFeedforwardMode>() {
  return ::Kinova::Api::ActuatorConfig::CoggingFeedforwardMode_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::ActuatorConfig::SafetyIdentifierBankA> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::ActuatorConfig::SafetyIdentifierBankA>() {
  return ::Kinova::Api::ActuatorConfig::SafetyIdentifierBankA_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::ActuatorConfig::CustomDataIndex> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::ActuatorConfig::CustomDataIndex>() {
  return ::Kinova::Api::ActuatorConfig::CustomDataIndex_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ActuatorConfig_2eproto__INCLUDED
