// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Common.proto

#ifndef PROTOBUF_Common_2eproto__INCLUDED
#define PROTOBUF_Common_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Common_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsDeviceHandleImpl();
void InitDefaultsDeviceHandle();
void InitDefaultsEmptyImpl();
void InitDefaultsEmpty();
void InitDefaultsNotificationOptionsImpl();
void InitDefaultsNotificationOptions();
void InitDefaultsSafetyHandleImpl();
void InitDefaultsSafetyHandle();
void InitDefaultsNotificationHandleImpl();
void InitDefaultsNotificationHandle();
void InitDefaultsSafetyNotificationImpl();
void InitDefaultsSafetyNotification();
void InitDefaultsTimestampImpl();
void InitDefaultsTimestamp();
void InitDefaultsUserProfileHandleImpl();
void InitDefaultsUserProfileHandle();
void InitDefaultsConnectionImpl();
void InitDefaultsConnection();
void InitDefaultsUARTConfigurationImpl();
void InitDefaultsUARTConfiguration();
void InitDefaultsUARTDeviceIdentificationImpl();
void InitDefaultsUARTDeviceIdentification();
void InitDefaultsCountryCodeImpl();
void InitDefaultsCountryCode();
inline void InitDefaults() {
  InitDefaultsDeviceHandle();
  InitDefaultsEmpty();
  InitDefaultsNotificationOptions();
  InitDefaultsSafetyHandle();
  InitDefaultsNotificationHandle();
  InitDefaultsSafetyNotification();
  InitDefaultsTimestamp();
  InitDefaultsUserProfileHandle();
  InitDefaultsConnection();
  InitDefaultsUARTConfiguration();
  InitDefaultsUARTDeviceIdentification();
  InitDefaultsCountryCode();
}
}  // namespace protobuf_Common_2eproto
namespace Kinova {
namespace Api {
namespace Common {
class Connection;
class ConnectionDefaultTypeInternal;
extern ConnectionDefaultTypeInternal _Connection_default_instance_;
class CountryCode;
class CountryCodeDefaultTypeInternal;
extern CountryCodeDefaultTypeInternal _CountryCode_default_instance_;
class DeviceHandle;
class DeviceHandleDefaultTypeInternal;
extern DeviceHandleDefaultTypeInternal _DeviceHandle_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class NotificationHandle;
class NotificationHandleDefaultTypeInternal;
extern NotificationHandleDefaultTypeInternal _NotificationHandle_default_instance_;
class NotificationOptions;
class NotificationOptionsDefaultTypeInternal;
extern NotificationOptionsDefaultTypeInternal _NotificationOptions_default_instance_;
class SafetyHandle;
class SafetyHandleDefaultTypeInternal;
extern SafetyHandleDefaultTypeInternal _SafetyHandle_default_instance_;
class SafetyNotification;
class SafetyNotificationDefaultTypeInternal;
extern SafetyNotificationDefaultTypeInternal _SafetyNotification_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class UARTConfiguration;
class UARTConfigurationDefaultTypeInternal;
extern UARTConfigurationDefaultTypeInternal _UARTConfiguration_default_instance_;
class UARTDeviceIdentification;
class UARTDeviceIdentificationDefaultTypeInternal;
extern UARTDeviceIdentificationDefaultTypeInternal _UARTDeviceIdentification_default_instance_;
class UserProfileHandle;
class UserProfileHandleDefaultTypeInternal;
extern UserProfileHandleDefaultTypeInternal _UserProfileHandle_default_instance_;
}  // namespace Common
}  // namespace Api
}  // namespace Kinova
namespace Kinova {
namespace Api {
namespace Common {

enum DeviceTypes {
  UNSPECIFIED_DEVICE_TYPE = 0,
  BASE = 1,
  VISION = 2,
  BIG_ACTUATOR = 3,
  SMALL_ACTUATOR = 4,
  INTERCONNECT = 5,
  GRIPPER = 6,
  MEDIUM_ACTUATOR = 7,
  XBIG_ACTUATOR = 8,
  DeviceTypes_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DeviceTypes_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DeviceTypes_IsValid(int value);
const DeviceTypes DeviceTypes_MIN = UNSPECIFIED_DEVICE_TYPE;
const DeviceTypes DeviceTypes_MAX = XBIG_ACTUATOR;
const int DeviceTypes_ARRAYSIZE = DeviceTypes_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeviceTypes_descriptor();
inline const ::std::string& DeviceTypes_Name(DeviceTypes value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeviceTypes_descriptor(), value);
}
inline bool DeviceTypes_Parse(
    const ::std::string& name, DeviceTypes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceTypes>(
    DeviceTypes_descriptor(), name, value);
}
enum SafetyStatusValue {
  SAFETY_STATUS_UNSPECIFIED = 0,
  SAFETY_STATUS_WARNING = 1,
  SAFETY_STATUS_ERROR = 2,
  SAFETY_STATUS_NORMAL = 3,
  SafetyStatusValue_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SafetyStatusValue_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SafetyStatusValue_IsValid(int value);
const SafetyStatusValue SafetyStatusValue_MIN = SAFETY_STATUS_UNSPECIFIED;
const SafetyStatusValue SafetyStatusValue_MAX = SAFETY_STATUS_NORMAL;
const int SafetyStatusValue_ARRAYSIZE = SafetyStatusValue_MAX + 1;

const ::google::protobuf::EnumDescriptor* SafetyStatusValue_descriptor();
inline const ::std::string& SafetyStatusValue_Name(SafetyStatusValue value) {
  return ::google::protobuf::internal::NameOfEnum(
    SafetyStatusValue_descriptor(), value);
}
inline bool SafetyStatusValue_Parse(
    const ::std::string& name, SafetyStatusValue* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SafetyStatusValue>(
    SafetyStatusValue_descriptor(), name, value);
}
enum Permission {
  NO_PERMISSION = 0,
  READ_PERMISSION = 1,
  UPDATE_PERMISSION = 2,
  DELETE_PERMISSION = 4,
  Permission_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Permission_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Permission_IsValid(int value);
const Permission Permission_MIN = NO_PERMISSION;
const Permission Permission_MAX = DELETE_PERMISSION;
const int Permission_ARRAYSIZE = Permission_MAX + 1;

const ::google::protobuf::EnumDescriptor* Permission_descriptor();
inline const ::std::string& Permission_Name(Permission value) {
  return ::google::protobuf::internal::NameOfEnum(
    Permission_descriptor(), value);
}
inline bool Permission_Parse(
    const ::std::string& name, Permission* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Permission>(
    Permission_descriptor(), name, value);
}
enum NotificationType {
  NOTIFICATION_TYPE_UNSPECIFIED = 0,
  NOTIFICATION_TYPE_THRESHOLD = 1,
  NOTIFICATION_TYPE_FIX_RATE = 2,
  NOTIFICATION_TYPE_EVENT = 3,
  NotificationType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NotificationType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NotificationType_IsValid(int value);
const NotificationType NotificationType_MIN = NOTIFICATION_TYPE_UNSPECIFIED;
const NotificationType NotificationType_MAX = NOTIFICATION_TYPE_EVENT;
const int NotificationType_ARRAYSIZE = NotificationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NotificationType_descriptor();
inline const ::std::string& NotificationType_Name(NotificationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NotificationType_descriptor(), value);
}
inline bool NotificationType_Parse(
    const ::std::string& name, NotificationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NotificationType>(
    NotificationType_descriptor(), name, value);
}
enum Unit {
  UNSPECIFIED_UNIT = 0,
  CELSIUS = 1,
  AMPERE = 2,
  VOLT = 3,
  METER_PER_SECOND = 4,
  DEGREE_PER_SECOND = 5,
  METER_PER_SECOND_2 = 6,
  DEGREE_PER_SECOND_2 = 7,
  NEWTON = 8,
  NEWTON_METER = 9,
  KILOGRAM = 10,
  DEGREE = 11,
  TICK = 12,
  DEGREE_PER_MILLISECOND = 13,
  Unit_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Unit_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Unit_IsValid(int value);
const Unit Unit_MIN = UNSPECIFIED_UNIT;
const Unit Unit_MAX = DEGREE_PER_MILLISECOND;
const int Unit_ARRAYSIZE = Unit_MAX + 1;

const ::google::protobuf::EnumDescriptor* Unit_descriptor();
inline const ::std::string& Unit_Name(Unit value) {
  return ::google::protobuf::internal::NameOfEnum(
    Unit_descriptor(), value);
}
inline bool Unit_Parse(
    const ::std::string& name, Unit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Unit>(
    Unit_descriptor(), name, value);
}
enum ArmState {
  ARMSTATE_UNSPECIFIED = 0,
  ARMSTATE_BASE_INITIALIZATION = 1,
  ARMSTATE_IDLE = 2,
  ARMSTATE_INITIALIZATION = 3,
  ARMSTATE_IN_FAULT = 4,
  ARMSTATE_MAINTENANCE = 5,
  ARMSTATE_SERVOING_LOW_LEVEL = 6,
  ARMSTATE_SERVOING_READY = 7,
  ARMSTATE_SERVOING_PLAYING_SEQUENCE = 8,
  ARMSTATE_SERVOING_MANUALLY_CONTROLLED = 9,
  ARMSTATE_RESERVED = 255,
  ArmState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ArmState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ArmState_IsValid(int value);
const ArmState ArmState_MIN = ARMSTATE_UNSPECIFIED;
const ArmState ArmState_MAX = ARMSTATE_RESERVED;
const int ArmState_ARRAYSIZE = ArmState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ArmState_descriptor();
inline const ::std::string& ArmState_Name(ArmState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ArmState_descriptor(), value);
}
inline bool ArmState_Parse(
    const ::std::string& name, ArmState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ArmState>(
    ArmState_descriptor(), name, value);
}
enum UARTSpeed {
  UART_SPEED_UNSPECIFIED = 0,
  UART_SPEED_4800 = 1,
  UART_SPEED_9600 = 2,
  UART_SPEED_19200 = 3,
  UART_SPEED_38400 = 4,
  UART_SPEED_57600 = 5,
  UART_SPEED_115200 = 6,
  UART_SPEED_230400 = 7,
  UART_SPEED_460800 = 8,
  UART_SPEED_921600 = 9,
  UART_SPEED_1382400 = 10,
  UART_SPEED_1612800 = 11,
  UART_SPEED_1843200 = 12,
  UART_SPEED_2073600 = 13,
  UART_SPEED_2188800 = 14,
  UART_SPEED_2246400 = 15,
  UARTSpeed_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UARTSpeed_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UARTSpeed_IsValid(int value);
const UARTSpeed UARTSpeed_MIN = UART_SPEED_UNSPECIFIED;
const UARTSpeed UARTSpeed_MAX = UART_SPEED_2246400;
const int UARTSpeed_ARRAYSIZE = UARTSpeed_MAX + 1;

const ::google::protobuf::EnumDescriptor* UARTSpeed_descriptor();
inline const ::std::string& UARTSpeed_Name(UARTSpeed value) {
  return ::google::protobuf::internal::NameOfEnum(
    UARTSpeed_descriptor(), value);
}
inline bool UARTSpeed_Parse(
    const ::std::string& name, UARTSpeed* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UARTSpeed>(
    UARTSpeed_descriptor(), name, value);
}
enum UARTWordLength {
  UART_WORD_LENGTH_UNSPECIFIED = 0,
  UART_WORD_LENGTH_7 = 1,
  UART_WORD_LENGTH_8 = 2,
  UART_WORD_LENGTH_9 = 3,
  UARTWordLength_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UARTWordLength_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UARTWordLength_IsValid(int value);
const UARTWordLength UARTWordLength_MIN = UART_WORD_LENGTH_UNSPECIFIED;
const UARTWordLength UARTWordLength_MAX = UART_WORD_LENGTH_9;
const int UARTWordLength_ARRAYSIZE = UARTWordLength_MAX + 1;

const ::google::protobuf::EnumDescriptor* UARTWordLength_descriptor();
inline const ::std::string& UARTWordLength_Name(UARTWordLength value) {
  return ::google::protobuf::internal::NameOfEnum(
    UARTWordLength_descriptor(), value);
}
inline bool UARTWordLength_Parse(
    const ::std::string& name, UARTWordLength* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UARTWordLength>(
    UARTWordLength_descriptor(), name, value);
}
enum UARTStopBits {
  UART_STOP_BITS_UNSPECIFIED = 0,
  UART_STOP_BITS_0_5 = 1,
  UART_STOP_BITS_1 = 2,
  UART_STOP_BITS_1_5 = 3,
  UART_STOP_BITS_2 = 4,
  UARTStopBits_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UARTStopBits_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UARTStopBits_IsValid(int value);
const UARTStopBits UARTStopBits_MIN = UART_STOP_BITS_UNSPECIFIED;
const UARTStopBits UARTStopBits_MAX = UART_STOP_BITS_2;
const int UARTStopBits_ARRAYSIZE = UARTStopBits_MAX + 1;

const ::google::protobuf::EnumDescriptor* UARTStopBits_descriptor();
inline const ::std::string& UARTStopBits_Name(UARTStopBits value) {
  return ::google::protobuf::internal::NameOfEnum(
    UARTStopBits_descriptor(), value);
}
inline bool UARTStopBits_Parse(
    const ::std::string& name, UARTStopBits* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UARTStopBits>(
    UARTStopBits_descriptor(), name, value);
}
enum UARTParity {
  UART_PARITY_UNSPECIFIED = 0,
  UART_PARITY_NONE = 1,
  UART_PARITY_ODD = 2,
  UART_PARITY_EVEN = 3,
  UARTParity_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UARTParity_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UARTParity_IsValid(int value);
const UARTParity UARTParity_MIN = UART_PARITY_UNSPECIFIED;
const UARTParity UARTParity_MAX = UART_PARITY_EVEN;
const int UARTParity_ARRAYSIZE = UARTParity_MAX + 1;

const ::google::protobuf::EnumDescriptor* UARTParity_descriptor();
inline const ::std::string& UARTParity_Name(UARTParity value) {
  return ::google::protobuf::internal::NameOfEnum(
    UARTParity_descriptor(), value);
}
inline bool UARTParity_Parse(
    const ::std::string& name, UARTParity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UARTParity>(
    UARTParity_descriptor(), name, value);
}
enum CartesianReferenceFrame {
  CARTESIAN_REFERENCE_FRAME_UNSPECIFIED = 0,
  CARTESIAN_REFERENCE_FRAME_MIXED = 1,
  CARTESIAN_REFERENCE_FRAME_TOOL = 2,
  CARTESIAN_REFERENCE_FRAME_BASE = 3,
  CartesianReferenceFrame_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CartesianReferenceFrame_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CartesianReferenceFrame_IsValid(int value);
const CartesianReferenceFrame CartesianReferenceFrame_MIN = CARTESIAN_REFERENCE_FRAME_UNSPECIFIED;
const CartesianReferenceFrame CartesianReferenceFrame_MAX = CARTESIAN_REFERENCE_FRAME_BASE;
const int CartesianReferenceFrame_ARRAYSIZE = CartesianReferenceFrame_MAX + 1;

const ::google::protobuf::EnumDescriptor* CartesianReferenceFrame_descriptor();
inline const ::std::string& CartesianReferenceFrame_Name(CartesianReferenceFrame value) {
  return ::google::protobuf::internal::NameOfEnum(
    CartesianReferenceFrame_descriptor(), value);
}
inline bool CartesianReferenceFrame_Parse(
    const ::std::string& name, CartesianReferenceFrame* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CartesianReferenceFrame>(
    CartesianReferenceFrame_descriptor(), name, value);
}
enum CountryCodeIdentifier {
  UNSPECIFIED_COUNTRY_CODE = 0,
  UNITED_ARAB_EMIRATES_AE = 1,
  ANTIGUA_AND_BARBUDA_AG = 2,
  ANGUILLA_AI = 3,
  ALBANIA_AL = 4,
  AMERICAN_SAMOA_AS = 5,
  AUSTRIA_AT = 6,
  AUSTRALIA_AU = 7,
  ARUBA_AW = 8,
  AZERBAIJAN_AZ = 9,
  BOSNIA_AND_HERZEGOVINA_BA = 10,
  BANGLADESH_BD = 11,
  BELGIUM_BE = 12,
  BULGARIA_BG = 13,
  BAHRAIN_BH = 14,
  BERMUDA_BM = 15,
  BRUNEI_DARUSSALAM_BN = 16,
  BRAZIL_BR = 17,
  BAHAMAS_BS = 18,
  BELARUS_BY = 19,
  SWITZERLAND_CH = 20,
  CANADA_CA = 21,
  CHINA_CN = 22,
  COLOMBIA_CO = 23,
  COSTA_RICA_CR = 24,
  CYPRUS_CY = 25,
  CZECH_REPUBLIC_CZ = 26,
  GERMANY_DE = 27,
  DENMARK_DK = 28,
  ECUADOR_EC = 29,
  ESTONIA_EE = 30,
  EGYPT_EG = 31,
  SPAIN_ES = 32,
  ETHIOPIA_ET = 33,
  FINLAND_FI = 34,
  FRANCE_FR = 35,
  UNITED_KINGDOM_GB = 36,
  GRENADA_GD = 37,
  FRENCH_GUIANA_GF = 38,
  GUADELOUPE_GP = 39,
  GREECE_GR = 40,
  GUATEMALA_GT = 41,
  GUAM_GU = 42,
  HONG_KONG_HK = 43,
  CROATIA_HR = 44,
  HUNGARY_HU = 45,
  INDIA_IN = 46,
  INDONESIA_ID = 47,
  IRELAND_IE = 48,
  ISRAEL_IL = 49,
  ICELAND_IS = 50,
  ITALY_IT = 51,
  JORDAN_JO = 52,
  JAPAN_JP = 53,
  CAMBODIA_KH = 54,
  REPUBLIC_OF_KOREA_KR = 55,
  KUWAIT_KW = 56,
  CAYMAN_ISLANDS_KY = 57,
  LAO_PDR_LA = 58,
  LEBANON_LB = 59,
  LIECHTENSTEIN_LI = 60,
  SRI_LANKA_LK = 61,
  LESOTHO_LS = 62,
  LITHUANIA_LT = 63,
  LUXEMBOURG_LU = 64,
  LATVIA_LV = 65,
  MOROCCO_MA = 66,
  MONACO_MC = 67,
  MOLDOVA_MD = 68,
  MONTENEGRO_ME = 69,
  REPUBLIC_OF_MACEDONIA_MK = 70,
  MONGOLIA_MN = 71,
  MARTINIQUE_MQ = 72,
  MAURITANIA_MR = 73,
  MALTA_MT = 74,
  MAURITIUS_MU = 75,
  MALDIVES_MV = 76,
  MALAWI_MW = 77,
  MEXICO_MX = 78,
  MALAYSIA_MY = 79,
  NICARAGUA_NI = 80,
  NETHERLANDS_NL = 81,
  NORWAY_NO = 82,
  NEW_ZEALAND_NZ = 83,
  OMAN_OM = 84,
  PANAMA_PA = 85,
  PERU_PE = 86,
  PHILIPPINES_PH = 87,
  POLAND_PL = 88,
  PUERTO_RICO_PR = 89,
  PORTUGAL_PT = 90,
  PARAGUAY_PY = 91,
  REUNION_RE = 92,
  ROMANIA_RO = 93,
  SERBIA_RS = 94,
  RUSSIAN_FEDERATION_RU = 95,
  SWEDEN_SE = 96,
  SINGAPORE_SI = 97,
  SLOVAKIA_SK = 98,
  EL_SALVADOR_SV = 99,
  THAILAND_TH = 100,
  TUNISIA_TN = 101,
  TURKEY_TR = 102,
  TRINIDAD_AND_TOBAGO_TT = 103,
  TAIWAN_PROVINCE_OF_CHINA_TW = 104,
  UKRAINE_UA = 105,
  UNITED_STATES_US = 106,
  HOLY_SEE_VATICAN_CITY_STATE_VA = 107,
  BOLIVARIAN_REPUBLIC_OF_VENEZUELA_VE = 108,
  BRITISH_VIRGIN_ISLANDS_VG = 109,
  VIETNAM_VN = 110,
  MAYOTTE_YT = 111,
  SOUTH_AFRICA_ZA = 112,
  CountryCodeIdentifier_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CountryCodeIdentifier_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CountryCodeIdentifier_IsValid(int value);
const CountryCodeIdentifier CountryCodeIdentifier_MIN = UNSPECIFIED_COUNTRY_CODE;
const CountryCodeIdentifier CountryCodeIdentifier_MAX = SOUTH_AFRICA_ZA;
const int CountryCodeIdentifier_ARRAYSIZE = CountryCodeIdentifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* CountryCodeIdentifier_descriptor();
inline const ::std::string& CountryCodeIdentifier_Name(CountryCodeIdentifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    CountryCodeIdentifier_descriptor(), value);
}
inline bool CountryCodeIdentifier_Parse(
    const ::std::string& name, CountryCodeIdentifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CountryCodeIdentifier>(
    CountryCodeIdentifier_descriptor(), name, value);
}
// ===================================================================

class DeviceHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Common.DeviceHandle) */ {
 public:
  DeviceHandle();
  virtual ~DeviceHandle();

  DeviceHandle(const DeviceHandle& from);

  inline DeviceHandle& operator=(const DeviceHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceHandle(DeviceHandle&& from) noexcept
    : DeviceHandle() {
    *this = ::std::move(from);
  }

  inline DeviceHandle& operator=(DeviceHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceHandle* internal_default_instance() {
    return reinterpret_cast<const DeviceHandle*>(
               &_DeviceHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DeviceHandle* other);
  friend void swap(DeviceHandle& a, DeviceHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  DeviceHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeviceHandle& from);
  void MergeFrom(const DeviceHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeviceHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.DeviceTypes device_type = 1;
  void clear_device_type();
  static const int kDeviceTypeFieldNumber = 1;
  ::Kinova::Api::Common::DeviceTypes device_type() const;
  void set_device_type(::Kinova::Api::Common::DeviceTypes value);

  // uint32 device_identifier = 2;
  void clear_device_identifier();
  static const int kDeviceIdentifierFieldNumber = 2;
  ::google::protobuf::uint32 device_identifier() const;
  void set_device_identifier(::google::protobuf::uint32 value);

  // uint32 order = 3;
  void clear_order();
  static const int kOrderFieldNumber = 3;
  ::google::protobuf::uint32 order() const;
  void set_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Common.DeviceHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int device_type_;
  ::google::protobuf::uint32 device_identifier_;
  ::google::protobuf::uint32 order_;
  mutable int _cached_size_;
  friend struct ::protobuf_Common_2eproto::TableStruct;
  friend void ::protobuf_Common_2eproto::InitDefaultsDeviceHandleImpl();
};
// -------------------------------------------------------------------

class Empty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Common.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Empty* other);
  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const PROTOBUF_FINAL { return New(NULL); }

  Empty* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Kinova.Api.Common.Empty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_Common_2eproto::TableStruct;
  friend void ::protobuf_Common_2eproto::InitDefaultsEmptyImpl();
};
// -------------------------------------------------------------------

class NotificationOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Common.NotificationOptions) */ {
 public:
  NotificationOptions();
  virtual ~NotificationOptions();

  NotificationOptions(const NotificationOptions& from);

  inline NotificationOptions& operator=(const NotificationOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NotificationOptions(NotificationOptions&& from) noexcept
    : NotificationOptions() {
    *this = ::std::move(from);
  }

  inline NotificationOptions& operator=(NotificationOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NotificationOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NotificationOptions* internal_default_instance() {
    return reinterpret_cast<const NotificationOptions*>(
               &_NotificationOptions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(NotificationOptions* other);
  friend void swap(NotificationOptions& a, NotificationOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NotificationOptions* New() const PROTOBUF_FINAL { return New(NULL); }

  NotificationOptions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NotificationOptions& from);
  void MergeFrom(const NotificationOptions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NotificationOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.NotificationType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Kinova::Api::Common::NotificationType type() const;
  void set_type(::Kinova::Api::Common::NotificationType value);

  // uint32 rate_m_sec = 2;
  void clear_rate_m_sec();
  static const int kRateMSecFieldNumber = 2;
  ::google::protobuf::uint32 rate_m_sec() const;
  void set_rate_m_sec(::google::protobuf::uint32 value);

  // float threshold_value = 3;
  void clear_threshold_value();
  static const int kThresholdValueFieldNumber = 3;
  float threshold_value() const;
  void set_threshold_value(float value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Common.NotificationOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int type_;
  ::google::protobuf::uint32 rate_m_sec_;
  float threshold_value_;
  mutable int _cached_size_;
  friend struct ::protobuf_Common_2eproto::TableStruct;
  friend void ::protobuf_Common_2eproto::InitDefaultsNotificationOptionsImpl();
};
// -------------------------------------------------------------------

class SafetyHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Common.SafetyHandle) */ {
 public:
  SafetyHandle();
  virtual ~SafetyHandle();

  SafetyHandle(const SafetyHandle& from);

  inline SafetyHandle& operator=(const SafetyHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SafetyHandle(SafetyHandle&& from) noexcept
    : SafetyHandle() {
    *this = ::std::move(from);
  }

  inline SafetyHandle& operator=(SafetyHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SafetyHandle* internal_default_instance() {
    return reinterpret_cast<const SafetyHandle*>(
               &_SafetyHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(SafetyHandle* other);
  friend void swap(SafetyHandle& a, SafetyHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SafetyHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  SafetyHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SafetyHandle& from);
  void MergeFrom(const SafetyHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SafetyHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 identifier() const;
  void set_identifier(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Common.SafetyHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 identifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_Common_2eproto::TableStruct;
  friend void ::protobuf_Common_2eproto::InitDefaultsSafetyHandleImpl();
};
// -------------------------------------------------------------------

class NotificationHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Common.NotificationHandle) */ {
 public:
  NotificationHandle();
  virtual ~NotificationHandle();

  NotificationHandle(const NotificationHandle& from);

  inline NotificationHandle& operator=(const NotificationHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NotificationHandle(NotificationHandle&& from) noexcept
    : NotificationHandle() {
    *this = ::std::move(from);
  }

  inline NotificationHandle& operator=(NotificationHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NotificationHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NotificationHandle* internal_default_instance() {
    return reinterpret_cast<const NotificationHandle*>(
               &_NotificationHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(NotificationHandle* other);
  friend void swap(NotificationHandle& a, NotificationHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NotificationHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  NotificationHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NotificationHandle& from);
  void MergeFrom(const NotificationHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NotificationHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 identifier() const;
  void set_identifier(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Common.NotificationHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 identifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_Common_2eproto::TableStruct;
  friend void ::protobuf_Common_2eproto::InitDefaultsNotificationHandleImpl();
};
// -------------------------------------------------------------------

class SafetyNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Common.SafetyNotification) */ {
 public:
  SafetyNotification();
  virtual ~SafetyNotification();

  SafetyNotification(const SafetyNotification& from);

  inline SafetyNotification& operator=(const SafetyNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SafetyNotification(SafetyNotification&& from) noexcept
    : SafetyNotification() {
    *this = ::std::move(from);
  }

  inline SafetyNotification& operator=(SafetyNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SafetyNotification* internal_default_instance() {
    return reinterpret_cast<const SafetyNotification*>(
               &_SafetyNotification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(SafetyNotification* other);
  friend void swap(SafetyNotification& a, SafetyNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SafetyNotification* New() const PROTOBUF_FINAL { return New(NULL); }

  SafetyNotification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SafetyNotification& from);
  void MergeFrom(const SafetyNotification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SafetyNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.SafetyHandle safety_handle = 1;
  bool has_safety_handle() const;
  void clear_safety_handle();
  static const int kSafetyHandleFieldNumber = 1;
  const ::Kinova::Api::Common::SafetyHandle& safety_handle() const;
  ::Kinova::Api::Common::SafetyHandle* release_safety_handle();
  ::Kinova::Api::Common::SafetyHandle* mutable_safety_handle();
  void set_allocated_safety_handle(::Kinova::Api::Common::SafetyHandle* safety_handle);

  // .Kinova.Api.Common.Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  const ::Kinova::Api::Common::Timestamp& timestamp() const;
  ::Kinova::Api::Common::Timestamp* release_timestamp();
  ::Kinova::Api::Common::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 4;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 4;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // .Kinova.Api.Common.Connection connection = 5;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 5;
  const ::Kinova::Api::Common::Connection& connection() const;
  ::Kinova::Api::Common::Connection* release_connection();
  ::Kinova::Api::Common::Connection* mutable_connection();
  void set_allocated_connection(::Kinova::Api::Common::Connection* connection);

  // .Kinova.Api.Common.SafetyStatusValue value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::Kinova::Api::Common::SafetyStatusValue value() const;
  void set_value(::Kinova::Api::Common::SafetyStatusValue value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Common.SafetyNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::Common::SafetyHandle* safety_handle_;
  ::Kinova::Api::Common::Timestamp* timestamp_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::Kinova::Api::Common::Connection* connection_;
  int value_;
  mutable int _cached_size_;
  friend struct ::protobuf_Common_2eproto::TableStruct;
  friend void ::protobuf_Common_2eproto::InitDefaultsSafetyNotificationImpl();
};
// -------------------------------------------------------------------

class Timestamp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Common.Timestamp) */ {
 public:
  Timestamp();
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Timestamp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Timestamp* other);
  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const PROTOBUF_FINAL { return New(NULL); }

  Timestamp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Timestamp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 sec = 1;
  void clear_sec();
  static const int kSecFieldNumber = 1;
  ::google::protobuf::uint32 sec() const;
  void set_sec(::google::protobuf::uint32 value);

  // uint32 usec = 2;
  void clear_usec();
  static const int kUsecFieldNumber = 2;
  ::google::protobuf::uint32 usec() const;
  void set_usec(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Common.Timestamp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 sec_;
  ::google::protobuf::uint32 usec_;
  mutable int _cached_size_;
  friend struct ::protobuf_Common_2eproto::TableStruct;
  friend void ::protobuf_Common_2eproto::InitDefaultsTimestampImpl();
};
// -------------------------------------------------------------------

class UserProfileHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Common.UserProfileHandle) */ {
 public:
  UserProfileHandle();
  virtual ~UserProfileHandle();

  UserProfileHandle(const UserProfileHandle& from);

  inline UserProfileHandle& operator=(const UserProfileHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserProfileHandle(UserProfileHandle&& from) noexcept
    : UserProfileHandle() {
    *this = ::std::move(from);
  }

  inline UserProfileHandle& operator=(UserProfileHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserProfileHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserProfileHandle* internal_default_instance() {
    return reinterpret_cast<const UserProfileHandle*>(
               &_UserProfileHandle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(UserProfileHandle* other);
  friend void swap(UserProfileHandle& a, UserProfileHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserProfileHandle* New() const PROTOBUF_FINAL { return New(NULL); }

  UserProfileHandle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserProfileHandle& from);
  void MergeFrom(const UserProfileHandle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserProfileHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::google::protobuf::uint32 identifier() const;
  void set_identifier(::google::protobuf::uint32 value);

  // fixed32 permission = 2;
  void clear_permission();
  static const int kPermissionFieldNumber = 2;
  ::google::protobuf::uint32 permission() const;
  void set_permission(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Common.UserProfileHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 identifier_;
  ::google::protobuf::uint32 permission_;
  mutable int _cached_size_;
  friend struct ::protobuf_Common_2eproto::TableStruct;
  friend void ::protobuf_Common_2eproto::InitDefaultsUserProfileHandleImpl();
};
// -------------------------------------------------------------------

class Connection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Common.Connection) */ {
 public:
  Connection();
  virtual ~Connection();

  Connection(const Connection& from);

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Connection(Connection&& from) noexcept
    : Connection() {
    *this = ::std::move(from);
  }

  inline Connection& operator=(Connection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Connection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Connection* internal_default_instance() {
    return reinterpret_cast<const Connection*>(
               &_Connection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Connection* other);
  friend void swap(Connection& a, Connection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Connection* New() const PROTOBUF_FINAL { return New(NULL); }

  Connection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Connection& from);
  void MergeFrom(const Connection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Connection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string connection_information = 2;
  void clear_connection_information();
  static const int kConnectionInformationFieldNumber = 2;
  const ::std::string& connection_information() const;
  void set_connection_information(const ::std::string& value);
  #if LANG_CXX11
  void set_connection_information(::std::string&& value);
  #endif
  void set_connection_information(const char* value);
  void set_connection_information(const char* value, size_t size);
  ::std::string* mutable_connection_information();
  ::std::string* release_connection_information();
  void set_allocated_connection_information(::std::string* connection_information);

  // .Kinova.Api.Common.UserProfileHandle user_handle = 1;
  bool has_user_handle() const;
  void clear_user_handle();
  static const int kUserHandleFieldNumber = 1;
  const ::Kinova::Api::Common::UserProfileHandle& user_handle() const;
  ::Kinova::Api::Common::UserProfileHandle* release_user_handle();
  ::Kinova::Api::Common::UserProfileHandle* mutable_user_handle();
  void set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle);

  // uint32 connection_identifier = 3;
  void clear_connection_identifier();
  static const int kConnectionIdentifierFieldNumber = 3;
  ::google::protobuf::uint32 connection_identifier() const;
  void set_connection_identifier(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Common.Connection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr connection_information_;
  ::Kinova::Api::Common::UserProfileHandle* user_handle_;
  ::google::protobuf::uint32 connection_identifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_Common_2eproto::TableStruct;
  friend void ::protobuf_Common_2eproto::InitDefaultsConnectionImpl();
};
// -------------------------------------------------------------------

class UARTConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Common.UARTConfiguration) */ {
 public:
  UARTConfiguration();
  virtual ~UARTConfiguration();

  UARTConfiguration(const UARTConfiguration& from);

  inline UARTConfiguration& operator=(const UARTConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UARTConfiguration(UARTConfiguration&& from) noexcept
    : UARTConfiguration() {
    *this = ::std::move(from);
  }

  inline UARTConfiguration& operator=(UARTConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UARTConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UARTConfiguration* internal_default_instance() {
    return reinterpret_cast<const UARTConfiguration*>(
               &_UARTConfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(UARTConfiguration* other);
  friend void swap(UARTConfiguration& a, UARTConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UARTConfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  UARTConfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UARTConfiguration& from);
  void MergeFrom(const UARTConfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UARTConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 port_id = 1;
  void clear_port_id();
  static const int kPortIdFieldNumber = 1;
  ::google::protobuf::uint32 port_id() const;
  void set_port_id(::google::protobuf::uint32 value);

  // bool enabled = 2;
  void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  bool enabled() const;
  void set_enabled(bool value);

  // .Kinova.Api.Common.UARTSpeed speed = 3;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  ::Kinova::Api::Common::UARTSpeed speed() const;
  void set_speed(::Kinova::Api::Common::UARTSpeed value);

  // .Kinova.Api.Common.UARTWordLength word_length = 4;
  void clear_word_length();
  static const int kWordLengthFieldNumber = 4;
  ::Kinova::Api::Common::UARTWordLength word_length() const;
  void set_word_length(::Kinova::Api::Common::UARTWordLength value);

  // .Kinova.Api.Common.UARTStopBits stop_bits = 5;
  void clear_stop_bits();
  static const int kStopBitsFieldNumber = 5;
  ::Kinova::Api::Common::UARTStopBits stop_bits() const;
  void set_stop_bits(::Kinova::Api::Common::UARTStopBits value);

  // .Kinova.Api.Common.UARTParity parity = 6;
  void clear_parity();
  static const int kParityFieldNumber = 6;
  ::Kinova::Api::Common::UARTParity parity() const;
  void set_parity(::Kinova::Api::Common::UARTParity value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Common.UARTConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 port_id_;
  bool enabled_;
  int speed_;
  int word_length_;
  int stop_bits_;
  int parity_;
  mutable int _cached_size_;
  friend struct ::protobuf_Common_2eproto::TableStruct;
  friend void ::protobuf_Common_2eproto::InitDefaultsUARTConfigurationImpl();
};
// -------------------------------------------------------------------

class UARTDeviceIdentification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Common.UARTDeviceIdentification) */ {
 public:
  UARTDeviceIdentification();
  virtual ~UARTDeviceIdentification();

  UARTDeviceIdentification(const UARTDeviceIdentification& from);

  inline UARTDeviceIdentification& operator=(const UARTDeviceIdentification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UARTDeviceIdentification(UARTDeviceIdentification&& from) noexcept
    : UARTDeviceIdentification() {
    *this = ::std::move(from);
  }

  inline UARTDeviceIdentification& operator=(UARTDeviceIdentification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UARTDeviceIdentification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UARTDeviceIdentification* internal_default_instance() {
    return reinterpret_cast<const UARTDeviceIdentification*>(
               &_UARTDeviceIdentification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(UARTDeviceIdentification* other);
  friend void swap(UARTDeviceIdentification& a, UARTDeviceIdentification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UARTDeviceIdentification* New() const PROTOBUF_FINAL { return New(NULL); }

  UARTDeviceIdentification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UARTDeviceIdentification& from);
  void MergeFrom(const UARTDeviceIdentification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UARTDeviceIdentification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 port_id = 1;
  void clear_port_id();
  static const int kPortIdFieldNumber = 1;
  ::google::protobuf::uint32 port_id() const;
  void set_port_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Common.UARTDeviceIdentification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 port_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_Common_2eproto::TableStruct;
  friend void ::protobuf_Common_2eproto::InitDefaultsUARTDeviceIdentificationImpl();
};
// -------------------------------------------------------------------

class CountryCode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.Common.CountryCode) */ {
 public:
  CountryCode();
  virtual ~CountryCode();

  CountryCode(const CountryCode& from);

  inline CountryCode& operator=(const CountryCode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CountryCode(CountryCode&& from) noexcept
    : CountryCode() {
    *this = ::std::move(from);
  }

  inline CountryCode& operator=(CountryCode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CountryCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CountryCode* internal_default_instance() {
    return reinterpret_cast<const CountryCode*>(
               &_CountryCode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(CountryCode* other);
  friend void swap(CountryCode& a, CountryCode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CountryCode* New() const PROTOBUF_FINAL { return New(NULL); }

  CountryCode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CountryCode& from);
  void MergeFrom(const CountryCode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CountryCode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.Common.CountryCodeIdentifier identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::Kinova::Api::Common::CountryCodeIdentifier identifier() const;
  void set_identifier(::Kinova::Api::Common::CountryCodeIdentifier value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.Common.CountryCode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int identifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_Common_2eproto::TableStruct;
  friend void ::protobuf_Common_2eproto::InitDefaultsCountryCodeImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DeviceHandle

// .Kinova.Api.Common.DeviceTypes device_type = 1;
inline void DeviceHandle::clear_device_type() {
  device_type_ = 0;
}
inline ::Kinova::Api::Common::DeviceTypes DeviceHandle::device_type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.DeviceHandle.device_type)
  return static_cast< ::Kinova::Api::Common::DeviceTypes >(device_type_);
}
inline void DeviceHandle::set_device_type(::Kinova::Api::Common::DeviceTypes value) {
  
  device_type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.DeviceHandle.device_type)
}

// uint32 device_identifier = 2;
inline void DeviceHandle::clear_device_identifier() {
  device_identifier_ = 0u;
}
inline ::google::protobuf::uint32 DeviceHandle::device_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.DeviceHandle.device_identifier)
  return device_identifier_;
}
inline void DeviceHandle::set_device_identifier(::google::protobuf::uint32 value) {
  
  device_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.DeviceHandle.device_identifier)
}

// uint32 order = 3;
inline void DeviceHandle::clear_order() {
  order_ = 0u;
}
inline ::google::protobuf::uint32 DeviceHandle::order() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.DeviceHandle.order)
  return order_;
}
inline void DeviceHandle::set_order(::google::protobuf::uint32 value) {
  
  order_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.DeviceHandle.order)
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// NotificationOptions

// .Kinova.Api.Common.NotificationType type = 1;
inline void NotificationOptions::clear_type() {
  type_ = 0;
}
inline ::Kinova::Api::Common::NotificationType NotificationOptions::type() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.NotificationOptions.type)
  return static_cast< ::Kinova::Api::Common::NotificationType >(type_);
}
inline void NotificationOptions::set_type(::Kinova::Api::Common::NotificationType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.NotificationOptions.type)
}

// uint32 rate_m_sec = 2;
inline void NotificationOptions::clear_rate_m_sec() {
  rate_m_sec_ = 0u;
}
inline ::google::protobuf::uint32 NotificationOptions::rate_m_sec() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.NotificationOptions.rate_m_sec)
  return rate_m_sec_;
}
inline void NotificationOptions::set_rate_m_sec(::google::protobuf::uint32 value) {
  
  rate_m_sec_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.NotificationOptions.rate_m_sec)
}

// float threshold_value = 3;
inline void NotificationOptions::clear_threshold_value() {
  threshold_value_ = 0;
}
inline float NotificationOptions::threshold_value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.NotificationOptions.threshold_value)
  return threshold_value_;
}
inline void NotificationOptions::set_threshold_value(float value) {
  
  threshold_value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.NotificationOptions.threshold_value)
}

// -------------------------------------------------------------------

// SafetyHandle

// uint32 identifier = 1;
inline void SafetyHandle::clear_identifier() {
  identifier_ = 0u;
}
inline ::google::protobuf::uint32 SafetyHandle::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.SafetyHandle.identifier)
  return identifier_;
}
inline void SafetyHandle::set_identifier(::google::protobuf::uint32 value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.SafetyHandle.identifier)
}

// -------------------------------------------------------------------

// NotificationHandle

// uint32 identifier = 1;
inline void NotificationHandle::clear_identifier() {
  identifier_ = 0u;
}
inline ::google::protobuf::uint32 NotificationHandle::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.NotificationHandle.identifier)
  return identifier_;
}
inline void NotificationHandle::set_identifier(::google::protobuf::uint32 value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.NotificationHandle.identifier)
}

// -------------------------------------------------------------------

// SafetyNotification

// .Kinova.Api.Common.SafetyHandle safety_handle = 1;
inline bool SafetyNotification::has_safety_handle() const {
  return this != internal_default_instance() && safety_handle_ != NULL;
}
inline void SafetyNotification::clear_safety_handle() {
  if (GetArenaNoVirtual() == NULL && safety_handle_ != NULL) {
    delete safety_handle_;
  }
  safety_handle_ = NULL;
}
inline const ::Kinova::Api::Common::SafetyHandle& SafetyNotification::safety_handle() const {
  const ::Kinova::Api::Common::SafetyHandle* p = safety_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.SafetyNotification.safety_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::SafetyHandle*>(
      &::Kinova::Api::Common::_SafetyHandle_default_instance_);
}
inline ::Kinova::Api::Common::SafetyHandle* SafetyNotification::release_safety_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Common.SafetyNotification.safety_handle)
  
  ::Kinova::Api::Common::SafetyHandle* temp = safety_handle_;
  safety_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::SafetyHandle* SafetyNotification::mutable_safety_handle() {
  
  if (safety_handle_ == NULL) {
    safety_handle_ = new ::Kinova::Api::Common::SafetyHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Common.SafetyNotification.safety_handle)
  return safety_handle_;
}
inline void SafetyNotification::set_allocated_safety_handle(::Kinova::Api::Common::SafetyHandle* safety_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete safety_handle_;
  }
  if (safety_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      safety_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, safety_handle, submessage_arena);
    }
    
  } else {
    
  }
  safety_handle_ = safety_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Common.SafetyNotification.safety_handle)
}

// .Kinova.Api.Common.SafetyStatusValue value = 2;
inline void SafetyNotification::clear_value() {
  value_ = 0;
}
inline ::Kinova::Api::Common::SafetyStatusValue SafetyNotification::value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.SafetyNotification.value)
  return static_cast< ::Kinova::Api::Common::SafetyStatusValue >(value_);
}
inline void SafetyNotification::set_value(::Kinova::Api::Common::SafetyStatusValue value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.SafetyNotification.value)
}

// .Kinova.Api.Common.Timestamp timestamp = 3;
inline bool SafetyNotification::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void SafetyNotification::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) {
    delete timestamp_;
  }
  timestamp_ = NULL;
}
inline const ::Kinova::Api::Common::Timestamp& SafetyNotification::timestamp() const {
  const ::Kinova::Api::Common::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.SafetyNotification.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Timestamp*>(
      &::Kinova::Api::Common::_Timestamp_default_instance_);
}
inline ::Kinova::Api::Common::Timestamp* SafetyNotification::release_timestamp() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Common.SafetyNotification.timestamp)
  
  ::Kinova::Api::Common::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Timestamp* SafetyNotification::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::Kinova::Api::Common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Common.SafetyNotification.timestamp)
  return timestamp_;
}
inline void SafetyNotification::set_allocated_timestamp(::Kinova::Api::Common::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete timestamp_;
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Common.SafetyNotification.timestamp)
}

// .Kinova.Api.Common.UserProfileHandle user_handle = 4;
inline bool SafetyNotification::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline void SafetyNotification::clear_user_handle() {
  if (GetArenaNoVirtual() == NULL && user_handle_ != NULL) {
    delete user_handle_;
  }
  user_handle_ = NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& SafetyNotification::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.SafetyNotification.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* SafetyNotification::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Common.SafetyNotification.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* SafetyNotification::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Common.SafetyNotification.user_handle)
  return user_handle_;
}
inline void SafetyNotification::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_handle_;
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Common.SafetyNotification.user_handle)
}

// .Kinova.Api.Common.Connection connection = 5;
inline bool SafetyNotification::has_connection() const {
  return this != internal_default_instance() && connection_ != NULL;
}
inline void SafetyNotification::clear_connection() {
  if (GetArenaNoVirtual() == NULL && connection_ != NULL) {
    delete connection_;
  }
  connection_ = NULL;
}
inline const ::Kinova::Api::Common::Connection& SafetyNotification::connection() const {
  const ::Kinova::Api::Common::Connection* p = connection_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.SafetyNotification.connection)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::Connection*>(
      &::Kinova::Api::Common::_Connection_default_instance_);
}
inline ::Kinova::Api::Common::Connection* SafetyNotification::release_connection() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Common.SafetyNotification.connection)
  
  ::Kinova::Api::Common::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::Connection* SafetyNotification::mutable_connection() {
  
  if (connection_ == NULL) {
    connection_ = new ::Kinova::Api::Common::Connection;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Common.SafetyNotification.connection)
  return connection_;
}
inline void SafetyNotification::set_allocated_connection(::Kinova::Api::Common::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete connection_;
  }
  if (connection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Common.SafetyNotification.connection)
}

// -------------------------------------------------------------------

// Timestamp

// uint32 sec = 1;
inline void Timestamp::clear_sec() {
  sec_ = 0u;
}
inline ::google::protobuf::uint32 Timestamp::sec() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.Timestamp.sec)
  return sec_;
}
inline void Timestamp::set_sec(::google::protobuf::uint32 value) {
  
  sec_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.Timestamp.sec)
}

// uint32 usec = 2;
inline void Timestamp::clear_usec() {
  usec_ = 0u;
}
inline ::google::protobuf::uint32 Timestamp::usec() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.Timestamp.usec)
  return usec_;
}
inline void Timestamp::set_usec(::google::protobuf::uint32 value) {
  
  usec_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.Timestamp.usec)
}

// -------------------------------------------------------------------

// UserProfileHandle

// uint32 identifier = 1;
inline void UserProfileHandle::clear_identifier() {
  identifier_ = 0u;
}
inline ::google::protobuf::uint32 UserProfileHandle::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.UserProfileHandle.identifier)
  return identifier_;
}
inline void UserProfileHandle::set_identifier(::google::protobuf::uint32 value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.UserProfileHandle.identifier)
}

// fixed32 permission = 2;
inline void UserProfileHandle::clear_permission() {
  permission_ = 0u;
}
inline ::google::protobuf::uint32 UserProfileHandle::permission() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.UserProfileHandle.permission)
  return permission_;
}
inline void UserProfileHandle::set_permission(::google::protobuf::uint32 value) {
  
  permission_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.UserProfileHandle.permission)
}

// -------------------------------------------------------------------

// Connection

// .Kinova.Api.Common.UserProfileHandle user_handle = 1;
inline bool Connection::has_user_handle() const {
  return this != internal_default_instance() && user_handle_ != NULL;
}
inline void Connection::clear_user_handle() {
  if (GetArenaNoVirtual() == NULL && user_handle_ != NULL) {
    delete user_handle_;
  }
  user_handle_ = NULL;
}
inline const ::Kinova::Api::Common::UserProfileHandle& Connection::user_handle() const {
  const ::Kinova::Api::Common::UserProfileHandle* p = user_handle_;
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.Connection.user_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::Common::UserProfileHandle*>(
      &::Kinova::Api::Common::_UserProfileHandle_default_instance_);
}
inline ::Kinova::Api::Common::UserProfileHandle* Connection::release_user_handle() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Common.Connection.user_handle)
  
  ::Kinova::Api::Common::UserProfileHandle* temp = user_handle_;
  user_handle_ = NULL;
  return temp;
}
inline ::Kinova::Api::Common::UserProfileHandle* Connection::mutable_user_handle() {
  
  if (user_handle_ == NULL) {
    user_handle_ = new ::Kinova::Api::Common::UserProfileHandle;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Common.Connection.user_handle)
  return user_handle_;
}
inline void Connection::set_allocated_user_handle(::Kinova::Api::Common::UserProfileHandle* user_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_handle_;
  }
  if (user_handle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_handle, submessage_arena);
    }
    
  } else {
    
  }
  user_handle_ = user_handle;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Common.Connection.user_handle)
}

// string connection_information = 2;
inline void Connection::clear_connection_information() {
  connection_information_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Connection::connection_information() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.Connection.connection_information)
  return connection_information_.GetNoArena();
}
inline void Connection::set_connection_information(const ::std::string& value) {
  
  connection_information_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.Connection.connection_information)
}
#if LANG_CXX11
inline void Connection::set_connection_information(::std::string&& value) {
  
  connection_information_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.Common.Connection.connection_information)
}
#endif
inline void Connection::set_connection_information(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  connection_information_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.Common.Connection.connection_information)
}
inline void Connection::set_connection_information(const char* value, size_t size) {
  
  connection_information_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.Common.Connection.connection_information)
}
inline ::std::string* Connection::mutable_connection_information() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.Common.Connection.connection_information)
  return connection_information_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Connection::release_connection_information() {
  // @@protoc_insertion_point(field_release:Kinova.Api.Common.Connection.connection_information)
  
  return connection_information_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connection::set_allocated_connection_information(::std::string* connection_information) {
  if (connection_information != NULL) {
    
  } else {
    
  }
  connection_information_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), connection_information);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.Common.Connection.connection_information)
}

// uint32 connection_identifier = 3;
inline void Connection::clear_connection_identifier() {
  connection_identifier_ = 0u;
}
inline ::google::protobuf::uint32 Connection::connection_identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.Connection.connection_identifier)
  return connection_identifier_;
}
inline void Connection::set_connection_identifier(::google::protobuf::uint32 value) {
  
  connection_identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.Connection.connection_identifier)
}

// -------------------------------------------------------------------

// UARTConfiguration

// uint32 port_id = 1;
inline void UARTConfiguration::clear_port_id() {
  port_id_ = 0u;
}
inline ::google::protobuf::uint32 UARTConfiguration::port_id() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.UARTConfiguration.port_id)
  return port_id_;
}
inline void UARTConfiguration::set_port_id(::google::protobuf::uint32 value) {
  
  port_id_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.UARTConfiguration.port_id)
}

// bool enabled = 2;
inline void UARTConfiguration::clear_enabled() {
  enabled_ = false;
}
inline bool UARTConfiguration::enabled() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.UARTConfiguration.enabled)
  return enabled_;
}
inline void UARTConfiguration::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.UARTConfiguration.enabled)
}

// .Kinova.Api.Common.UARTSpeed speed = 3;
inline void UARTConfiguration::clear_speed() {
  speed_ = 0;
}
inline ::Kinova::Api::Common::UARTSpeed UARTConfiguration::speed() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.UARTConfiguration.speed)
  return static_cast< ::Kinova::Api::Common::UARTSpeed >(speed_);
}
inline void UARTConfiguration::set_speed(::Kinova::Api::Common::UARTSpeed value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.UARTConfiguration.speed)
}

// .Kinova.Api.Common.UARTWordLength word_length = 4;
inline void UARTConfiguration::clear_word_length() {
  word_length_ = 0;
}
inline ::Kinova::Api::Common::UARTWordLength UARTConfiguration::word_length() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.UARTConfiguration.word_length)
  return static_cast< ::Kinova::Api::Common::UARTWordLength >(word_length_);
}
inline void UARTConfiguration::set_word_length(::Kinova::Api::Common::UARTWordLength value) {
  
  word_length_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.UARTConfiguration.word_length)
}

// .Kinova.Api.Common.UARTStopBits stop_bits = 5;
inline void UARTConfiguration::clear_stop_bits() {
  stop_bits_ = 0;
}
inline ::Kinova::Api::Common::UARTStopBits UARTConfiguration::stop_bits() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.UARTConfiguration.stop_bits)
  return static_cast< ::Kinova::Api::Common::UARTStopBits >(stop_bits_);
}
inline void UARTConfiguration::set_stop_bits(::Kinova::Api::Common::UARTStopBits value) {
  
  stop_bits_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.UARTConfiguration.stop_bits)
}

// .Kinova.Api.Common.UARTParity parity = 6;
inline void UARTConfiguration::clear_parity() {
  parity_ = 0;
}
inline ::Kinova::Api::Common::UARTParity UARTConfiguration::parity() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.UARTConfiguration.parity)
  return static_cast< ::Kinova::Api::Common::UARTParity >(parity_);
}
inline void UARTConfiguration::set_parity(::Kinova::Api::Common::UARTParity value) {
  
  parity_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.UARTConfiguration.parity)
}

// -------------------------------------------------------------------

// UARTDeviceIdentification

// uint32 port_id = 1;
inline void UARTDeviceIdentification::clear_port_id() {
  port_id_ = 0u;
}
inline ::google::protobuf::uint32 UARTDeviceIdentification::port_id() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.UARTDeviceIdentification.port_id)
  return port_id_;
}
inline void UARTDeviceIdentification::set_port_id(::google::protobuf::uint32 value) {
  
  port_id_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.UARTDeviceIdentification.port_id)
}

// -------------------------------------------------------------------

// CountryCode

// .Kinova.Api.Common.CountryCodeIdentifier identifier = 1;
inline void CountryCode::clear_identifier() {
  identifier_ = 0;
}
inline ::Kinova::Api::Common::CountryCodeIdentifier CountryCode::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.Common.CountryCode.identifier)
  return static_cast< ::Kinova::Api::Common::CountryCodeIdentifier >(identifier_);
}
inline void CountryCode::set_identifier(::Kinova::Api::Common::CountryCodeIdentifier value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.Common.CountryCode.identifier)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Common
}  // namespace Api
}  // namespace Kinova

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Kinova::Api::Common::DeviceTypes> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Common::DeviceTypes>() {
  return ::Kinova::Api::Common::DeviceTypes_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Common::SafetyStatusValue> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Common::SafetyStatusValue>() {
  return ::Kinova::Api::Common::SafetyStatusValue_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Common::Permission> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Common::Permission>() {
  return ::Kinova::Api::Common::Permission_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Common::NotificationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Common::NotificationType>() {
  return ::Kinova::Api::Common::NotificationType_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Common::Unit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Common::Unit>() {
  return ::Kinova::Api::Common::Unit_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Common::ArmState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Common::ArmState>() {
  return ::Kinova::Api::Common::ArmState_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Common::UARTSpeed> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Common::UARTSpeed>() {
  return ::Kinova::Api::Common::UARTSpeed_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Common::UARTWordLength> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Common::UARTWordLength>() {
  return ::Kinova::Api::Common::UARTWordLength_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Common::UARTStopBits> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Common::UARTStopBits>() {
  return ::Kinova::Api::Common::UARTStopBits_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Common::UARTParity> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Common::UARTParity>() {
  return ::Kinova::Api::Common::UARTParity_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Common::CartesianReferenceFrame> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Common::CartesianReferenceFrame>() {
  return ::Kinova::Api::Common::CartesianReferenceFrame_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::Common::CountryCodeIdentifier> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::Common::CountryCodeIdentifier>() {
  return ::Kinova::Api::Common::CountryCodeIdentifier_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Common_2eproto__INCLUDED
