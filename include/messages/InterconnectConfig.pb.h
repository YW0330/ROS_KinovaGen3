// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: InterconnectConfig.proto

#ifndef PROTOBUF_InterconnectConfig_2eproto__INCLUDED
#define PROTOBUF_InterconnectConfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Common.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace protobuf_InterconnectConfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsEthernetDeviceIdentificationImpl();
void InitDefaultsEthernetDeviceIdentification();
void InitDefaultsEthernetConfigurationImpl();
void InitDefaultsEthernetConfiguration();
void InitDefaultsGPIOIdentificationImpl();
void InitDefaultsGPIOIdentification();
void InitDefaultsGPIOConfigurationImpl();
void InitDefaultsGPIOConfiguration();
void InitDefaultsGPIOStateImpl();
void InitDefaultsGPIOState();
void InitDefaultsI2CDeviceIdentificationImpl();
void InitDefaultsI2CDeviceIdentification();
void InitDefaultsI2CConfigurationImpl();
void InitDefaultsI2CConfiguration();
void InitDefaultsI2CReadParameterImpl();
void InitDefaultsI2CReadParameter();
void InitDefaultsI2CReadRegisterParameterImpl();
void InitDefaultsI2CReadRegisterParameter();
void InitDefaultsI2CWriteParameterImpl();
void InitDefaultsI2CWriteParameter();
void InitDefaultsI2CWriteRegisterParameterImpl();
void InitDefaultsI2CWriteRegisterParameter();
void InitDefaultsI2CDataImpl();
void InitDefaultsI2CData();
inline void InitDefaults() {
  InitDefaultsEthernetDeviceIdentification();
  InitDefaultsEthernetConfiguration();
  InitDefaultsGPIOIdentification();
  InitDefaultsGPIOConfiguration();
  InitDefaultsGPIOState();
  InitDefaultsI2CDeviceIdentification();
  InitDefaultsI2CConfiguration();
  InitDefaultsI2CReadParameter();
  InitDefaultsI2CReadRegisterParameter();
  InitDefaultsI2CWriteParameter();
  InitDefaultsI2CWriteRegisterParameter();
  InitDefaultsI2CData();
}
}  // namespace protobuf_InterconnectConfig_2eproto
namespace Kinova {
namespace Api {
namespace InterconnectConfig {
class EthernetConfiguration;
class EthernetConfigurationDefaultTypeInternal;
extern EthernetConfigurationDefaultTypeInternal _EthernetConfiguration_default_instance_;
class EthernetDeviceIdentification;
class EthernetDeviceIdentificationDefaultTypeInternal;
extern EthernetDeviceIdentificationDefaultTypeInternal _EthernetDeviceIdentification_default_instance_;
class GPIOConfiguration;
class GPIOConfigurationDefaultTypeInternal;
extern GPIOConfigurationDefaultTypeInternal _GPIOConfiguration_default_instance_;
class GPIOIdentification;
class GPIOIdentificationDefaultTypeInternal;
extern GPIOIdentificationDefaultTypeInternal _GPIOIdentification_default_instance_;
class GPIOState;
class GPIOStateDefaultTypeInternal;
extern GPIOStateDefaultTypeInternal _GPIOState_default_instance_;
class I2CConfiguration;
class I2CConfigurationDefaultTypeInternal;
extern I2CConfigurationDefaultTypeInternal _I2CConfiguration_default_instance_;
class I2CData;
class I2CDataDefaultTypeInternal;
extern I2CDataDefaultTypeInternal _I2CData_default_instance_;
class I2CDeviceIdentification;
class I2CDeviceIdentificationDefaultTypeInternal;
extern I2CDeviceIdentificationDefaultTypeInternal _I2CDeviceIdentification_default_instance_;
class I2CReadParameter;
class I2CReadParameterDefaultTypeInternal;
extern I2CReadParameterDefaultTypeInternal _I2CReadParameter_default_instance_;
class I2CReadRegisterParameter;
class I2CReadRegisterParameterDefaultTypeInternal;
extern I2CReadRegisterParameterDefaultTypeInternal _I2CReadRegisterParameter_default_instance_;
class I2CWriteParameter;
class I2CWriteParameterDefaultTypeInternal;
extern I2CWriteParameterDefaultTypeInternal _I2CWriteParameter_default_instance_;
class I2CWriteRegisterParameter;
class I2CWriteRegisterParameterDefaultTypeInternal;
extern I2CWriteRegisterParameterDefaultTypeInternal _I2CWriteRegisterParameter_default_instance_;
}  // namespace InterconnectConfig
}  // namespace Api
}  // namespace Kinova
namespace Kinova {
namespace Api {
namespace InterconnectConfig {

enum ServiceVersion {
  RESERVED_0 = 0,
  CURRENT_VERSION = 1,
  ServiceVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ServiceVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ServiceVersion_IsValid(int value);
const ServiceVersion ServiceVersion_MIN = RESERVED_0;
const ServiceVersion ServiceVersion_MAX = CURRENT_VERSION;
const int ServiceVersion_ARRAYSIZE = ServiceVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceVersion_descriptor();
inline const ::std::string& ServiceVersion_Name(ServiceVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceVersion_descriptor(), value);
}
inline bool ServiceVersion_Parse(
    const ::std::string& name, ServiceVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceVersion>(
    ServiceVersion_descriptor(), name, value);
}
enum SafetyIdentifier {
  UNSPECIFIED_INTERCONNECT_SAFETY_IDENTIFIER = 0,
  MAXIMUM_MOTOR_CURRENT = 1,
  MAXIMUM_VOLTAGE = 2,
  MINIMUM_VOLTAGE = 4,
  MAXIMUM_MOTOR_TEMPERATURE = 8,
  MAXIMUM_CORE_TEMPERATURE = 16,
  NON_VOLATILE_MEMORY_CORRUPTED = 32,
  EMERGENCY_LINE_ASSERTED = 64,
  COMMUNICATION_TICK_LOST = 128,
  WATCHDOG_TRIGGERED = 256,
  SafetyIdentifier_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SafetyIdentifier_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SafetyIdentifier_IsValid(int value);
const SafetyIdentifier SafetyIdentifier_MIN = UNSPECIFIED_INTERCONNECT_SAFETY_IDENTIFIER;
const SafetyIdentifier SafetyIdentifier_MAX = WATCHDOG_TRIGGERED;
const int SafetyIdentifier_ARRAYSIZE = SafetyIdentifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* SafetyIdentifier_descriptor();
inline const ::std::string& SafetyIdentifier_Name(SafetyIdentifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    SafetyIdentifier_descriptor(), value);
}
inline bool SafetyIdentifier_Parse(
    const ::std::string& name, SafetyIdentifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SafetyIdentifier>(
    SafetyIdentifier_descriptor(), name, value);
}
enum UARTPortId {
  UART_PORT_UNSPECIFIED = 0,
  UART_PORT_EXPANSION = 1,
  UARTPortId_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UARTPortId_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UARTPortId_IsValid(int value);
const UARTPortId UARTPortId_MIN = UART_PORT_UNSPECIFIED;
const UARTPortId UARTPortId_MAX = UART_PORT_EXPANSION;
const int UARTPortId_ARRAYSIZE = UARTPortId_MAX + 1;

const ::google::protobuf::EnumDescriptor* UARTPortId_descriptor();
inline const ::std::string& UARTPortId_Name(UARTPortId value) {
  return ::google::protobuf::internal::NameOfEnum(
    UARTPortId_descriptor(), value);
}
inline bool UARTPortId_Parse(
    const ::std::string& name, UARTPortId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UARTPortId>(
    UARTPortId_descriptor(), name, value);
}
enum EthernetDevice {
  ETHERNET_DEVICE_UNSPECIFIED = 0,
  ETHERNET_DEVICE_EXPANSION = 1,
  EthernetDevice_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EthernetDevice_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EthernetDevice_IsValid(int value);
const EthernetDevice EthernetDevice_MIN = ETHERNET_DEVICE_UNSPECIFIED;
const EthernetDevice EthernetDevice_MAX = ETHERNET_DEVICE_EXPANSION;
const int EthernetDevice_ARRAYSIZE = EthernetDevice_MAX + 1;

const ::google::protobuf::EnumDescriptor* EthernetDevice_descriptor();
inline const ::std::string& EthernetDevice_Name(EthernetDevice value) {
  return ::google::protobuf::internal::NameOfEnum(
    EthernetDevice_descriptor(), value);
}
inline bool EthernetDevice_Parse(
    const ::std::string& name, EthernetDevice* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EthernetDevice>(
    EthernetDevice_descriptor(), name, value);
}
enum EthernetSpeed {
  ETHERNET_SPEED_UNSPECIFIED = 0,
  ETHERNET_SPEED_10M = 1,
  ETHERNET_SPEED_100M = 2,
  EthernetSpeed_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EthernetSpeed_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EthernetSpeed_IsValid(int value);
const EthernetSpeed EthernetSpeed_MIN = ETHERNET_SPEED_UNSPECIFIED;
const EthernetSpeed EthernetSpeed_MAX = ETHERNET_SPEED_100M;
const int EthernetSpeed_ARRAYSIZE = EthernetSpeed_MAX + 1;

const ::google::protobuf::EnumDescriptor* EthernetSpeed_descriptor();
inline const ::std::string& EthernetSpeed_Name(EthernetSpeed value) {
  return ::google::protobuf::internal::NameOfEnum(
    EthernetSpeed_descriptor(), value);
}
inline bool EthernetSpeed_Parse(
    const ::std::string& name, EthernetSpeed* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EthernetSpeed>(
    EthernetSpeed_descriptor(), name, value);
}
enum EthernetDuplex {
  ETHERNET_DUPLEX_UNSPECIFIED = 0,
  ETHERNET_DUPLEX_HALF = 1,
  ETHERNET_DUPLEX_FULL = 2,
  EthernetDuplex_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EthernetDuplex_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EthernetDuplex_IsValid(int value);
const EthernetDuplex EthernetDuplex_MIN = ETHERNET_DUPLEX_UNSPECIFIED;
const EthernetDuplex EthernetDuplex_MAX = ETHERNET_DUPLEX_FULL;
const int EthernetDuplex_ARRAYSIZE = EthernetDuplex_MAX + 1;

const ::google::protobuf::EnumDescriptor* EthernetDuplex_descriptor();
inline const ::std::string& EthernetDuplex_Name(EthernetDuplex value) {
  return ::google::protobuf::internal::NameOfEnum(
    EthernetDuplex_descriptor(), value);
}
inline bool EthernetDuplex_Parse(
    const ::std::string& name, EthernetDuplex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EthernetDuplex>(
    EthernetDuplex_descriptor(), name, value);
}
enum GPIOIdentifier {
  GPIO_IDENTIFIER_UNSPECIFIED = 0,
  GPIO_IDENTIFIER_1 = 1,
  GPIO_IDENTIFIER_2 = 2,
  GPIO_IDENTIFIER_3 = 3,
  GPIO_IDENTIFIER_4 = 4,
  GPIOIdentifier_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GPIOIdentifier_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GPIOIdentifier_IsValid(int value);
const GPIOIdentifier GPIOIdentifier_MIN = GPIO_IDENTIFIER_UNSPECIFIED;
const GPIOIdentifier GPIOIdentifier_MAX = GPIO_IDENTIFIER_4;
const int GPIOIdentifier_ARRAYSIZE = GPIOIdentifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* GPIOIdentifier_descriptor();
inline const ::std::string& GPIOIdentifier_Name(GPIOIdentifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    GPIOIdentifier_descriptor(), value);
}
inline bool GPIOIdentifier_Parse(
    const ::std::string& name, GPIOIdentifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GPIOIdentifier>(
    GPIOIdentifier_descriptor(), name, value);
}
enum GPIOMode {
  GPIO_MODE_UNSPECIFIED = 0,
  GPIO_MODE_INPUT_FLOATING = 1,
  GPIO_MODE_OUTPUT_PUSH_PULL = 2,
  GPIO_MODE_OUTPUT_OPEN_DRAIN = 3,
  GPIOMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GPIOMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GPIOMode_IsValid(int value);
const GPIOMode GPIOMode_MIN = GPIO_MODE_UNSPECIFIED;
const GPIOMode GPIOMode_MAX = GPIO_MODE_OUTPUT_OPEN_DRAIN;
const int GPIOMode_ARRAYSIZE = GPIOMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GPIOMode_descriptor();
inline const ::std::string& GPIOMode_Name(GPIOMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GPIOMode_descriptor(), value);
}
inline bool GPIOMode_Parse(
    const ::std::string& name, GPIOMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GPIOMode>(
    GPIOMode_descriptor(), name, value);
}
enum GPIOPull {
  GPIO_PULL_UNSPECIFIED = 0,
  GPIO_PULL_NONE = 1,
  GPIO_PULL_UP = 2,
  GPIO_PULL_DOWN = 3,
  GPIOPull_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GPIOPull_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GPIOPull_IsValid(int value);
const GPIOPull GPIOPull_MIN = GPIO_PULL_UNSPECIFIED;
const GPIOPull GPIOPull_MAX = GPIO_PULL_DOWN;
const int GPIOPull_ARRAYSIZE = GPIOPull_MAX + 1;

const ::google::protobuf::EnumDescriptor* GPIOPull_descriptor();
inline const ::std::string& GPIOPull_Name(GPIOPull value) {
  return ::google::protobuf::internal::NameOfEnum(
    GPIOPull_descriptor(), value);
}
inline bool GPIOPull_Parse(
    const ::std::string& name, GPIOPull* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GPIOPull>(
    GPIOPull_descriptor(), name, value);
}
enum GPIOValue {
  GPIO_VALUE_UNSPECIFIED = 0,
  GPIO_VALUE_LOW = 1,
  GPIO_VALUE_HIGH = 2,
  GPIOValue_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GPIOValue_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GPIOValue_IsValid(int value);
const GPIOValue GPIOValue_MIN = GPIO_VALUE_UNSPECIFIED;
const GPIOValue GPIOValue_MAX = GPIO_VALUE_HIGH;
const int GPIOValue_ARRAYSIZE = GPIOValue_MAX + 1;

const ::google::protobuf::EnumDescriptor* GPIOValue_descriptor();
inline const ::std::string& GPIOValue_Name(GPIOValue value) {
  return ::google::protobuf::internal::NameOfEnum(
    GPIOValue_descriptor(), value);
}
inline bool GPIOValue_Parse(
    const ::std::string& name, GPIOValue* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GPIOValue>(
    GPIOValue_descriptor(), name, value);
}
enum I2CDevice {
  I2C_DEVICE_UNSPECIFIED = 0,
  I2C_DEVICE_EXPANSION = 1,
  I2CDevice_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  I2CDevice_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool I2CDevice_IsValid(int value);
const I2CDevice I2CDevice_MIN = I2C_DEVICE_UNSPECIFIED;
const I2CDevice I2CDevice_MAX = I2C_DEVICE_EXPANSION;
const int I2CDevice_ARRAYSIZE = I2CDevice_MAX + 1;

const ::google::protobuf::EnumDescriptor* I2CDevice_descriptor();
inline const ::std::string& I2CDevice_Name(I2CDevice value) {
  return ::google::protobuf::internal::NameOfEnum(
    I2CDevice_descriptor(), value);
}
inline bool I2CDevice_Parse(
    const ::std::string& name, I2CDevice* value) {
  return ::google::protobuf::internal::ParseNamedEnum<I2CDevice>(
    I2CDevice_descriptor(), name, value);
}
enum I2CMode {
  I2C_MODE_UNSPECIFIED = 0,
  I2C_MODE_STANDARD = 1,
  I2C_MODE_FAST = 2,
  I2C_MODE_FAST_PLUS = 3,
  I2CMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  I2CMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool I2CMode_IsValid(int value);
const I2CMode I2CMode_MIN = I2C_MODE_UNSPECIFIED;
const I2CMode I2CMode_MAX = I2C_MODE_FAST_PLUS;
const int I2CMode_ARRAYSIZE = I2CMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* I2CMode_descriptor();
inline const ::std::string& I2CMode_Name(I2CMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    I2CMode_descriptor(), value);
}
inline bool I2CMode_Parse(
    const ::std::string& name, I2CMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<I2CMode>(
    I2CMode_descriptor(), name, value);
}
enum I2CDeviceAddressing {
  I2C_DEVICE_ADDRESSING_UNSPECIFIED = 0,
  I2C_DEVICE_ADDRESSING_7_BITS = 1,
  I2C_DEVICE_ADDRESSING_10_BITS = 2,
  I2CDeviceAddressing_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  I2CDeviceAddressing_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool I2CDeviceAddressing_IsValid(int value);
const I2CDeviceAddressing I2CDeviceAddressing_MIN = I2C_DEVICE_ADDRESSING_UNSPECIFIED;
const I2CDeviceAddressing I2CDeviceAddressing_MAX = I2C_DEVICE_ADDRESSING_10_BITS;
const int I2CDeviceAddressing_ARRAYSIZE = I2CDeviceAddressing_MAX + 1;

const ::google::protobuf::EnumDescriptor* I2CDeviceAddressing_descriptor();
inline const ::std::string& I2CDeviceAddressing_Name(I2CDeviceAddressing value) {
  return ::google::protobuf::internal::NameOfEnum(
    I2CDeviceAddressing_descriptor(), value);
}
inline bool I2CDeviceAddressing_Parse(
    const ::std::string& name, I2CDeviceAddressing* value) {
  return ::google::protobuf::internal::ParseNamedEnum<I2CDeviceAddressing>(
    I2CDeviceAddressing_descriptor(), name, value);
}
enum I2CRegisterAddressSize {
  I2C_REGISTER_ADDRESS_SIZE_UNSPECIFIED = 0,
  I2C_REGISTER_ADDRESS_SIZE_8_BITS = 1,
  I2C_REGISTER_ADDRESS_SIZE_16_BITS = 2,
  I2CRegisterAddressSize_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  I2CRegisterAddressSize_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool I2CRegisterAddressSize_IsValid(int value);
const I2CRegisterAddressSize I2CRegisterAddressSize_MIN = I2C_REGISTER_ADDRESS_SIZE_UNSPECIFIED;
const I2CRegisterAddressSize I2CRegisterAddressSize_MAX = I2C_REGISTER_ADDRESS_SIZE_16_BITS;
const int I2CRegisterAddressSize_ARRAYSIZE = I2CRegisterAddressSize_MAX + 1;

const ::google::protobuf::EnumDescriptor* I2CRegisterAddressSize_descriptor();
inline const ::std::string& I2CRegisterAddressSize_Name(I2CRegisterAddressSize value) {
  return ::google::protobuf::internal::NameOfEnum(
    I2CRegisterAddressSize_descriptor(), value);
}
inline bool I2CRegisterAddressSize_Parse(
    const ::std::string& name, I2CRegisterAddressSize* value) {
  return ::google::protobuf::internal::ParseNamedEnum<I2CRegisterAddressSize>(
    I2CRegisterAddressSize_descriptor(), name, value);
}
// ===================================================================

class EthernetDeviceIdentification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.InterconnectConfig.EthernetDeviceIdentification) */ {
 public:
  EthernetDeviceIdentification();
  virtual ~EthernetDeviceIdentification();

  EthernetDeviceIdentification(const EthernetDeviceIdentification& from);

  inline EthernetDeviceIdentification& operator=(const EthernetDeviceIdentification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EthernetDeviceIdentification(EthernetDeviceIdentification&& from) noexcept
    : EthernetDeviceIdentification() {
    *this = ::std::move(from);
  }

  inline EthernetDeviceIdentification& operator=(EthernetDeviceIdentification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EthernetDeviceIdentification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EthernetDeviceIdentification* internal_default_instance() {
    return reinterpret_cast<const EthernetDeviceIdentification*>(
               &_EthernetDeviceIdentification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(EthernetDeviceIdentification* other);
  friend void swap(EthernetDeviceIdentification& a, EthernetDeviceIdentification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EthernetDeviceIdentification* New() const PROTOBUF_FINAL { return New(NULL); }

  EthernetDeviceIdentification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EthernetDeviceIdentification& from);
  void MergeFrom(const EthernetDeviceIdentification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EthernetDeviceIdentification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.InterconnectConfig.EthernetDevice device = 1;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  ::Kinova::Api::InterconnectConfig::EthernetDevice device() const;
  void set_device(::Kinova::Api::InterconnectConfig::EthernetDevice value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.InterconnectConfig.EthernetDeviceIdentification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int device_;
  mutable int _cached_size_;
  friend struct ::protobuf_InterconnectConfig_2eproto::TableStruct;
  friend void ::protobuf_InterconnectConfig_2eproto::InitDefaultsEthernetDeviceIdentificationImpl();
};
// -------------------------------------------------------------------

class EthernetConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.InterconnectConfig.EthernetConfiguration) */ {
 public:
  EthernetConfiguration();
  virtual ~EthernetConfiguration();

  EthernetConfiguration(const EthernetConfiguration& from);

  inline EthernetConfiguration& operator=(const EthernetConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EthernetConfiguration(EthernetConfiguration&& from) noexcept
    : EthernetConfiguration() {
    *this = ::std::move(from);
  }

  inline EthernetConfiguration& operator=(EthernetConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EthernetConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EthernetConfiguration* internal_default_instance() {
    return reinterpret_cast<const EthernetConfiguration*>(
               &_EthernetConfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(EthernetConfiguration* other);
  friend void swap(EthernetConfiguration& a, EthernetConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EthernetConfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  EthernetConfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EthernetConfiguration& from);
  void MergeFrom(const EthernetConfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EthernetConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.InterconnectConfig.EthernetDevice device = 1;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  ::Kinova::Api::InterconnectConfig::EthernetDevice device() const;
  void set_device(::Kinova::Api::InterconnectConfig::EthernetDevice value);

  // bool enabled = 2;
  void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  bool enabled() const;
  void set_enabled(bool value);

  // .Kinova.Api.InterconnectConfig.EthernetSpeed speed = 3;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  ::Kinova::Api::InterconnectConfig::EthernetSpeed speed() const;
  void set_speed(::Kinova::Api::InterconnectConfig::EthernetSpeed value);

  // .Kinova.Api.InterconnectConfig.EthernetDuplex duplex = 4;
  void clear_duplex();
  static const int kDuplexFieldNumber = 4;
  ::Kinova::Api::InterconnectConfig::EthernetDuplex duplex() const;
  void set_duplex(::Kinova::Api::InterconnectConfig::EthernetDuplex value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.InterconnectConfig.EthernetConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int device_;
  bool enabled_;
  int speed_;
  int duplex_;
  mutable int _cached_size_;
  friend struct ::protobuf_InterconnectConfig_2eproto::TableStruct;
  friend void ::protobuf_InterconnectConfig_2eproto::InitDefaultsEthernetConfigurationImpl();
};
// -------------------------------------------------------------------

class GPIOIdentification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.InterconnectConfig.GPIOIdentification) */ {
 public:
  GPIOIdentification();
  virtual ~GPIOIdentification();

  GPIOIdentification(const GPIOIdentification& from);

  inline GPIOIdentification& operator=(const GPIOIdentification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GPIOIdentification(GPIOIdentification&& from) noexcept
    : GPIOIdentification() {
    *this = ::std::move(from);
  }

  inline GPIOIdentification& operator=(GPIOIdentification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPIOIdentification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GPIOIdentification* internal_default_instance() {
    return reinterpret_cast<const GPIOIdentification*>(
               &_GPIOIdentification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(GPIOIdentification* other);
  friend void swap(GPIOIdentification& a, GPIOIdentification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GPIOIdentification* New() const PROTOBUF_FINAL { return New(NULL); }

  GPIOIdentification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GPIOIdentification& from);
  void MergeFrom(const GPIOIdentification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GPIOIdentification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.InterconnectConfig.GPIOIdentifier identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::Kinova::Api::InterconnectConfig::GPIOIdentifier identifier() const;
  void set_identifier(::Kinova::Api::InterconnectConfig::GPIOIdentifier value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.InterconnectConfig.GPIOIdentification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int identifier_;
  mutable int _cached_size_;
  friend struct ::protobuf_InterconnectConfig_2eproto::TableStruct;
  friend void ::protobuf_InterconnectConfig_2eproto::InitDefaultsGPIOIdentificationImpl();
};
// -------------------------------------------------------------------

class GPIOConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.InterconnectConfig.GPIOConfiguration) */ {
 public:
  GPIOConfiguration();
  virtual ~GPIOConfiguration();

  GPIOConfiguration(const GPIOConfiguration& from);

  inline GPIOConfiguration& operator=(const GPIOConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GPIOConfiguration(GPIOConfiguration&& from) noexcept
    : GPIOConfiguration() {
    *this = ::std::move(from);
  }

  inline GPIOConfiguration& operator=(GPIOConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPIOConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GPIOConfiguration* internal_default_instance() {
    return reinterpret_cast<const GPIOConfiguration*>(
               &_GPIOConfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(GPIOConfiguration* other);
  friend void swap(GPIOConfiguration& a, GPIOConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GPIOConfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  GPIOConfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GPIOConfiguration& from);
  void MergeFrom(const GPIOConfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GPIOConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.InterconnectConfig.GPIOIdentifier identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::Kinova::Api::InterconnectConfig::GPIOIdentifier identifier() const;
  void set_identifier(::Kinova::Api::InterconnectConfig::GPIOIdentifier value);

  // .Kinova.Api.InterconnectConfig.GPIOMode mode = 2;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  ::Kinova::Api::InterconnectConfig::GPIOMode mode() const;
  void set_mode(::Kinova::Api::InterconnectConfig::GPIOMode value);

  // .Kinova.Api.InterconnectConfig.GPIOPull pull = 3;
  void clear_pull();
  static const int kPullFieldNumber = 3;
  ::Kinova::Api::InterconnectConfig::GPIOPull pull() const;
  void set_pull(::Kinova::Api::InterconnectConfig::GPIOPull value);

  // .Kinova.Api.InterconnectConfig.GPIOValue default_value = 4;
  void clear_default_value();
  static const int kDefaultValueFieldNumber = 4;
  ::Kinova::Api::InterconnectConfig::GPIOValue default_value() const;
  void set_default_value(::Kinova::Api::InterconnectConfig::GPIOValue value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.InterconnectConfig.GPIOConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int identifier_;
  int mode_;
  int pull_;
  int default_value_;
  mutable int _cached_size_;
  friend struct ::protobuf_InterconnectConfig_2eproto::TableStruct;
  friend void ::protobuf_InterconnectConfig_2eproto::InitDefaultsGPIOConfigurationImpl();
};
// -------------------------------------------------------------------

class GPIOState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.InterconnectConfig.GPIOState) */ {
 public:
  GPIOState();
  virtual ~GPIOState();

  GPIOState(const GPIOState& from);

  inline GPIOState& operator=(const GPIOState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GPIOState(GPIOState&& from) noexcept
    : GPIOState() {
    *this = ::std::move(from);
  }

  inline GPIOState& operator=(GPIOState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPIOState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GPIOState* internal_default_instance() {
    return reinterpret_cast<const GPIOState*>(
               &_GPIOState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(GPIOState* other);
  friend void swap(GPIOState& a, GPIOState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GPIOState* New() const PROTOBUF_FINAL { return New(NULL); }

  GPIOState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GPIOState& from);
  void MergeFrom(const GPIOState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GPIOState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.InterconnectConfig.GPIOIdentifier identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  ::Kinova::Api::InterconnectConfig::GPIOIdentifier identifier() const;
  void set_identifier(::Kinova::Api::InterconnectConfig::GPIOIdentifier value);

  // .Kinova.Api.InterconnectConfig.GPIOValue value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::Kinova::Api::InterconnectConfig::GPIOValue value() const;
  void set_value(::Kinova::Api::InterconnectConfig::GPIOValue value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.InterconnectConfig.GPIOState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int identifier_;
  int value_;
  mutable int _cached_size_;
  friend struct ::protobuf_InterconnectConfig_2eproto::TableStruct;
  friend void ::protobuf_InterconnectConfig_2eproto::InitDefaultsGPIOStateImpl();
};
// -------------------------------------------------------------------

class I2CDeviceIdentification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.InterconnectConfig.I2CDeviceIdentification) */ {
 public:
  I2CDeviceIdentification();
  virtual ~I2CDeviceIdentification();

  I2CDeviceIdentification(const I2CDeviceIdentification& from);

  inline I2CDeviceIdentification& operator=(const I2CDeviceIdentification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  I2CDeviceIdentification(I2CDeviceIdentification&& from) noexcept
    : I2CDeviceIdentification() {
    *this = ::std::move(from);
  }

  inline I2CDeviceIdentification& operator=(I2CDeviceIdentification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const I2CDeviceIdentification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const I2CDeviceIdentification* internal_default_instance() {
    return reinterpret_cast<const I2CDeviceIdentification*>(
               &_I2CDeviceIdentification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(I2CDeviceIdentification* other);
  friend void swap(I2CDeviceIdentification& a, I2CDeviceIdentification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline I2CDeviceIdentification* New() const PROTOBUF_FINAL { return New(NULL); }

  I2CDeviceIdentification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const I2CDeviceIdentification& from);
  void MergeFrom(const I2CDeviceIdentification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(I2CDeviceIdentification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.InterconnectConfig.I2CDevice device = 1;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  ::Kinova::Api::InterconnectConfig::I2CDevice device() const;
  void set_device(::Kinova::Api::InterconnectConfig::I2CDevice value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.InterconnectConfig.I2CDeviceIdentification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int device_;
  mutable int _cached_size_;
  friend struct ::protobuf_InterconnectConfig_2eproto::TableStruct;
  friend void ::protobuf_InterconnectConfig_2eproto::InitDefaultsI2CDeviceIdentificationImpl();
};
// -------------------------------------------------------------------

class I2CConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.InterconnectConfig.I2CConfiguration) */ {
 public:
  I2CConfiguration();
  virtual ~I2CConfiguration();

  I2CConfiguration(const I2CConfiguration& from);

  inline I2CConfiguration& operator=(const I2CConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  I2CConfiguration(I2CConfiguration&& from) noexcept
    : I2CConfiguration() {
    *this = ::std::move(from);
  }

  inline I2CConfiguration& operator=(I2CConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const I2CConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const I2CConfiguration* internal_default_instance() {
    return reinterpret_cast<const I2CConfiguration*>(
               &_I2CConfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(I2CConfiguration* other);
  friend void swap(I2CConfiguration& a, I2CConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline I2CConfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  I2CConfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const I2CConfiguration& from);
  void MergeFrom(const I2CConfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(I2CConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.InterconnectConfig.I2CDevice device = 1;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  ::Kinova::Api::InterconnectConfig::I2CDevice device() const;
  void set_device(::Kinova::Api::InterconnectConfig::I2CDevice value);

  // bool enabled = 2;
  void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  bool enabled() const;
  void set_enabled(bool value);

  // .Kinova.Api.InterconnectConfig.I2CMode mode = 3;
  void clear_mode();
  static const int kModeFieldNumber = 3;
  ::Kinova::Api::InterconnectConfig::I2CMode mode() const;
  void set_mode(::Kinova::Api::InterconnectConfig::I2CMode value);

  // .Kinova.Api.InterconnectConfig.I2CDeviceAddressing addressing = 4;
  void clear_addressing();
  static const int kAddressingFieldNumber = 4;
  ::Kinova::Api::InterconnectConfig::I2CDeviceAddressing addressing() const;
  void set_addressing(::Kinova::Api::InterconnectConfig::I2CDeviceAddressing value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.InterconnectConfig.I2CConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int device_;
  bool enabled_;
  int mode_;
  int addressing_;
  mutable int _cached_size_;
  friend struct ::protobuf_InterconnectConfig_2eproto::TableStruct;
  friend void ::protobuf_InterconnectConfig_2eproto::InitDefaultsI2CConfigurationImpl();
};
// -------------------------------------------------------------------

class I2CReadParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.InterconnectConfig.I2CReadParameter) */ {
 public:
  I2CReadParameter();
  virtual ~I2CReadParameter();

  I2CReadParameter(const I2CReadParameter& from);

  inline I2CReadParameter& operator=(const I2CReadParameter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  I2CReadParameter(I2CReadParameter&& from) noexcept
    : I2CReadParameter() {
    *this = ::std::move(from);
  }

  inline I2CReadParameter& operator=(I2CReadParameter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const I2CReadParameter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const I2CReadParameter* internal_default_instance() {
    return reinterpret_cast<const I2CReadParameter*>(
               &_I2CReadParameter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(I2CReadParameter* other);
  friend void swap(I2CReadParameter& a, I2CReadParameter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline I2CReadParameter* New() const PROTOBUF_FINAL { return New(NULL); }

  I2CReadParameter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const I2CReadParameter& from);
  void MergeFrom(const I2CReadParameter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(I2CReadParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.InterconnectConfig.I2CDevice device = 1;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  ::Kinova::Api::InterconnectConfig::I2CDevice device() const;
  void set_device(::Kinova::Api::InterconnectConfig::I2CDevice value);

  // fixed32 device_address = 2;
  void clear_device_address();
  static const int kDeviceAddressFieldNumber = 2;
  ::google::protobuf::uint32 device_address() const;
  void set_device_address(::google::protobuf::uint32 value);

  // fixed32 size = 5;
  void clear_size();
  static const int kSizeFieldNumber = 5;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // fixed32 timeout = 6;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 6;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.InterconnectConfig.I2CReadParameter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int device_;
  ::google::protobuf::uint32 device_address_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::uint32 timeout_;
  mutable int _cached_size_;
  friend struct ::protobuf_InterconnectConfig_2eproto::TableStruct;
  friend void ::protobuf_InterconnectConfig_2eproto::InitDefaultsI2CReadParameterImpl();
};
// -------------------------------------------------------------------

class I2CReadRegisterParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.InterconnectConfig.I2CReadRegisterParameter) */ {
 public:
  I2CReadRegisterParameter();
  virtual ~I2CReadRegisterParameter();

  I2CReadRegisterParameter(const I2CReadRegisterParameter& from);

  inline I2CReadRegisterParameter& operator=(const I2CReadRegisterParameter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  I2CReadRegisterParameter(I2CReadRegisterParameter&& from) noexcept
    : I2CReadRegisterParameter() {
    *this = ::std::move(from);
  }

  inline I2CReadRegisterParameter& operator=(I2CReadRegisterParameter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const I2CReadRegisterParameter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const I2CReadRegisterParameter* internal_default_instance() {
    return reinterpret_cast<const I2CReadRegisterParameter*>(
               &_I2CReadRegisterParameter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(I2CReadRegisterParameter* other);
  friend void swap(I2CReadRegisterParameter& a, I2CReadRegisterParameter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline I2CReadRegisterParameter* New() const PROTOBUF_FINAL { return New(NULL); }

  I2CReadRegisterParameter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const I2CReadRegisterParameter& from);
  void MergeFrom(const I2CReadRegisterParameter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(I2CReadRegisterParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.InterconnectConfig.I2CDevice device = 1;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  ::Kinova::Api::InterconnectConfig::I2CDevice device() const;
  void set_device(::Kinova::Api::InterconnectConfig::I2CDevice value);

  // fixed32 device_address = 2;
  void clear_device_address();
  static const int kDeviceAddressFieldNumber = 2;
  ::google::protobuf::uint32 device_address() const;
  void set_device_address(::google::protobuf::uint32 value);

  // fixed32 register_address = 3;
  void clear_register_address();
  static const int kRegisterAddressFieldNumber = 3;
  ::google::protobuf::uint32 register_address() const;
  void set_register_address(::google::protobuf::uint32 value);

  // .Kinova.Api.InterconnectConfig.I2CRegisterAddressSize register_address_size = 4;
  void clear_register_address_size();
  static const int kRegisterAddressSizeFieldNumber = 4;
  ::Kinova::Api::InterconnectConfig::I2CRegisterAddressSize register_address_size() const;
  void set_register_address_size(::Kinova::Api::InterconnectConfig::I2CRegisterAddressSize value);

  // fixed32 size = 5;
  void clear_size();
  static const int kSizeFieldNumber = 5;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // fixed32 timeout = 6;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 6;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.InterconnectConfig.I2CReadRegisterParameter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int device_;
  ::google::protobuf::uint32 device_address_;
  ::google::protobuf::uint32 register_address_;
  int register_address_size_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::uint32 timeout_;
  mutable int _cached_size_;
  friend struct ::protobuf_InterconnectConfig_2eproto::TableStruct;
  friend void ::protobuf_InterconnectConfig_2eproto::InitDefaultsI2CReadRegisterParameterImpl();
};
// -------------------------------------------------------------------

class I2CWriteParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.InterconnectConfig.I2CWriteParameter) */ {
 public:
  I2CWriteParameter();
  virtual ~I2CWriteParameter();

  I2CWriteParameter(const I2CWriteParameter& from);

  inline I2CWriteParameter& operator=(const I2CWriteParameter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  I2CWriteParameter(I2CWriteParameter&& from) noexcept
    : I2CWriteParameter() {
    *this = ::std::move(from);
  }

  inline I2CWriteParameter& operator=(I2CWriteParameter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const I2CWriteParameter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const I2CWriteParameter* internal_default_instance() {
    return reinterpret_cast<const I2CWriteParameter*>(
               &_I2CWriteParameter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(I2CWriteParameter* other);
  friend void swap(I2CWriteParameter& a, I2CWriteParameter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline I2CWriteParameter* New() const PROTOBUF_FINAL { return New(NULL); }

  I2CWriteParameter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const I2CWriteParameter& from);
  void MergeFrom(const I2CWriteParameter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(I2CWriteParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.InterconnectConfig.I2CData data = 6;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 6;
  const ::Kinova::Api::InterconnectConfig::I2CData& data() const;
  ::Kinova::Api::InterconnectConfig::I2CData* release_data();
  ::Kinova::Api::InterconnectConfig::I2CData* mutable_data();
  void set_allocated_data(::Kinova::Api::InterconnectConfig::I2CData* data);

  // .Kinova.Api.InterconnectConfig.I2CDevice device = 1;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  ::Kinova::Api::InterconnectConfig::I2CDevice device() const;
  void set_device(::Kinova::Api::InterconnectConfig::I2CDevice value);

  // fixed32 device_address = 2;
  void clear_device_address();
  static const int kDeviceAddressFieldNumber = 2;
  ::google::protobuf::uint32 device_address() const;
  void set_device_address(::google::protobuf::uint32 value);

  // fixed32 timeout = 5;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 5;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.InterconnectConfig.I2CWriteParameter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::InterconnectConfig::I2CData* data_;
  int device_;
  ::google::protobuf::uint32 device_address_;
  ::google::protobuf::uint32 timeout_;
  mutable int _cached_size_;
  friend struct ::protobuf_InterconnectConfig_2eproto::TableStruct;
  friend void ::protobuf_InterconnectConfig_2eproto::InitDefaultsI2CWriteParameterImpl();
};
// -------------------------------------------------------------------

class I2CWriteRegisterParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter) */ {
 public:
  I2CWriteRegisterParameter();
  virtual ~I2CWriteRegisterParameter();

  I2CWriteRegisterParameter(const I2CWriteRegisterParameter& from);

  inline I2CWriteRegisterParameter& operator=(const I2CWriteRegisterParameter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  I2CWriteRegisterParameter(I2CWriteRegisterParameter&& from) noexcept
    : I2CWriteRegisterParameter() {
    *this = ::std::move(from);
  }

  inline I2CWriteRegisterParameter& operator=(I2CWriteRegisterParameter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const I2CWriteRegisterParameter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const I2CWriteRegisterParameter* internal_default_instance() {
    return reinterpret_cast<const I2CWriteRegisterParameter*>(
               &_I2CWriteRegisterParameter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(I2CWriteRegisterParameter* other);
  friend void swap(I2CWriteRegisterParameter& a, I2CWriteRegisterParameter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline I2CWriteRegisterParameter* New() const PROTOBUF_FINAL { return New(NULL); }

  I2CWriteRegisterParameter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const I2CWriteRegisterParameter& from);
  void MergeFrom(const I2CWriteRegisterParameter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(I2CWriteRegisterParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Kinova.Api.InterconnectConfig.I2CData data = 6;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 6;
  const ::Kinova::Api::InterconnectConfig::I2CData& data() const;
  ::Kinova::Api::InterconnectConfig::I2CData* release_data();
  ::Kinova::Api::InterconnectConfig::I2CData* mutable_data();
  void set_allocated_data(::Kinova::Api::InterconnectConfig::I2CData* data);

  // .Kinova.Api.InterconnectConfig.I2CDevice device = 1;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  ::Kinova::Api::InterconnectConfig::I2CDevice device() const;
  void set_device(::Kinova::Api::InterconnectConfig::I2CDevice value);

  // fixed32 device_address = 2;
  void clear_device_address();
  static const int kDeviceAddressFieldNumber = 2;
  ::google::protobuf::uint32 device_address() const;
  void set_device_address(::google::protobuf::uint32 value);

  // fixed32 register_address = 3;
  void clear_register_address();
  static const int kRegisterAddressFieldNumber = 3;
  ::google::protobuf::uint32 register_address() const;
  void set_register_address(::google::protobuf::uint32 value);

  // .Kinova.Api.InterconnectConfig.I2CRegisterAddressSize register_address_size = 4;
  void clear_register_address_size();
  static const int kRegisterAddressSizeFieldNumber = 4;
  ::Kinova::Api::InterconnectConfig::I2CRegisterAddressSize register_address_size() const;
  void set_register_address_size(::Kinova::Api::InterconnectConfig::I2CRegisterAddressSize value);

  // fixed32 timeout = 5;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 5;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Kinova::Api::InterconnectConfig::I2CData* data_;
  int device_;
  ::google::protobuf::uint32 device_address_;
  ::google::protobuf::uint32 register_address_;
  int register_address_size_;
  ::google::protobuf::uint32 timeout_;
  mutable int _cached_size_;
  friend struct ::protobuf_InterconnectConfig_2eproto::TableStruct;
  friend void ::protobuf_InterconnectConfig_2eproto::InitDefaultsI2CWriteRegisterParameterImpl();
};
// -------------------------------------------------------------------

class I2CData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kinova.Api.InterconnectConfig.I2CData) */ {
 public:
  I2CData();
  virtual ~I2CData();

  I2CData(const I2CData& from);

  inline I2CData& operator=(const I2CData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  I2CData(I2CData&& from) noexcept
    : I2CData() {
    *this = ::std::move(from);
  }

  inline I2CData& operator=(I2CData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const I2CData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const I2CData* internal_default_instance() {
    return reinterpret_cast<const I2CData*>(
               &_I2CData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(I2CData* other);
  friend void swap(I2CData& a, I2CData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline I2CData* New() const PROTOBUF_FINAL { return New(NULL); }

  I2CData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const I2CData& from);
  void MergeFrom(const I2CData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(I2CData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // fixed32 size = 2;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Kinova.Api.InterconnectConfig.I2CData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 size_;
  mutable int _cached_size_;
  friend struct ::protobuf_InterconnectConfig_2eproto::TableStruct;
  friend void ::protobuf_InterconnectConfig_2eproto::InitDefaultsI2CDataImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EthernetDeviceIdentification

// .Kinova.Api.InterconnectConfig.EthernetDevice device = 1;
inline void EthernetDeviceIdentification::clear_device() {
  device_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::EthernetDevice EthernetDeviceIdentification::device() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.EthernetDeviceIdentification.device)
  return static_cast< ::Kinova::Api::InterconnectConfig::EthernetDevice >(device_);
}
inline void EthernetDeviceIdentification::set_device(::Kinova::Api::InterconnectConfig::EthernetDevice value) {
  
  device_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.EthernetDeviceIdentification.device)
}

// -------------------------------------------------------------------

// EthernetConfiguration

// .Kinova.Api.InterconnectConfig.EthernetDevice device = 1;
inline void EthernetConfiguration::clear_device() {
  device_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::EthernetDevice EthernetConfiguration::device() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.EthernetConfiguration.device)
  return static_cast< ::Kinova::Api::InterconnectConfig::EthernetDevice >(device_);
}
inline void EthernetConfiguration::set_device(::Kinova::Api::InterconnectConfig::EthernetDevice value) {
  
  device_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.EthernetConfiguration.device)
}

// bool enabled = 2;
inline void EthernetConfiguration::clear_enabled() {
  enabled_ = false;
}
inline bool EthernetConfiguration::enabled() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.EthernetConfiguration.enabled)
  return enabled_;
}
inline void EthernetConfiguration::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.EthernetConfiguration.enabled)
}

// .Kinova.Api.InterconnectConfig.EthernetSpeed speed = 3;
inline void EthernetConfiguration::clear_speed() {
  speed_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::EthernetSpeed EthernetConfiguration::speed() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.EthernetConfiguration.speed)
  return static_cast< ::Kinova::Api::InterconnectConfig::EthernetSpeed >(speed_);
}
inline void EthernetConfiguration::set_speed(::Kinova::Api::InterconnectConfig::EthernetSpeed value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.EthernetConfiguration.speed)
}

// .Kinova.Api.InterconnectConfig.EthernetDuplex duplex = 4;
inline void EthernetConfiguration::clear_duplex() {
  duplex_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::EthernetDuplex EthernetConfiguration::duplex() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.EthernetConfiguration.duplex)
  return static_cast< ::Kinova::Api::InterconnectConfig::EthernetDuplex >(duplex_);
}
inline void EthernetConfiguration::set_duplex(::Kinova::Api::InterconnectConfig::EthernetDuplex value) {
  
  duplex_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.EthernetConfiguration.duplex)
}

// -------------------------------------------------------------------

// GPIOIdentification

// .Kinova.Api.InterconnectConfig.GPIOIdentifier identifier = 1;
inline void GPIOIdentification::clear_identifier() {
  identifier_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::GPIOIdentifier GPIOIdentification::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.GPIOIdentification.identifier)
  return static_cast< ::Kinova::Api::InterconnectConfig::GPIOIdentifier >(identifier_);
}
inline void GPIOIdentification::set_identifier(::Kinova::Api::InterconnectConfig::GPIOIdentifier value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.GPIOIdentification.identifier)
}

// -------------------------------------------------------------------

// GPIOConfiguration

// .Kinova.Api.InterconnectConfig.GPIOIdentifier identifier = 1;
inline void GPIOConfiguration::clear_identifier() {
  identifier_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::GPIOIdentifier GPIOConfiguration::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.GPIOConfiguration.identifier)
  return static_cast< ::Kinova::Api::InterconnectConfig::GPIOIdentifier >(identifier_);
}
inline void GPIOConfiguration::set_identifier(::Kinova::Api::InterconnectConfig::GPIOIdentifier value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.GPIOConfiguration.identifier)
}

// .Kinova.Api.InterconnectConfig.GPIOMode mode = 2;
inline void GPIOConfiguration::clear_mode() {
  mode_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::GPIOMode GPIOConfiguration::mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.GPIOConfiguration.mode)
  return static_cast< ::Kinova::Api::InterconnectConfig::GPIOMode >(mode_);
}
inline void GPIOConfiguration::set_mode(::Kinova::Api::InterconnectConfig::GPIOMode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.GPIOConfiguration.mode)
}

// .Kinova.Api.InterconnectConfig.GPIOPull pull = 3;
inline void GPIOConfiguration::clear_pull() {
  pull_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::GPIOPull GPIOConfiguration::pull() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.GPIOConfiguration.pull)
  return static_cast< ::Kinova::Api::InterconnectConfig::GPIOPull >(pull_);
}
inline void GPIOConfiguration::set_pull(::Kinova::Api::InterconnectConfig::GPIOPull value) {
  
  pull_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.GPIOConfiguration.pull)
}

// .Kinova.Api.InterconnectConfig.GPIOValue default_value = 4;
inline void GPIOConfiguration::clear_default_value() {
  default_value_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::GPIOValue GPIOConfiguration::default_value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.GPIOConfiguration.default_value)
  return static_cast< ::Kinova::Api::InterconnectConfig::GPIOValue >(default_value_);
}
inline void GPIOConfiguration::set_default_value(::Kinova::Api::InterconnectConfig::GPIOValue value) {
  
  default_value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.GPIOConfiguration.default_value)
}

// -------------------------------------------------------------------

// GPIOState

// .Kinova.Api.InterconnectConfig.GPIOIdentifier identifier = 1;
inline void GPIOState::clear_identifier() {
  identifier_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::GPIOIdentifier GPIOState::identifier() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.GPIOState.identifier)
  return static_cast< ::Kinova::Api::InterconnectConfig::GPIOIdentifier >(identifier_);
}
inline void GPIOState::set_identifier(::Kinova::Api::InterconnectConfig::GPIOIdentifier value) {
  
  identifier_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.GPIOState.identifier)
}

// .Kinova.Api.InterconnectConfig.GPIOValue value = 2;
inline void GPIOState::clear_value() {
  value_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::GPIOValue GPIOState::value() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.GPIOState.value)
  return static_cast< ::Kinova::Api::InterconnectConfig::GPIOValue >(value_);
}
inline void GPIOState::set_value(::Kinova::Api::InterconnectConfig::GPIOValue value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.GPIOState.value)
}

// -------------------------------------------------------------------

// I2CDeviceIdentification

// .Kinova.Api.InterconnectConfig.I2CDevice device = 1;
inline void I2CDeviceIdentification::clear_device() {
  device_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::I2CDevice I2CDeviceIdentification::device() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CDeviceIdentification.device)
  return static_cast< ::Kinova::Api::InterconnectConfig::I2CDevice >(device_);
}
inline void I2CDeviceIdentification::set_device(::Kinova::Api::InterconnectConfig::I2CDevice value) {
  
  device_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CDeviceIdentification.device)
}

// -------------------------------------------------------------------

// I2CConfiguration

// .Kinova.Api.InterconnectConfig.I2CDevice device = 1;
inline void I2CConfiguration::clear_device() {
  device_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::I2CDevice I2CConfiguration::device() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CConfiguration.device)
  return static_cast< ::Kinova::Api::InterconnectConfig::I2CDevice >(device_);
}
inline void I2CConfiguration::set_device(::Kinova::Api::InterconnectConfig::I2CDevice value) {
  
  device_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CConfiguration.device)
}

// bool enabled = 2;
inline void I2CConfiguration::clear_enabled() {
  enabled_ = false;
}
inline bool I2CConfiguration::enabled() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CConfiguration.enabled)
  return enabled_;
}
inline void I2CConfiguration::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CConfiguration.enabled)
}

// .Kinova.Api.InterconnectConfig.I2CMode mode = 3;
inline void I2CConfiguration::clear_mode() {
  mode_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::I2CMode I2CConfiguration::mode() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CConfiguration.mode)
  return static_cast< ::Kinova::Api::InterconnectConfig::I2CMode >(mode_);
}
inline void I2CConfiguration::set_mode(::Kinova::Api::InterconnectConfig::I2CMode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CConfiguration.mode)
}

// .Kinova.Api.InterconnectConfig.I2CDeviceAddressing addressing = 4;
inline void I2CConfiguration::clear_addressing() {
  addressing_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::I2CDeviceAddressing I2CConfiguration::addressing() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CConfiguration.addressing)
  return static_cast< ::Kinova::Api::InterconnectConfig::I2CDeviceAddressing >(addressing_);
}
inline void I2CConfiguration::set_addressing(::Kinova::Api::InterconnectConfig::I2CDeviceAddressing value) {
  
  addressing_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CConfiguration.addressing)
}

// -------------------------------------------------------------------

// I2CReadParameter

// .Kinova.Api.InterconnectConfig.I2CDevice device = 1;
inline void I2CReadParameter::clear_device() {
  device_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::I2CDevice I2CReadParameter::device() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CReadParameter.device)
  return static_cast< ::Kinova::Api::InterconnectConfig::I2CDevice >(device_);
}
inline void I2CReadParameter::set_device(::Kinova::Api::InterconnectConfig::I2CDevice value) {
  
  device_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CReadParameter.device)
}

// fixed32 device_address = 2;
inline void I2CReadParameter::clear_device_address() {
  device_address_ = 0u;
}
inline ::google::protobuf::uint32 I2CReadParameter::device_address() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CReadParameter.device_address)
  return device_address_;
}
inline void I2CReadParameter::set_device_address(::google::protobuf::uint32 value) {
  
  device_address_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CReadParameter.device_address)
}

// fixed32 size = 5;
inline void I2CReadParameter::clear_size() {
  size_ = 0u;
}
inline ::google::protobuf::uint32 I2CReadParameter::size() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CReadParameter.size)
  return size_;
}
inline void I2CReadParameter::set_size(::google::protobuf::uint32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CReadParameter.size)
}

// fixed32 timeout = 6;
inline void I2CReadParameter::clear_timeout() {
  timeout_ = 0u;
}
inline ::google::protobuf::uint32 I2CReadParameter::timeout() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CReadParameter.timeout)
  return timeout_;
}
inline void I2CReadParameter::set_timeout(::google::protobuf::uint32 value) {
  
  timeout_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CReadParameter.timeout)
}

// -------------------------------------------------------------------

// I2CReadRegisterParameter

// .Kinova.Api.InterconnectConfig.I2CDevice device = 1;
inline void I2CReadRegisterParameter::clear_device() {
  device_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::I2CDevice I2CReadRegisterParameter::device() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CReadRegisterParameter.device)
  return static_cast< ::Kinova::Api::InterconnectConfig::I2CDevice >(device_);
}
inline void I2CReadRegisterParameter::set_device(::Kinova::Api::InterconnectConfig::I2CDevice value) {
  
  device_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CReadRegisterParameter.device)
}

// fixed32 device_address = 2;
inline void I2CReadRegisterParameter::clear_device_address() {
  device_address_ = 0u;
}
inline ::google::protobuf::uint32 I2CReadRegisterParameter::device_address() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CReadRegisterParameter.device_address)
  return device_address_;
}
inline void I2CReadRegisterParameter::set_device_address(::google::protobuf::uint32 value) {
  
  device_address_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CReadRegisterParameter.device_address)
}

// fixed32 register_address = 3;
inline void I2CReadRegisterParameter::clear_register_address() {
  register_address_ = 0u;
}
inline ::google::protobuf::uint32 I2CReadRegisterParameter::register_address() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CReadRegisterParameter.register_address)
  return register_address_;
}
inline void I2CReadRegisterParameter::set_register_address(::google::protobuf::uint32 value) {
  
  register_address_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CReadRegisterParameter.register_address)
}

// .Kinova.Api.InterconnectConfig.I2CRegisterAddressSize register_address_size = 4;
inline void I2CReadRegisterParameter::clear_register_address_size() {
  register_address_size_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::I2CRegisterAddressSize I2CReadRegisterParameter::register_address_size() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CReadRegisterParameter.register_address_size)
  return static_cast< ::Kinova::Api::InterconnectConfig::I2CRegisterAddressSize >(register_address_size_);
}
inline void I2CReadRegisterParameter::set_register_address_size(::Kinova::Api::InterconnectConfig::I2CRegisterAddressSize value) {
  
  register_address_size_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CReadRegisterParameter.register_address_size)
}

// fixed32 size = 5;
inline void I2CReadRegisterParameter::clear_size() {
  size_ = 0u;
}
inline ::google::protobuf::uint32 I2CReadRegisterParameter::size() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CReadRegisterParameter.size)
  return size_;
}
inline void I2CReadRegisterParameter::set_size(::google::protobuf::uint32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CReadRegisterParameter.size)
}

// fixed32 timeout = 6;
inline void I2CReadRegisterParameter::clear_timeout() {
  timeout_ = 0u;
}
inline ::google::protobuf::uint32 I2CReadRegisterParameter::timeout() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CReadRegisterParameter.timeout)
  return timeout_;
}
inline void I2CReadRegisterParameter::set_timeout(::google::protobuf::uint32 value) {
  
  timeout_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CReadRegisterParameter.timeout)
}

// -------------------------------------------------------------------

// I2CWriteParameter

// .Kinova.Api.InterconnectConfig.I2CDevice device = 1;
inline void I2CWriteParameter::clear_device() {
  device_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::I2CDevice I2CWriteParameter::device() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CWriteParameter.device)
  return static_cast< ::Kinova::Api::InterconnectConfig::I2CDevice >(device_);
}
inline void I2CWriteParameter::set_device(::Kinova::Api::InterconnectConfig::I2CDevice value) {
  
  device_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CWriteParameter.device)
}

// fixed32 device_address = 2;
inline void I2CWriteParameter::clear_device_address() {
  device_address_ = 0u;
}
inline ::google::protobuf::uint32 I2CWriteParameter::device_address() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CWriteParameter.device_address)
  return device_address_;
}
inline void I2CWriteParameter::set_device_address(::google::protobuf::uint32 value) {
  
  device_address_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CWriteParameter.device_address)
}

// fixed32 timeout = 5;
inline void I2CWriteParameter::clear_timeout() {
  timeout_ = 0u;
}
inline ::google::protobuf::uint32 I2CWriteParameter::timeout() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CWriteParameter.timeout)
  return timeout_;
}
inline void I2CWriteParameter::set_timeout(::google::protobuf::uint32 value) {
  
  timeout_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CWriteParameter.timeout)
}

// .Kinova.Api.InterconnectConfig.I2CData data = 6;
inline bool I2CWriteParameter::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline void I2CWriteParameter::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) {
    delete data_;
  }
  data_ = NULL;
}
inline const ::Kinova::Api::InterconnectConfig::I2CData& I2CWriteParameter::data() const {
  const ::Kinova::Api::InterconnectConfig::I2CData* p = data_;
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CWriteParameter.data)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::InterconnectConfig::I2CData*>(
      &::Kinova::Api::InterconnectConfig::_I2CData_default_instance_);
}
inline ::Kinova::Api::InterconnectConfig::I2CData* I2CWriteParameter::release_data() {
  // @@protoc_insertion_point(field_release:Kinova.Api.InterconnectConfig.I2CWriteParameter.data)
  
  ::Kinova::Api::InterconnectConfig::I2CData* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::Kinova::Api::InterconnectConfig::I2CData* I2CWriteParameter::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::Kinova::Api::InterconnectConfig::I2CData;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.InterconnectConfig.I2CWriteParameter.data)
  return data_;
}
inline void I2CWriteParameter::set_allocated_data(::Kinova::Api::InterconnectConfig::I2CData* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_;
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.InterconnectConfig.I2CWriteParameter.data)
}

// -------------------------------------------------------------------

// I2CWriteRegisterParameter

// .Kinova.Api.InterconnectConfig.I2CDevice device = 1;
inline void I2CWriteRegisterParameter::clear_device() {
  device_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::I2CDevice I2CWriteRegisterParameter::device() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter.device)
  return static_cast< ::Kinova::Api::InterconnectConfig::I2CDevice >(device_);
}
inline void I2CWriteRegisterParameter::set_device(::Kinova::Api::InterconnectConfig::I2CDevice value) {
  
  device_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter.device)
}

// fixed32 device_address = 2;
inline void I2CWriteRegisterParameter::clear_device_address() {
  device_address_ = 0u;
}
inline ::google::protobuf::uint32 I2CWriteRegisterParameter::device_address() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter.device_address)
  return device_address_;
}
inline void I2CWriteRegisterParameter::set_device_address(::google::protobuf::uint32 value) {
  
  device_address_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter.device_address)
}

// fixed32 register_address = 3;
inline void I2CWriteRegisterParameter::clear_register_address() {
  register_address_ = 0u;
}
inline ::google::protobuf::uint32 I2CWriteRegisterParameter::register_address() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter.register_address)
  return register_address_;
}
inline void I2CWriteRegisterParameter::set_register_address(::google::protobuf::uint32 value) {
  
  register_address_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter.register_address)
}

// .Kinova.Api.InterconnectConfig.I2CRegisterAddressSize register_address_size = 4;
inline void I2CWriteRegisterParameter::clear_register_address_size() {
  register_address_size_ = 0;
}
inline ::Kinova::Api::InterconnectConfig::I2CRegisterAddressSize I2CWriteRegisterParameter::register_address_size() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter.register_address_size)
  return static_cast< ::Kinova::Api::InterconnectConfig::I2CRegisterAddressSize >(register_address_size_);
}
inline void I2CWriteRegisterParameter::set_register_address_size(::Kinova::Api::InterconnectConfig::I2CRegisterAddressSize value) {
  
  register_address_size_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter.register_address_size)
}

// fixed32 timeout = 5;
inline void I2CWriteRegisterParameter::clear_timeout() {
  timeout_ = 0u;
}
inline ::google::protobuf::uint32 I2CWriteRegisterParameter::timeout() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter.timeout)
  return timeout_;
}
inline void I2CWriteRegisterParameter::set_timeout(::google::protobuf::uint32 value) {
  
  timeout_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter.timeout)
}

// .Kinova.Api.InterconnectConfig.I2CData data = 6;
inline bool I2CWriteRegisterParameter::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline void I2CWriteRegisterParameter::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) {
    delete data_;
  }
  data_ = NULL;
}
inline const ::Kinova::Api::InterconnectConfig::I2CData& I2CWriteRegisterParameter::data() const {
  const ::Kinova::Api::InterconnectConfig::I2CData* p = data_;
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter.data)
  return p != NULL ? *p : *reinterpret_cast<const ::Kinova::Api::InterconnectConfig::I2CData*>(
      &::Kinova::Api::InterconnectConfig::_I2CData_default_instance_);
}
inline ::Kinova::Api::InterconnectConfig::I2CData* I2CWriteRegisterParameter::release_data() {
  // @@protoc_insertion_point(field_release:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter.data)
  
  ::Kinova::Api::InterconnectConfig::I2CData* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::Kinova::Api::InterconnectConfig::I2CData* I2CWriteRegisterParameter::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::Kinova::Api::InterconnectConfig::I2CData;
  }
  // @@protoc_insertion_point(field_mutable:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter.data)
  return data_;
}
inline void I2CWriteRegisterParameter::set_allocated_data(::Kinova::Api::InterconnectConfig::I2CData* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_;
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.InterconnectConfig.I2CWriteRegisterParameter.data)
}

// -------------------------------------------------------------------

// I2CData

// bytes data = 1;
inline void I2CData::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& I2CData::data() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CData.data)
  return data_.GetNoArena();
}
inline void I2CData::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CData.data)
}
#if LANG_CXX11
inline void I2CData::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kinova.Api.InterconnectConfig.I2CData.data)
}
#endif
inline void I2CData::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kinova.Api.InterconnectConfig.I2CData.data)
}
inline void I2CData::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kinova.Api.InterconnectConfig.I2CData.data)
}
inline ::std::string* I2CData::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:Kinova.Api.InterconnectConfig.I2CData.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* I2CData::release_data() {
  // @@protoc_insertion_point(field_release:Kinova.Api.InterconnectConfig.I2CData.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void I2CData::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:Kinova.Api.InterconnectConfig.I2CData.data)
}

// fixed32 size = 2;
inline void I2CData::clear_size() {
  size_ = 0u;
}
inline ::google::protobuf::uint32 I2CData::size() const {
  // @@protoc_insertion_point(field_get:Kinova.Api.InterconnectConfig.I2CData.size)
  return size_;
}
inline void I2CData::set_size(::google::protobuf::uint32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:Kinova.Api.InterconnectConfig.I2CData.size)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace InterconnectConfig
}  // namespace Api
}  // namespace Kinova

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Kinova::Api::InterconnectConfig::ServiceVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::InterconnectConfig::ServiceVersion>() {
  return ::Kinova::Api::InterconnectConfig::ServiceVersion_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::InterconnectConfig::SafetyIdentifier> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::InterconnectConfig::SafetyIdentifier>() {
  return ::Kinova::Api::InterconnectConfig::SafetyIdentifier_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::InterconnectConfig::UARTPortId> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::InterconnectConfig::UARTPortId>() {
  return ::Kinova::Api::InterconnectConfig::UARTPortId_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::InterconnectConfig::EthernetDevice> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::InterconnectConfig::EthernetDevice>() {
  return ::Kinova::Api::InterconnectConfig::EthernetDevice_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::InterconnectConfig::EthernetSpeed> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::InterconnectConfig::EthernetSpeed>() {
  return ::Kinova::Api::InterconnectConfig::EthernetSpeed_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::InterconnectConfig::EthernetDuplex> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::InterconnectConfig::EthernetDuplex>() {
  return ::Kinova::Api::InterconnectConfig::EthernetDuplex_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::InterconnectConfig::GPIOIdentifier> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::InterconnectConfig::GPIOIdentifier>() {
  return ::Kinova::Api::InterconnectConfig::GPIOIdentifier_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::InterconnectConfig::GPIOMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::InterconnectConfig::GPIOMode>() {
  return ::Kinova::Api::InterconnectConfig::GPIOMode_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::InterconnectConfig::GPIOPull> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::InterconnectConfig::GPIOPull>() {
  return ::Kinova::Api::InterconnectConfig::GPIOPull_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::InterconnectConfig::GPIOValue> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::InterconnectConfig::GPIOValue>() {
  return ::Kinova::Api::InterconnectConfig::GPIOValue_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::InterconnectConfig::I2CDevice> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::InterconnectConfig::I2CDevice>() {
  return ::Kinova::Api::InterconnectConfig::I2CDevice_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::InterconnectConfig::I2CMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::InterconnectConfig::I2CMode>() {
  return ::Kinova::Api::InterconnectConfig::I2CMode_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::InterconnectConfig::I2CDeviceAddressing> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::InterconnectConfig::I2CDeviceAddressing>() {
  return ::Kinova::Api::InterconnectConfig::I2CDeviceAddressing_descriptor();
}
template <> struct is_proto_enum< ::Kinova::Api::InterconnectConfig::I2CRegisterAddressSize> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Kinova::Api::InterconnectConfig::I2CRegisterAddressSize>() {
  return ::Kinova::Api::InterconnectConfig::I2CRegisterAddressSize_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_InterconnectConfig_2eproto__INCLUDED
